0001   0000             ;************************************************************************
0002   0000             ;** An Assembly File Listing to generate a 16K ROM for the ZX Spectrum **
0003   0000             ;************************************************************************
0004   0000             
0005   0000             ; -------------------------
0006   0000             ; Last updated: 13-DEC-2004
0007   0000             ; -------------------------
0008   0000             
0009   0000             ; TASM cross-assembler directives. 
0010   0000             ; ( comment out, perhaps, for other assemblers - see Notes at end.)
0011   0000             
0012   0000             #define DEFB .BYTE      
0013   0000             #define DEFW .WORD
0014   0000             #define DEFM .TEXT
0015   0000             #define ORG  .ORG
0016   0000             #define EQU  .EQU
0017   0000             #define equ  .EQU
0018   0000             
0019   0000             ;   It is always a good idea to anchor, using ORGs, important sections such as 
0020   0000             ;   the character bitmaps so that they don't move as code is added and removed.
0021   0000             
0022   0000             ;   Generally most approaches try to maintain main entry points as they are
0023   0000             ;   often used by third-party software. 
0024   0000             
0025   0000             ORG 0000
0026   0000             
0027   0000             ;*****************************************
0028   0000             ;** Part 1. RESTART ROUTINES AND TABLES **
0029   0000             ;*****************************************
0030   0000             
0031   0000             ; -----------
0032   0000             ; THE 'START'
0033   0000             ; -----------
0034   0000             ;   At switch on, the Z80 chip is in Interrupt Mode 0.
0035   0000             ;   The Spectrum uses Interrupt Mode 1.
0036   0000             ;   This location can also be 'called' to reset the machine.
0037   0000             ;   Typically with PRINT USR 0.
0038   0000             
0039   0000             ;; START
0040   0000 F3          L0000:  DI                      ; Disable Interrupts.
0041   0001 AF                  XOR     A               ; Signal coming from START.
0042   0002 11 FF FF            LD      DE,$FFFF        ; Set pointer to top of possible physical RAM.
0043   0005 C3 FA 11            JP      L11CB           ; Jump forward to common code at START-NEW.
0044   0008             
0045   0008             ; -------------------
0046   0008             ; THE 'ERROR' RESTART
0047   0008             ; -------------------
0048   0008             ;   The error pointer is made to point to the position of the error to enable
0049   0008             ;   the editor to highlight the error position if it occurred during syntax 
0050   0008             ;   checking.  It is used at 37 places in the program.  An instruction fetch 
0051   0008             ;   on address $0008 may page in a peripheral ROM such as the Sinclair 
0052   0008             ;   Interface 1 or Disciple Disk Interface.  This was not an original design 
0053   0008             ;   concept and not all errors pass through here.
0054   0008             
0055   0008             ;; ERROR-1
0056   0008 2A 5D 5C    L0008:  LD      HL,($5C5D)      ; Fetch the character address from CH_ADD.
0057   000B 22 5F 5C            LD      ($5C5F),HL      ; Copy it to the error pointer X_PTR.
0058   000E 18 43               JR      L0053           ; Forward to continue at ERROR-2.
0059   0010             
0060   0010             ; -----------------------------
0061   0010             ; THE 'PRINT CHARACTER' RESTART
0062   0010             ; -----------------------------
0063   0010             ;   The A register holds the code of the character that is to be sent to
0064   0010             ;   the output stream of the current channel.  The alternate register set is 
0065   0010             ;   used to output a character in the A register so there is no need to 
0066   0010             ;   preserve any of the current main registers (HL, DE, BC).  
0067   0010             ;   This restart is used 21 times.
0068   0010             
0069   0010             ;; PRINT-A
0070   0010 C3 21 16    L0010:  JP      L15F2           ; Jump forward to continue at PRINT-A-2.
0071   0013             
0072   0013             ; ---
0073   0013             
0074   0013 FF FF FF            DEFB    $FF, $FF, $FF   ; Five unused locations.
0075   0016 FF FF               DEFB    $FF, $FF        ;
0076   0018             
0077   0018             ; -------------------------------
0078   0018             ; THE 'COLLECT CHARACTER' RESTART
0079   0018             ; -------------------------------
0080   0018             ;   The contents of the location currently addressed by CH_ADD are fetched.
0081   0018             ;   A return is made if the value represents a character that has
0082   0018             ;   relevance to the BASIC parser. Otherwise CH_ADD is incremented and the
0083   0018             ;   tests repeated. CH_ADD will be addressing somewhere -
0084   0018             ;   1) in the BASIC program area during line execution.
0085   0018             ;   2) in workspace if evaluating, for example, a string expression.
0086   0018             ;   3) in the edit buffer if parsing a direct command or a new BASIC line.
0087   0018             ;   4) in workspace if accepting input but not that from INPUT LINE.
0088   0018             
0089   0018             ;; GET-CHAR
0090   0018 2A 5D 5C    L0018:  LD      HL,($5C5D)      ; fetch the address from CH_ADD.
0091   001B 7E                  LD      A,(HL)          ; use it to pick up current character.
0092   001C             
0093   001C             ;; TEST-CHAR
0094   001C CD 7D 00    L001C:  CALL    L007D           ; routine SKIP-OVER tests if the character is
0095   001F                                             ; relevant.
0096   001F D0                  RET     NC              ; Return if it is significant.
0097   0020             
0098   0020             ; ------------------------------------
0099   0020             ; THE 'COLLECT NEXT CHARACTER' RESTART
0100   0020             ; ------------------------------------
0101   0020             ;   As the BASIC commands and expressions are interpreted, this routine is
0102   0020             ;   called repeatedly to step along the line.  It is used 83 times.
0103   0020             
0104   0020             ;; NEXT-CHAR
0105   0020 CD 74 00    L0020:  CALL    L0074           ; routine CH-ADD+1 fetches the next immediate
0106   0023                                             ; character.
0107   0023 18 F7               JR      L001C           ; jump back to TEST-CHAR until a valid
0108   0025                                             ; character is found.
0109   0025             
0110   0025             ; ---
0111   0025             
0112   0025 FF FF FF            DEFB    $FF, $FF, $FF   ; unused
0113   0028             
0114   0028             ; -----------------------
0115   0028             ; THE 'CALCULATE' RESTART
0116   0028             ; -----------------------
0117   0028             ;   This restart enters the Spectrum's internal, floating-point, stack-based, 
0118   0028             ;   FORTH-like language.
0119   0028             ;   It is further used recursively from within the calculator.
0120   0028             ;   It is used on 77 occasions.
0121   0028             
0122   0028             ;; FP-CALC
0123   0028 C3 8A 33    L0028:  JP      L335B           ; jump forward to the CALCULATE routine.
0124   002B             
0125   002B             ; ---
0126   002B             
0127   002B FF FF FF            DEFB    $FF, $FF, $FF   ; spare - note that on the ZX81, space being a 
0128   002E FF FF               DEFB    $FF, $FF        ; little cramped, these same locations were
0129   0030                                             ; used for the five-byte end-calc literal.
0130   0030             
0131   0030             ; ------------------------------
0132   0030             ; THE 'CREATE BC SPACES' RESTART
0133   0030             ; ------------------------------
0134   0030             ;   This restart is used on only 12 occasions to create BC spaces
0135   0030             ;   between workspace and the calculator stack.
0136   0030             
0137   0030             ;; BC-SPACES
0138   0030 C5          L0030:  PUSH    BC              ; Save number of spaces.
0139   0031 2A 61 5C            LD      HL,($5C61)      ; Fetch WORKSP.
0140   0034 E5                  PUSH    HL              ; Save address of workspace.
0141   0035 C3 CD 16            JP      L169E           ; Jump forward to continuation code RESERVE.
0142   0038             
0143   0038             ; --------------------------------
0144   0038             ; THE 'MASKABLE INTERRUPT' ROUTINE
0145   0038             ; --------------------------------
0146   0038             ;   This routine increments the Spectrum's three-byte FRAMES counter fifty 
0147   0038             ;   times a second (sixty times a second in the USA ).
0148   0038             ;   Both this routine and the called KEYBOARD subroutine use the IY register 
0149   0038             ;   to access system variables and flags so a user-written program must 
0150   0038             ;   disable interrupts to make use of the IY register.
0151   0038             
0152   0038             ;; MASK-INT
0153   0038 F5          L0038:  PUSH    AF              ; Save the registers that will be used but not
0154   0039 E5                  PUSH    HL              ; the IY register unfortunately.
0155   003A 2A 78 5C            LD      HL,($5C78)      ; Fetch the first two bytes at FRAMES1.
0156   003D 23                  INC     HL              ; Increment lowest two bytes of counter.
0157   003E 22 78 5C            LD      ($5C78),HL      ; Place back in FRAMES1.
0158   0041 7C                  LD      A,H             ; Test if the result was zero.
0159   0042 B5                  OR      L               ;            
0160   0043 20 03               JR      NZ,L0048        ; Forward, if not, to KEY-INT
0161   0045             
0162   0045 FD 34 40            INC     (IY+$40)        ; otherwise increment FRAMES3 the third byte.
0163   0048             
0164   0048             ;   Now save the rest of the main registers and read and decode the keyboard.
0165   0048             
0166   0048             ;; KEY-INT
0167   0048 C5          L0048:  PUSH    BC              ; Save the other main registers.
0168   0049 D5                  PUSH    DE              ;                 
0169   004A             
0170   004A CD D0 02            CALL    L02BF           ; Routine KEYBOARD executes a stage in the 
0171   004D                                             ; process of reading a key-press.
0172   004D D1                  POP     DE              ;
0173   004E C1                  POP     BC              ; Restore registers.
0174   004F             
0175   004F E1                  POP     HL              ;
0176   0050 F1                  POP     AF              ;
0177   0051             
0178   0051 FB                  EI                      ; Enable Interrupts.
0179   0052 C9                  RET                     ; Return.
0180   0053             
0181   0053             ; ---------------------
0182   0053             ; THE 'ERROR-2' ROUTINE
0183   0053             ; ---------------------
0184   0053             ;   A continuation of the code at 0008.
0185   0053             ;   The error code is stored and after clearing down stacks, an indirect jump 
0186   0053             ;   is made to MAIN-4, etc. to handle the error.
0187   0053             
0188   0053             ;; ERROR-2
0189   0053 E1          L0053:  POP     HL              ; drop the return address - the location
0190   0054                                             ; after the RST 08H instruction.
0191   0054 6E                  LD      L,(HL)          ; fetch the error code that follows.
0192   0055                                             ; (nice to see this instruction used.)
0193   0055             
0194   0055             ;   Note. this entry point is used when out of memory at REPORT-4.
0195   0055             ;   The L register has been loaded with the report code but X-PTR is not
0196   0055             ;   updated.
0197   0055             
0198   0055             ;; ERROR-3
0199   0055 FD 75 00    L0055:  LD      (IY+$00),L      ; Store it in the system variable ERR_NR.
0200   0058 ED 7B 3D 5C         LD      SP,($5C3D)      ; ERR_SP points to an error handler on the
0201   005C                                             ; machine stack. There may be a hierarchy
0202   005C                                             ; of routines.
0203   005C                                             ; To MAIN-4 initially at base.
0204   005C                                             ; or REPORT-G on line entry.
0205   005C                                             ; or  ED-ERROR when editing.
0206   005C                                             ; or   ED-FULL during ed-enter.
0207   005C                                             ; or  IN-VAR-1 during runtime input etc.
0208   005C             
0209   005C C3 F4 16            JP      L16C5           ; Jump to SET-STK to clear the calculator stack 
0210   005F                                             ; and reset MEM to usual place in the systems 
0211   005F                                             ; variables area and then indirectly to MAIN-4, 
0212   005F                                             ; etc.
0213   005F             
0214   005F             ; ---
0215   005F             
0216   005F FF FF FF            DEFB    $FF, $FF, $FF   ; Unused locations
0217   0062 FF FF FF            DEFB    $FF, $FF, $FF   ; before the fixed-position
0218   0065 FF                  DEFB    $FF             ; NMI routine.
0219   0066             
0220   0066             ; ------------------------------------
0221   0066             ; THE 'NON-MASKABLE INTERRUPT' ROUTINE
0222   0066             ; ------------------------------------
0223   0066             ;   New
0224   0066             ;   There is no NMI switch on the standard Spectrum or its peripherals.
0225   0066             ;   When the NMI line is held low, then no matter what the Z80 was doing at 
0226   0066             ;   the time, it will now execute the code at 66 Hex.
0227   0066             ;   This Interrupt Service Routine will jump to location zero if the contents 
0228   0066             ;   of the system variable NMIADD are zero or return if the location holds a
0229   0066             ;   non-zero address.   So attaching a simple switch to the NMI as in the book 
0230   0066             ;   "Spectrum Hardware Manual" causes a reset.  The logic was obviously 
0231   0066             ;   intended to work the other way.  Sinclair Research said that, since they
0232   0066             ;   had never advertised the NMI, they had no plans to fix the error "until 
0233   0066             ;   the opportunity arose".
0234   0066             ;   
0235   0066             ;   Note. The location NMIADD was, in fact, later used by Sinclair Research 
0236   0066             ;   to enhance the text channel on the ZX Interface 1.
0237   0066             ;   On later Amstrad-made Spectrums, and the Brazilian Spectrum, the logic of 
0238   0066             ;   this routine was indeed reversed but not as at first intended.
0239   0066             ;
0240   0066             ;   It can be deduced by looking elsewhere in this ROM that the NMIADD system
0241   0066             ;   variable pointed to L121C and that this enabled a Warm Restart to be 
0242   0066             ;   performed at any time, even while playing machine code games, or while 
0243   0066             ;   another Spectrum has been allowed to gain control of this one. 
0244   0066             ;
0245   0066             ;   Software houses would have been able to protect their games from attack by
0246   0066             ;   placing two zeros in the NMIADD system variable.
0247   0066             
0248   0066             ;; RESET
0249   0066 F5          L0066:  PUSH    AF              ; save the
0250   0067 E5                  PUSH    HL              ; registers.
0251   0068 2A B0 5C            LD      HL,($5CB0)      ; fetch the system variable NMIADD.
0252   006B 7C                  LD      A,H             ; test address
0253   006C B5                  OR      L               ; for zero.
0254   006D             
0255   006D 20 01               JR      NZ,L0070        ; skip to NO-RESET if NOT ZERO
0256   006F             
0257   006F E9                  JP      (HL)            ; jump to routine ( i.e. L0000 )
0258   0070             
0259   0070             ;; NO-RESET
0260   0070 E1          L0070:  POP     HL              ; restore the
0261   0071 F1                  POP     AF              ; registers.
0262   0072 ED 45               RETN                    ; return to previous interrupt state.
0263   0074             
0264   0074             ; ---------------------------
0265   0074             ; THE 'CH ADD + 1' SUBROUTINE
0266   0074             ; ---------------------------
0267   0074             ;   This subroutine is called from RST 20, and three times from elsewhere
0268   0074             ;   to fetch the next immediate character following the current valid character
0269   0074             ;   address and update the associated system variable.
0270   0074             ;   The entry point TEMP-PTR1 is used from the SCANNING routine.
0271   0074             ;   Both TEMP-PTR1 and TEMP-PTR2 are used by the READ command routine.
0272   0074             
0273   0074             ;; CH-ADD+1
0274   0074 2A 5D 5C    L0074:  LD      HL,($5C5D)      ; fetch address from CH_ADD.
0275   0077             
0276   0077             ;; TEMP-PTR1
0277   0077 23          L0077:  INC     HL              ; increase the character address by one.
0278   0078             
0279   0078             ;; TEMP-PTR2
0280   0078 22 5D 5C    L0078:  LD      ($5C5D),HL      ; update CH_ADD with character address.
0281   007B             
0282   007B 7E          X007B:  LD      A,(HL)          ; load character to A from HL.
0283   007C C9                  RET                     ; and return.
0284   007D             
0285   007D             ; --------------------------
0286   007D             ; THE 'SKIP OVER' SUBROUTINE
0287   007D             ; --------------------------
0288   007D             ;   This subroutine is called once from RST 18 to skip over white-space and
0289   007D             ;   other characters irrelevant to the parsing of a BASIC line etc. .
0290   007D             ;   Initially the A register holds the character to be considered
0291   007D             ;   and HL holds its address which will not be within quoted text
0292   007D             ;   when a BASIC line is parsed.
0293   007D             ;   Although the 'tab' and 'at' characters will not appear in a BASIC line,
0294   007D             ;   they could be present in a string expression, and in other situations.
0295   007D             ;   Note. although white-space is usually placed in a program to indent loops
0296   007D             ;   and make it more readable, it can also be used for the opposite effect and
0297   007D             ;   spaces may appear in variable names although the parser never sees them.
0298   007D             ;   It is this routine that helps make the variables 'Anum bEr5 3BUS' and
0299   007D             ;   'a number 53 bus' appear the same to the parser.
0300   007D             
0301   007D             ;; SKIP-OVER
0302   007D FE 21       L007D:  CP      $21             ; test if higher than space.
0303   007F D0                  RET     NC              ; return with carry clear if so.
0304   0080             
0305   0080 FE 0D               CP      $0D             ; carriage return ?
0306   0082 C8                  RET     Z               ; return also with carry clear if so.
0307   0083             
0308   0083                                             ; all other characters have no relevance
0309   0083                                             ; to the parser and must be returned with
0310   0083                                             ; carry set.
0311   0083             
0312   0083 FE 10               CP      $10             ; test if 0-15d
0313   0085 D8                  RET     C               ; return, if so, with carry set.
0314   0086             
0315   0086 FE 18               CP      $18             ; test if 24-32d
0316   0088 3F                  CCF                     ; complement carry flag.
0317   0089 D8                  RET     C               ; return with carry set if so.
0318   008A             
0319   008A                                             ; now leaves 16d-23d
0320   008A             
0321   008A 23                  INC     HL              ; all above have at least one extra character
0322   008B                                             ; to be stepped over.
0323   008B             
0324   008B FE 16               CP      $16             ; controls 22d ('at') and 23d ('tab') have two.
0325   008D 38 01               JR      C,L0090         ; forward to SKIPS with ink, paper, flash,
0326   008F                                             ; bright, inverse or over controls.
0327   008F                                             ; Note. the high byte of tab is for RS232 only.
0328   008F                                             ; it has no relevance on this machine.
0329   008F             
0330   008F 23                  INC     HL              ; step over the second character of 'at'/'tab'.
0331   0090             
0332   0090             ;; SKIPS
0333   0090 37          L0090:  SCF                     ; set the carry flag
0334   0091 22 5D 5C            LD      ($5C5D),HL      ; update the CH_ADD system variable.
0335   0094 C9                  RET                     ; return with carry set.
0336   0095             
0337   0095             
0338   0095             ; ------------------
0339   0095             ; THE 'TOKEN' TABLES
0340   0095             ; ------------------
0341   0095             ;   The tokenized characters 134d (RND) to 255d (COPY) are expanded using
0342   0095             ;   this table. The last byte of a token is inverted to denote the end of
0343   0095             ;   the word. The first is an inverted step-over byte.
0344   0095             
0345   0095             ;; TKN-TABLE
0346   0095 BF          L0095:  DEFB    '?'+$80
0347   0096 52 4E               DEFM    "RN"
0348   0098 C4                  DEFB    'D'+$80
0349   0099 49 4E 4B 45         DEFM    "INKEY"
0349   009D 59 
0350   009E A4                  DEFB    '$'+$80
0351   009F 50 C9               DEFB    'P','I'+$80
0352   00A1 46 CE               DEFB    'F','N'+$80
0353   00A3 50 4F 49 4E         DEFM    "POIN"
0354   00A7 D4                  DEFB    'T'+$80
0355   00A8 53 43 52 45         DEFM    "SCREEN"
0355   00AC 45 4E 
0356   00AE A4                  DEFB    '$'+$80
0357   00AF 41 54 54            DEFM    "ATT"
0358   00B2 D2                  DEFB    'R'+$80
0359   00B3 41 D4               DEFB    'A','T'+$80
0360   00B5 54 41               DEFM    "TA"
0361   00B7 C2                  DEFB    'B'+$80
0362   00B8 56 41 4C            DEFM    "VAL"
0363   00BB A4                  DEFB    '$'+$80
0364   00BC 43 4F 44            DEFM    "COD"
0365   00BF C5                  DEFB    'E'+$80
0366   00C0 56 41               DEFM    "VA"
0367   00C2 CC                  DEFB    'L'+$80
0368   00C3 4C 45               DEFM    "LE"
0369   00C5 CE                  DEFB    'N'+$80
0370   00C6 53 49               DEFM    "SI"
0371   00C8 CE                  DEFB    'N'+$80
0372   00C9 43 4F               DEFM    "CO"
0373   00CB D3                  DEFB    'S'+$80
0374   00CC 54 41               DEFM    "TA"
0375   00CE CE                  DEFB    'N'+$80
0376   00CF 41 53               DEFM    "AS"
0377   00D1 CE                  DEFB    'N'+$80
0378   00D2 41 43               DEFM    "AC"
0379   00D4 D3                  DEFB    'S'+$80
0380   00D5 41 54               DEFM    "AT"
0381   00D7 CE                  DEFB    'N'+$80
0382   00D8 4C CE               DEFB    'L','N'+$80
0383   00DA 45 58               DEFM    "EX"
0384   00DC D0                  DEFB    'P'+$80
0385   00DD 49 4E               DEFM    "IN"
0386   00DF D4                  DEFB    'T'+$80
0387   00E0 53 51               DEFM    "SQ"
0388   00E2 D2                  DEFB    'R'+$80
0389   00E3 53 47               DEFM    "SG"
0390   00E5 CE                  DEFB    'N'+$80
0391   00E6 41 42               DEFM    "AB"
0392   00E8 D3                  DEFB    'S'+$80
0393   00E9 50 45 45            DEFM    "PEE"
0394   00EC CB                  DEFB    'K'+$80
0395   00ED 49 CE               DEFB    'I','N'+$80
0396   00EF 55 53               DEFM    "US"
0397   00F1 D2                  DEFB    'R'+$80
0398   00F2 53 54 52            DEFM    "STR"
0399   00F5 A4                  DEFB    '$'+$80
0400   00F6 43 48 52            DEFM    "CHR"
0401   00F9 A4                  DEFB    '$'+$80
0402   00FA 4E 4F               DEFM    "NO"
0403   00FC D4                  DEFB    'T'+$80
0404   00FD 42 49               DEFM    "BI"
0405   00FF CE                  DEFB    'N'+$80
0406   0100             
0407   0100             ;   The previous 32 function-type words are printed without a leading space
0408   0100             ;   The following have a leading space if they begin with a letter
0409   0100             
0410   0100 4F D2               DEFB    'O','R'+$80
0411   0102 41 4E               DEFM    "AN"
0412   0104 C4                  DEFB    'D'+$80
0413   0105 3C BD               DEFB    $3C,'='+$80             ; <=
0414   0107 3E BD               DEFB    $3E,'='+$80             ; >=
0415   0109 3C BE               DEFB    $3C,$3E+$80             ; <>
0416   010B 4C 49 4E            DEFM    "LIN"
0417   010E C5                  DEFB    'E'+$80
0418   010F 54 48 45            DEFM    "THE"
0419   0112 CE                  DEFB    'N'+$80
0420   0113 54 CF               DEFB    'T','O'+$80
0421   0115 53 54 45            DEFM    "STE"
0422   0118 D0                  DEFB    'P'+$80
0423   0119 44 45 46 20         DEFM    "DEF F"
0423   011D 46 
0424   011E CE                  DEFB    'N'+$80
0425   011F 43 41               DEFM    "CA"
0426   0121 D4                  DEFB    'T'+$80
0427   0122 46 4F 52 4D         DEFM    "FORMA"
0427   0126 41 
0428   0127 D4                  DEFB    'T'+$80
0429   0128 4D 4F 56            DEFM    "MOV"
0430   012B C5                  DEFB    'E'+$80
0431   012C 45 52 41 53         DEFM    "ERAS"
0432   0130 C5                  DEFB    'E'+$80
0433   0131 4F 50 45 4E         DEFM    "OPEN "
0433   0135 20 
0434   0136 A3                  DEFB    '#'+$80
0435   0137 43 4C 4F 53         DEFM    "CLOSE "
0435   013B 45 20 
0436   013D A3                  DEFB    '#'+$80
0437   013E 4D 45 52 47         DEFM    "MERG"
0438   0142 C5                  DEFB    'E'+$80
0439   0143 56 45 52 49         DEFM    "VERIF"
0439   0147 46 
0440   0148 D9                  DEFB    'Y'+$80
0441   0149 42 45 45            DEFM    "BEE"
0442   014C D0                  DEFB    'P'+$80
0443   014D 43 49 52 43         DEFM    "CIRCL"
0443   0151 4C 
0444   0152 C5                  DEFB    'E'+$80
0445   0153 49 4E               DEFM    "IN"
0446   0155 CB                  DEFB    'K'+$80
0447   0156 50 41 50 45         DEFM    "PAPE"
0448   015A D2                  DEFB    'R'+$80
0449   015B 46 4C 41 53         DEFM    "FLAS"
0450   015F C8                  DEFB    'H'+$80
0451   0160 42 52 49 47         DEFM    "BRIGH"
0451   0164 48 
0452   0165 D4                  DEFB    'T'+$80
0453   0166 49 4E 56 45         DEFM    "INVERS"
0453   016A 52 53 
0454   016C C5                  DEFB    'E'+$80
0455   016D 4F 56 45            DEFM    "OVE"
0456   0170 D2                  DEFB    'R'+$80
0457   0171 4F 55               DEFM    "OU"
0458   0173 D4                  DEFB    'T'+$80
0459   0174 4C 50 52 49         DEFM    "LPRIN"
0459   0178 4E 
0460   0179 D4                  DEFB    'T'+$80
0461   017A 4C 4C 49 53         DEFM    "LLIS"
0462   017E D4                  DEFB    'T'+$80
0463   017F 53 54 4F            DEFM    "STO"
0464   0182 D0                  DEFB    'P'+$80
0465   0183 52 45 41            DEFM    "REA"
0466   0186 C4                  DEFB    'D'+$80
0467   0187 44 41 54            DEFM    "DAT"
0468   018A C1                  DEFB    'A'+$80
0469   018B 52 45 53 54         DEFM    "RESTOR"
0469   018F 4F 52 
0470   0191 C5                  DEFB    'E'+$80
0471   0192 4E 45               DEFM    "NE"
0472   0194 D7                  DEFB    'W'+$80
0473   0195 42 4F 52 44         DEFM    "BORDE"
0473   0199 45 
0474   019A D2                  DEFB    'R'+$80
0475   019B 43 4F 4E 54         DEFM    "CONTINU"
0475   019F 49 4E 55 
0476   01A2 C5                  DEFB    'E'+$80
0477   01A3 44 49               DEFM    "DI"
0478   01A5 CD                  DEFB    'M'+$80
0479   01A6 52 45               DEFM    "RE"
0480   01A8 CD                  DEFB    'M'+$80
0481   01A9 46 4F               DEFM    "FO"
0482   01AB D2                  DEFB    'R'+$80
0483   01AC 47 4F 20 54         DEFM    "GO T"
0484   01B0 CF                  DEFB    'O'+$80
0485   01B1 47 4F 20 53         DEFM    "GO SU"
0485   01B5 55 
0486   01B6 C2                  DEFB    'B'+$80
0487   01B7 49 4E 50 55         DEFM    "INPU"
0488   01BB D4                  DEFB    'T'+$80
0489   01BC 4C 4F 41            DEFM    "LOA"
0490   01BF C4                  DEFB    'D'+$80
0491   01C0 4C 49 53            DEFM    "LIS"
0492   01C3 D4                  DEFB    'T'+$80
0493   01C4 4C 45               DEFM    "LE"
0494   01C6 D4                  DEFB    'T'+$80
0495   01C7 50 41 55 53         DEFM    "PAUS"
0496   01CB C5                  DEFB    'E'+$80
0497   01CC 4E 45 58            DEFM    "NEX"
0498   01CF D4                  DEFB    'T'+$80
0499   01D0 50 4F 4B            DEFM    "POK"
0500   01D3 C5                  DEFB    'E'+$80
0501   01D4 50 52 49 4E         DEFM    "PRIN"
0502   01D8 D4                  DEFB    'T'+$80
0503   01D9 50 4C 4F            DEFM    "PLO"
0504   01DC D4                  DEFB    'T'+$80
0505   01DD 52 55               DEFM    "RU"
0506   01DF CE                  DEFB    'N'+$80
0507   01E0 53 41 56            DEFM    "SAV"
0508   01E3 C5                  DEFB    'E'+$80
0509   01E4 52 41 4E 44         DEFM    "RANDOMIZ"
0509   01E8 4F 4D 49 5A 
0510   01EC C5                  DEFB    'E'+$80
0511   01ED 49 C6               DEFB    'I','F'+$80
0512   01EF 43 4C               DEFM    "CL"
0513   01F1 D3                  DEFB    'S'+$80
0514   01F2 44 52 41            DEFM    "DRA"
0515   01F5 D7                  DEFB    'W'+$80
0516   01F6 43 4C 45 41         DEFM    "CLEA"
0517   01FA D2                  DEFB    'R'+$80
0518   01FB 52 45 54 55         DEFM    "RETUR"
0518   01FF 52 
0519   0200 CE                  DEFB    'N'+$80
0520   0201 43 4F 50            DEFM    "COP"
0521   0204 D9                  DEFB    'Y'+$80
0522   0205             
0523   0205             ; ----------------
0524   0205             ; THE 'KEY' TABLES
0525   0205             ; ----------------
0526   0205             ;   These six look-up tables are used by the keyboard reading routine
0527   0205             ;   to decode the key values.
0528   0205             ;
0529   0205             ;   The first table contains the maps for the 39 keys of the standard
0530   0205             ;   40-key Spectrum keyboard. The remaining key [SHIFT $27] is read directly.
0531   0205             ;   The keys consist of the 26 upper-case alphabetic characters, the 10 digit
0532   0205             ;   keys and the space, ENTER and symbol shift key.
0533   0205             ;   Unshifted alphabetic keys have $20 added to the value.
0534   0205             ;   The keywords for the main alphabetic keys are obtained by adding $A5 to
0535   0205             ;   the values obtained from this table.
0536   0205             
0537   0205             ;; MAIN-KEYS
0538   0205 42          L0205:  DEFB    $42             ; B
0539   0206 48                  DEFB    $48             ; H
0540   0207 59                  DEFB    $59             ; Y
0541   0208 36                  DEFB    $36             ; 6
0542   0209 35                  DEFB    $35             ; 5
0543   020A 54                  DEFB    $54             ; T
0544   020B 47                  DEFB    $47             ; G
0545   020C 56                  DEFB    $56             ; V
0546   020D 4E                  DEFB    $4E             ; N
0547   020E 4A                  DEFB    $4A             ; J
0548   020F 55                  DEFB    $55             ; U
0549   0210 37                  DEFB    $37             ; 7
0550   0211 34                  DEFB    $34             ; 4
0551   0212 52                  DEFB    $52             ; R
0552   0213 46                  DEFB    $46             ; F
0553   0214 43                  DEFB    $43             ; C
0554   0215 4D                  DEFB    $4D             ; M
0555   0216 4B                  DEFB    $4B             ; K
0556   0217 49                  DEFB    $49             ; I
0557   0218 38                  DEFB    $38             ; 8
0558   0219 33                  DEFB    $33             ; 3
0559   021A 45                  DEFB    $45             ; E
0560   021B 44                  DEFB    $44             ; D
0561   021C 58                  DEFB    $58             ; X
0562   021D 0E                  DEFB    $0E             ; SYMBOL SHIFT
0563   021E 4C                  DEFB    $4C             ; L
0564   021F 4F                  DEFB    $4F             ; O
0565   0220 39                  DEFB    $39             ; 9
0566   0221 32                  DEFB    $32             ; 2
0567   0222 57                  DEFB    $57             ; W
0568   0223 53                  DEFB    $53             ; S
0569   0224 5A                  DEFB    $5A             ; Z
0570   0225 20                  DEFB    $20             ; SPACE
0571   0226 0D                  DEFB    $0D             ; ENTER
0572   0227 50                  DEFB    $50             ; P
0573   0228 30                  DEFB    $30             ; 0
0574   0229 31                  DEFB    $31             ; 1
0575   022A 51                  DEFB    $51             ; Q
0576   022B 41                  DEFB    $41             ; A
0577   022C             
0578   022C             
0579   022C             ;; E-UNSHIFT
0580   022C             ;  The 26 unshifted extended mode keys for the alphabetic characters.
0581   022C             ;  The green keywords on the original keyboard.
0582   022C E3          L022C:  DEFB    $E3             ; READ
0583   022D C4                  DEFB    $C4             ; BIN
0584   022E E0                  DEFB    $E0             ; LPRINT
0585   022F E4                  DEFB    $E4             ; DATA
0586   0230 B4                  DEFB    $B4             ; TAN
0587   0231 BC                  DEFB    $BC             ; SGN
0588   0232 BD                  DEFB    $BD             ; ABS
0589   0233 BB                  DEFB    $BB             ; SQR
0590   0234 AF                  DEFB    $AF             ; CODE
0591   0235 B0                  DEFB    $B0             ; VAL
0592   0236 B1                  DEFB    $B1             ; LEN
0593   0237 C0                  DEFB    $C0             ; USR
0594   0238 A7                  DEFB    $A7             ; PI
0595   0239 A6                  DEFB    $A6             ; INKEY$
0596   023A BE                  DEFB    $BE             ; PEEK
0597   023B AD                  DEFB    $AD             ; TAB
0598   023C B2                  DEFB    $B2             ; SIN
0599   023D BA                  DEFB    $BA             ; INT
0600   023E E5                  DEFB    $E5             ; RESTORE
0601   023F A5                  DEFB    $A5             ; RND
0602   0240 C2                  DEFB    $C2             ; CHR$
0603   0241 E1                  DEFB    $E1             ; LLIST
0604   0242 B3                  DEFB    $B3             ; COS
0605   0243 B9                  DEFB    $B9             ; EXP
0606   0244 C1                  DEFB    $C1             ; STR$
0607   0245 B8                  DEFB    $B8             ; LN
0608   0246             
0609   0246             
0610   0246             ;; EXT-SHIFT
0611   0246             ;  The 26 shifted extended mode keys for the alphabetic characters.
0612   0246             ;  The red keywords below keys on the original keyboard.
0613   0246 7E          L0246:  DEFB    $7E             ; ~
0614   0247 DC                  DEFB    $DC             ; BRIGHT
0615   0248 DA                  DEFB    $DA             ; PAPER
0616   0249 5C                  DEFB    $5C             ; \
0617   024A B7                  DEFB    $B7             ; ATN
0618   024B 7B                  DEFB    $7B             ; {
0619   024C 7D                  DEFB    $7D             ; }
0620   024D D8                  DEFB    $D8             ; CIRCLE
0621   024E BF                  DEFB    $BF             ; IN
0622   024F AE                  DEFB    $AE             ; VAL$
0623   0250 AA                  DEFB    $AA             ; SCREEN$
0624   0251 AB                  DEFB    $AB             ; ATTR
0625   0252 DD                  DEFB    $DD             ; INVERSE
0626   0253 DE                  DEFB    $DE             ; OVER
0627   0254 DF                  DEFB    $DF             ; OUT
0628   0255 7F                  DEFB    $7F             ; (Copyright character)
0629   0256 B5                  DEFB    $B5             ; ASN
0630   0257 D6                  DEFB    $D6             ; VERIFY
0631   0258 7C                  DEFB    $7C             ; |
0632   0259 D5                  DEFB    $D5             ; MERGE
0633   025A 5D                  DEFB    $5D             ; ]
0634   025B DB                  DEFB    $DB             ; FLASH
0635   025C B6                  DEFB    $B6             ; ACS
0636   025D D9                  DEFB    $D9             ; INK
0637   025E 5B                  DEFB    $5B             ; [
0638   025F D7                  DEFB    $D7             ; BEEP
0639   0260             
0640   0260             
0641   0260             ;; CTL-CODES
0642   0260             ;  The ten control codes assigned to the top line of digits when the shift 
0643   0260             ;  key is pressed.
0644   0260 0C          L0260:  DEFB    $0C             ; DELETE
0645   0261 07                  DEFB    $07             ; EDIT
0646   0262 06                  DEFB    $06             ; CAPS LOCK
0647   0263 04                  DEFB    $04             ; TRUE VIDEO
0648   0264 05                  DEFB    $05             ; INVERSE VIDEO
0649   0265 08                  DEFB    $08             ; CURSOR LEFT
0650   0266 0A                  DEFB    $0A             ; CURSOR DOWN
0651   0267 0B                  DEFB    $0B             ; CURSOR UP
0652   0268 09                  DEFB    $09             ; CURSOR RIGHT
0653   0269 0F                  DEFB    $0F             ; GRAPHICS
0654   026A             
0655   026A             
0656   026A             ;; SYM-CODES
0657   026A             ;  The 26 red symbols assigned to the alphabetic characters of the keyboard.
0658   026A             ;  The ten single-character digit symbols are converted without the aid of
0659   026A             ;  a table using subtraction and minor manipulation. 
0660   026A E2          L026A:  DEFB    $E2             ; STOP
0661   026B 2A                  DEFB    $2A             ; *
0662   026C 3F                  DEFB    $3F             ; ?
0663   026D CD                  DEFB    $CD             ; STEP
0664   026E C8                  DEFB    $C8             ; >=
0665   026F CC                  DEFB    $CC             ; TO
0666   0270 CB                  DEFB    $CB             ; THEN
0667   0271 5E                  DEFB    $5E             ; ^
0668   0272 AC                  DEFB    $AC             ; AT
0669   0273 2D                  DEFB    $2D             ; -
0670   0274 2B                  DEFB    $2B             ; +
0671   0275 3D                  DEFB    $3D             ; =
0672   0276 2E                  DEFB    $2E             ; .
0673   0277 2C                  DEFB    $2C             ; ,
0674   0278 3B                  DEFB    $3B             ; ;
0675   0279 22                  DEFB    $22             ; "
0676   027A C7                  DEFB    $C7             ; <=
0677   027B 3C                  DEFB    $3C             ; <
0678   027C C3                  DEFB    $C3             ; NOT
0679   027D 3E                  DEFB    $3E             ; >
0680   027E C5                  DEFB    $C5             ; OR
0681   027F 2F                  DEFB    $2F             ; /
0682   0280 C9                  DEFB    $C9             ; <>
0683   0281 60                  DEFB    $60             ; pound
0684   0282 C6                  DEFB    $C6             ; AND
0685   0283 3A                  DEFB    $3A             ; :
0686   0284             
0687   0284             ;; E-DIGITS
0688   0284             ;  The ten keywords assigned to the digits in extended mode.
0689   0284             ;  The remaining red keywords below the keys.
0690   0284 D0          L0284:  DEFB    $D0             ; FORMAT
0691   0285 CE                  DEFB    $CE             ; DEF FN
0692   0286 A8                  DEFB    $A8             ; FN
0693   0287 CA                  DEFB    $CA             ; LINE
0694   0288 D3                  DEFB    $D3             ; OPEN #
0695   0289 D4                  DEFB    $D4             ; CLOSE #
0696   028A D1                  DEFB    $D1             ; MOVE
0697   028B D2                  DEFB    $D2             ; ERASE
0698   028C A9                  DEFB    $A9             ; POINT
0699   028D CF                  DEFB    $CF             ; CAT
0700   028E             
0701   028E             
0702   028E             ;*******************************
0703   028E             ;** Part 2. KEYBOARD ROUTINES **
0704   028E             ;*******************************
0705   028E             
0706   028E             ;   Using shift keys and a combination of modes the Spectrum 40-key keyboard
0707   028E             ;   can be mapped to 256 input characters
0708   028E             
0709   028E             ; ---------------------------------------------------------------------------
0710   028E             ;
0711   028E             ;         0     1     2     3     4 -Bits-  4     3     2     1     0
0712   028E             ; PORT                                                                    PORT
0713   028E             ;
0714   028E             ; F7FE  [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]  |  [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 0 ]   EFFE
0715   028E             ;  ^                                   |                                   v
0716   028E             ; FBFE  [ Q ] [ W ] [ E ] [ R ] [ T ]  |  [ Y ] [ U ] [ I ] [ O ] [ P ]   DFFE
0717   028E             ;  ^                                   |                                   v
0718   028E             ; FDFE  [ A ] [ S ] [ D ] [ F ] [ G ]  |  [ H ] [ J ] [ K ] [ L ] [ ENT ] BFFE
0719   028E             ;  ^                                   |                                   v
0720   028E             ; FEFE  [SHI] [ Z ] [ X ] [ C ] [ V ]  |  [ B ] [ N ] [ M ] [sym] [ SPC ] 7FFE
0721   028E             ;  ^     $27                                                 $18           v
0722   028E             ; Start                                                                   End
0723   028E             ;        00100111                                            00011000
0724   028E             ;
0725   028E             ; ---------------------------------------------------------------------------
0726   028E             ;   The above map may help in reading.
0727   028E             ;   The neat arrangement of ports means that the B register need only be
0728   028E             ;   rotated left to work up the left hand side and then down the right
0729   028E             ;   hand side of the keyboard. When the reset bit drops into the carry
0730   028E             ;   then all 8 half-rows have been read. Shift is the first key to be
0731   028E             ;   read. The lower six bits of the shifts are unambiguous.
0732   028E             
0733   028E             ; -------------------------------
0734   028E             ; THE 'KEYBOARD SCANNING' ROUTINE
0735   028E             ; -------------------------------
0736   028E             ;   From keyboard and s-inkey$
0737   028E             ;   Returns 1 or 2 keys in DE, most significant shift first if any
0738   028E             ;   key values 0-39 else 255
0739   028E             
0740   028E             ;; KEY-SCAN
0741   028E 2E 2F       L028E:  LD      L,$2F           ; initial key value
0742   0290                                             ; valid values are obtained by subtracting
0743   0290                                             ; eight five times.
0744   0290 11 FF FF            LD      DE,$FFFF        ; a buffer to receive 2 keys.
0745   0293             
0746   0293 01 FE FE            LD      BC,$FEFE        ; the commencing port address
0747   0296                                             ; B holds 11111110 initially and is also
0748   0296                                             ; used to count the 8 half-rows
0749   0296             ;; KEY-LINE
0750   0296 ED 78       L0296:  IN      A,(C)           ; read the port to A - bits will be reset
0751   0298                                             ; if a key is pressed else set.
0752   0298 2F                  CPL                     ; complement - pressed key-bits are now set
0753   0299 E6 1F               AND     $1F             ; apply 00011111 mask to pick up the
0754   029B                                             ; relevant set bits.
0755   029B             
0756   029B 28 0E               JR      Z,L02AB         ; forward to KEY-DONE if zero and therefore
0757   029D                                             ; no keys pressed in row at all.
0758   029D             
0759   029D 67                  LD      H,A             ; transfer row bits to H
0760   029E 7D                  LD      A,L             ; load the initial key value to A
0761   029F             
0762   029F             ;; KEY-3KEYS
0763   029F 14          L029F:  INC     D               ; now test the key buffer
0764   02A0 C0                  RET     NZ              ; if we have collected 2 keys already
0765   02A1                                             ; then too many so quit.
0766   02A1             
0767   02A1             ;; KEY-BITS
0768   02A1 D6 08       L02A1:  SUB     $08             ; subtract 8 from the key value
0769   02A3                                             ; cycling through key values (top = $27)
0770   02A3                                             ; e.g. 2F>   27>1F>17>0F>07
0771   02A3                                             ;      2E>   26>1E>16>0E>06
0772   02A3 CB 3C               SRL     H               ; shift key bits right into carry.
0773   02A5 30 FA               JR      NC,L02A1        ; back to KEY-BITS if not pressed
0774   02A7                                             ; but if pressed we have a value (0-39d)
0775   02A7 53                  LD      D,E             ; transfer a possible previous key to D
0776   02A8 5F                  LD      E,A             ; transfer the new key to E
0777   02A9 20 F4               JR      NZ,L029F        ; back to KEY-3KEYS if there were more       
0778   02AB             
0779   02AB                                             ; set bits - H was not yet zero.
0780   02AB             
0781   02AB             ;; KEY-DONE
0782   02AB 2D          L02AB:  DEC     L               ; cycles 2F>2E>2D>2C>2B>2A>29>28 for
0783   02AC                                             ; each half-row.
0784   02AC CB 00               RLC     B               ; form next port address e.g. FEFE > FDFE
0785   02AE 38 E6               JR      C,L0296         ; back to KEY-LINE if still more rows to do.
0786   02B0             
0787   02B0 7A                  LD      A,D             ; now test if D is still FF ?
0788   02B1 3C                  INC     A               ; if it is zero we have at most 1 key
0789   02B2                                             ; range now $01-$28  (1-40d)
0790   02B2              ;       RET     Z              ; return if one key or no key.
0791   02B2 28 17               JR      Z,UNMRKSHFT     ; return if one key or no key.
0792   02B4              
0793   02B4 FE 28               CP      $28             ; is it capsshift (was $27) ?
0794   02B6 28 0E               JR      Z,MRKSHFT       ; return if so.
0795   02B8             
0796   02B8 FE 19               CP      $19             ; is it symbol shift (was $18) ?
0797   02BA 28 0F               JR      Z,UNMRKSHFT     ; return also
0798   02BC             
0799   02BC 7B                  LD      A,E             ; now test E
0800   02BD 5A                  LD      E,D             ; but first switch
0801   02BE 57                  LD      D,A             ; the two keys.
0802   02BF FE 18               CP      $18             ; is it symbol shift ?
0803   02C1 FD CB 01 A6         RES     4,(IY+$01)      ; return if so.
0804   02C5 C9                  RET                     ; return (with zero set if it was).
0805   02C6                                             ; but with symbol shift now in D
0806   02C6             
0807   02C6 FD CB 01 E6 MRKSHFT:   SET 4,(IY+$01)       ; Set unused flag to SET for shift  
0808   02CA C9                  RET
0809   02CB             
0810   02CB FD CB 01 A6 UNMRKSHFT:   RES 4,(IY+$01)
0811   02CF C9                  RET
0812   02D0             ; ----------------------
0813   02D0             ; THE 'KEYBOARD' ROUTINE
0814   02D0             ; ----------------------
0815   02D0             ;   Called from the interrupt 50 times a second.
0816   02D0             ;
0817   02D0             
0818   02D0             ;; KEYBOARD
0819   02D0 CD 8E 02    L02BF:  CALL    L028E           ; routine KEY-SCAN
0820   02D3 C0                  RET     NZ              ; return if invalid combinations
0821   02D4             
0822   02D4             ;   then decrease the counters within the two key-state maps
0823   02D4             ;   as this could cause one to become free.
0824   02D4             ;   if the keyboard has not been pressed during the last five interrupts
0825   02D4             ;   then both sets will be free.
0826   02D4             
0827   02D4             
0828   02D4 21 00 5C            LD      HL,$5C00        ; point to KSTATE-0
0829   02D7             
0830   02D7             ;; K-ST-LOOP
0831   02D7 CB 7E       L02C6:  BIT     7,(HL)          ; is it free ?  (i.e. $FF)
0832   02D9 20 07               JR      NZ,L02D1        ; forward to K-CH-SET if so
0833   02DB             
0834   02DB 23                  INC     HL              ; address the 5-counter
0835   02DC 35                  DEC     (HL)            ; decrease the counter
0836   02DD 2B                  DEC     HL              ; step back
0837   02DE             
0838   02DE 20 02               JR      NZ,L02D1        ; forward to K-CH-SET if not at end of count
0839   02E0             
0840   02E0 36 FF               LD      (HL),$FF        ; else mark this particular map free.
0841   02E2             
0842   02E2             ;; K-CH-SET
0843   02E2 7D          L02D1:  LD      A,L             ; make a copy of the low address byte.
0844   02E3 21 04 5C            LD      HL,$5C04        ; point to KSTATE-4
0845   02E6                                             ; (ld l,$04 would do)
0846   02E6 BD                  CP      L               ; have both sets been considered ?
0847   02E7 20 EE               JR      NZ,L02C6        ; back to K-ST-LOOP to consider this 2nd set
0848   02E9             
0849   02E9             ;   now the raw key (0-38d) is converted to a main key (uppercase).
0850   02E9             
0851   02E9 CD 42 03            CALL    L031E           ; routine K-TEST to get main key in A
0852   02EC             
0853   02EC D0                  RET     NC              ; return if just a single shift
0854   02ED                     ;JR      NC,MRKSHFT      ; return if just a single shift
0855   02ED             
0856   02ED 21 00 5C            LD      HL,$5C00        ; point to KSTATE-0
0857   02F0 BE                  CP      (HL)            ; does the main key code match ?
0858   02F1 28 41               JR      Z,L0310         ; forward to K-REPEAT if so
0859   02F3             
0860   02F3             ;   if not consider the second key map.
0861   02F3             
0862   02F3 EB                  EX      DE,HL           ; save kstate-0 in de
0863   02F4 21 04 5C            LD      HL,$5C04        ; point to KSTATE-4
0864   02F7 BE                  CP      (HL)            ; does the main key code match ?
0865   02F8 28 3A               JR      Z,L0310         ; forward to K-REPEAT if so
0866   02FA             
0867   02FA             ;   having excluded a repeating key we can now consider a new key.
0868   02FA             ;   the second set is always examined before the first.
0869   02FA             
0870   02FA CB 7E               BIT     7,(HL)          ; is the key map free ?
0871   02FC 20 04               JR      NZ,L02F1        ; forward to K-NEW if so.
0872   02FE             
0873   02FE EB                  EX      DE,HL           ; bring back KSTATE-0
0874   02FF CB 7E               BIT     7,(HL)          ; is it free ?
0875   0301 C8                  RET     Z               ; return if not.
0876   0302                                             ; as we have a key but nowhere to put it yet.
0877   0302             
0878   0302             ;   continue or jump to here if one of the buffers was free.
0879   0302             
0880   0302             ;; K-NEW
0881   0302 5F          L02F1:  LD      E,A             ; store key in E
0882   0303 77                  LD      (HL),A          ; place in free location
0883   0304 23                  INC     HL              ; advance to the interrupt counter
0884   0305 36 05               LD      (HL),$05        ; and initialize counter to 5
0885   0307 23                  INC     HL              ; advance to the delay
0886   0308 3A 09 5C            LD      A,($5C09)       ; pick up the system variable REPDEL
0887   030B 77                  LD      (HL),A          ; and insert that for first repeat delay.
0888   030C 23                  INC     HL              ; advance to last location of state map.
0889   030D             
0890   030D FD 4E 07            LD      C,(IY+$07)      ; pick up MODE  (3 bytes)
0891   0310 FD 56 01            LD      D,(IY+$01)      ; pick up FLAGS (3 bytes)
0892   0313 E5                  PUSH    HL              ; save state map location
0893   0314                                             ; Note. could now have used, to avoid IY,
0894   0314                                             ; ld l,$41; ld c,(hl); ld l,$3B; ld d,(hl).
0895   0314                                             ; six and two threes of course.
0896   0314             
0897   0314 CD 57 03            CALL    L0333           ; routine K-DECODE
0898   0317             
0899   0317 E1                  POP     HL              ; restore map pointer
0900   0318 77                  LD      (HL),A          ; put the decoded key in last location of map.
0901   0319 FE 20               CP      $20
0902   031B CC 26 03            CALL    Z,CHKBRK
0903   031E             
0904   031E             ;; K-END
0905   031E 32 08 5C    L0308:  LD      ($5C08),A       ; update LASTK system variable.
0906   0321 FD CB 01 EE         SET     5,(IY+$01)      ; update FLAGS  - signal a new key.
0907   0325 C9                  RET                     ; return to interrupt routine.
0908   0326             
0909   0326 FD CB 01 66 CHKBRK: BIT    4,(IY+$01)
0910   032A 20 01               JR     NZ,SWAPSPC
0911   032C C9                  RET
0912   032D 3E 0C       SWAPSPC:LD     A,$0C
0913   032F FD CB 01 A6         RES    4,(IY+$01)
0914   0333 C9                  RET
0915   0334             ; -----------------------
0916   0334             ; THE 'REPEAT KEY' BRANCH
0917   0334             ; -----------------------
0918   0334             ;   A possible repeat has been identified. HL addresses the raw key.
0919   0334             ;   The last location of the key map holds the decoded key from the first 
0920   0334             ;   context.  This could be a keyword and, with the exception of NOT a repeat 
0921   0334             ;   is syntactically incorrect and not really desirable.
0922   0334             
0923   0334             ;; K-REPEAT
0924   0334 23          L0310:  INC     HL              ; increment the map pointer to second location.
0925   0335 36 05               LD      (HL),$05        ; maintain interrupt counter at 5.
0926   0337 23                  INC     HL              ; now point to third location.
0927   0338 35                  DEC     (HL)            ; decrease the REPDEL value which is used to
0928   0339                                             ; time the delay of a repeat key.
0929   0339             
0930   0339 C0                  RET     NZ              ; return if not yet zero.
0931   033A             
0932   033A 3A 0A 5C            LD      A,($5C0A)       ; fetch the system variable value REPPER.
0933   033D 77                  LD      (HL),A          ; for subsequent repeats REPPER will be used.
0934   033E             
0935   033E 23                  INC     HL              ; advance
0936   033F                                             ;
0937   033F 7E                  LD      A,(HL)          ; pick up the key decoded possibly in another
0938   0340                                             ; context.
0939   0340                                             ; Note. should compare with $A5 (RND) and make
0940   0340                                             ; a simple return if this is a keyword.
0941   0340                                             ; e.g. cp $a5; ret nc; (3 extra bytes)
0942   0340 18 DC               JR      L0308           ; back to K-END
0943   0342             
0944   0342             ; ----------------------
0945   0342             ; THE 'KEY-TEST' ROUTINE
0946   0342             ; ----------------------
0947   0342             ;   also called from s-inkey$
0948   0342             ;   begin by testing for a shift with no other.
0949   0342             
0950   0342             ;; K-TEST
0951   0342 42          L031E:  LD      B,D             ; load most significant key to B
0952   0343                                             ; will be $FF if not shift.
0953   0343 16 00               LD      D,$00           ; and reset D to index into main table
0954   0345 7B                  LD      A,E             ; load least significant key from E
0955   0346 FE 27               CP      $27             ; is it higher than 39d   i.e. FF
0956   0348 D0                  RET     NC              ; return with just a shift (in B now)
0957   0349             
0958   0349 FE 18               CP      $18             ; is it symbol shift ?
0959   034B 20 03               JR      NZ,L032C        ; forward to K-MAIN if not
0960   034D             
0961   034D             ;   but we could have just symbol shift and no other
0962   034D             
0963   034D CB 78               BIT     7,B             ; is other key $FF (ie not shift)
0964   034F C0                  RET     NZ              ; return with solitary symbol shift
0965   0350             
0966   0350             
0967   0350             ;; K-MAIN
0968   0350 21 05 02    L032C:  LD      HL,L0205        ; address: MAIN-KEYS
0969   0353 19                  ADD     HL,DE           ; add offset 0-38
0970   0354 7E                  LD      A,(HL)          ; pick up main key value
0971   0355 37                  SCF                     ; set carry flag
0972   0356 C9                  RET                     ; return    (B has other key still)
0973   0357             
0974   0357             ; ----------------------------------
0975   0357             ; THE 'KEYBOARD DECODING' SUBROUTINE
0976   0357             ; ----------------------------------
0977   0357             ;   also called from s-inkey$
0978   0357             
0979   0357             ;; K-DECODE
0980   0357 7B          L0333:  LD      A,E             ; pick up the stored main key
0981   0358 FE 3A               CP      $3A             ; an arbitrary point between digits and letters
0982   035A 38 3A               JR      C,L0367         ; forward to K-DIGIT with digits, space, enter.
0983   035C             
0984   035C 0D                  DEC     C               ; decrease MODE ( 0='KLC', 1='E', 2='G')
0985   035D             
0986   035D FA 7E 03            JP      M,L034F         ; to K-KLC-LET if was zero
0987   0360             
0988   0360 28 03               JR      Z,L0341         ; to K-E-LET if was 1 for extended letters.
0989   0362             
0990   0362             ;   proceed with graphic codes.
0991   0362             ;   Note. should selectively drop return address if code > 'U' ($55).
0992   0362             ;   i.e. abort the KEYBOARD call.
0993   0362             ;   e.g. cp 'V'; jr c,addit; pop af ;pop af ;;addit etc. (6 extra bytes).
0994   0362             ;   (s-inkey$ never gets into graphics mode.)
0995   0362               
0996   0362             ;; addit
0997   0362 C6 4F               ADD     A,$4F           ; add offset to augment 'A' to graphics A say.
0998   0364 C9                  RET                     ; return.
0999   0365                                             ; Note. ( but [GRAPH] V gives RND, etc ).
1000   0365             
1001   0365             ; ---
1002   0365             
1003   0365             ;   the jump was to here with extended mode with uppercase A-Z.
1004   0365             
1005   0365             ;; K-E-LET
1006   0365 21 EB 01    L0341:  LD      HL,L022C-$41    ; base address of E-UNSHIFT L022c.
1007   0368                                             ; ( $01EB in standard ROM ).
1008   0368 04                  INC     B               ; test B is it empty i.e. not a shift.
1009   0369 28 03               JR      Z,L034A         ; forward to K-LOOK-UP if neither shift.
1010   036B             
1011   036B 21 05 02            LD      HL,L0246-$41    ; Address: $0205 L0246-$41 EXT-SHIFT base
1012   036E             
1013   036E             ;; K-LOOK-UP
1014   036E 16 00       L034A:  LD      D,$00           ; prepare to index.
1015   0370 19                  ADD     HL,DE           ; add the main key value.
1016   0371 7E                  LD      A,(HL)          ; pick up other mode value.
1017   0372 FE 0C               CP      $0C             ; Check if DELETE to swap with Shift-Space
1018   0374 28 01               JR      Z,SWAPDEL       ;    
1019   0376 C9                  RET                     ; return.
1020   0377             
1021   0377 3E 20       SWAPDEL: LD     A,$20
1022   0379 FD CB 01 A6         RES     4,(IY+$01)
1023   037D C9                  RET
1024   037E             
1025   037E             ; ---
1026   037E             
1027   037E             ;   the jump was here with mode = 0
1028   037E             
1029   037E             ;; K-KLC-LET
1030   037E 21 29 02    L034F:  LD      HL,L026A-$41    ; prepare base of sym-codes
1031   0381 CB 40               BIT     0,B             ; shift=$27 sym-shift=$18
1032   0383 28 E9               JR      Z,L034A         ; back to K-LOOK-UP with symbol-shift
1033   0385             
1034   0385 CB 5A               BIT     3,D             ; test FLAGS is it 'K' mode (from OUT-CURS)
1035   0387 28 0A               JR      Z,L0364         ; skip to K-TOKENS if so
1036   0389             
1037   0389 FD CB 30 5E         BIT     3,(IY+$30)      ; test FLAGS2 - consider CAPS LOCK ?
1038   038D C0                  RET     NZ              ; return if so with main code.
1039   038E             
1040   038E 04                  INC     B               ; is shift being pressed ?
1041   038F                                             ; result zero if not
1042   038F C0                  RET     NZ              ; return if shift pressed.
1043   0390             
1044   0390 C6 20               ADD     A,$20           ; else convert the code to lower case.
1045   0392 C9                  RET                     ; return.
1046   0393             
1047   0393             ; ---
1048   0393             
1049   0393             ;   the jump was here for tokens
1050   0393             
1051   0393             ;; K-TOKENS
1052   0393 C6 A5       L0364:  ADD     A,$A5           ; add offset to main code so that 'A'
1053   0395                                             ; becomes 'NEW' etc.
1054   0395             
1055   0395 C9                  RET                     ; return.
1056   0396             
1057   0396             ; ---
1058   0396             
1059   0396             ;   the jump was here with digits, space, enter and symbol shift (< $xx)
1060   0396             
1061   0396             ;; K-DIGIT
1062   0396 FE 30       L0367:  CP      $30             ; is it '0' or higher ?
1063   0398 D8                  RET     C               ; return with space, enter and symbol-shift
1064   0399             
1065   0399 0D                  DEC     C               ; test MODE (was 0='KLC', 1='E', 2='G')
1066   039A FA CC 03            JP      M,L039D         ; jump to K-KLC-DGT if was 0.
1067   039D             
1068   039D 20 19               JR      NZ,L0389        ; forward to K-GRA-DGT if mode was 2.
1069   039F             
1070   039F             ;   continue with extended digits 0-9.
1071   039F             
1072   039F 21 54 02            LD      HL,L0284-$30    ; $0254 - base of E-DIGITS
1073   03A2 CB 68               BIT     5,B             ; test - shift=$27 sym-shift=$18
1074   03A4 28 C8               JR      Z,L034A         ; to K-LOOK-UP if sym-shift
1075   03A6             
1076   03A6 FE 38               CP      $38             ; is character '8' ?
1077   03A8 30 07               JR      NC,L0382        ; to K-8-&-9 if greater than '7'
1078   03AA             
1079   03AA D6 20               SUB     $20             ; reduce to ink range $10-$17
1080   03AC 04                  INC     B               ; shift ?
1081   03AD C8                  RET     Z               ; return if not.
1082   03AE             
1083   03AE C6 08               ADD     A,$08           ; add 8 to give paper range $18 - $1F
1084   03B0 C9                  RET                     ; return
1085   03B1             
1086   03B1             ; ---
1087   03B1             
1088   03B1             ;   89
1089   03B1             
1090   03B1             ;; K-8-&-9
1091   03B1 D6 36       L0382:  SUB     $36             ; reduce to 02 and 03  bright codes
1092   03B3 04                  INC     B               ; test if shift pressed.
1093   03B4 C8                  RET     Z               ; return if not.
1094   03B5             
1095   03B5 C6 FE               ADD     A,$FE           ; subtract 2 setting carry
1096   03B7 C9                  RET                     ; to give 0 and 1    flash codes.
1097   03B8             
1098   03B8             ; ---
1099   03B8             
1100   03B8             ;   graphics mode with digits
1101   03B8             
1102   03B8             ;; K-GRA-DGT
1103   03B8 21 30 02    L0389:  LD      HL,L0260-$30    ; $0230 base address of CTL-CODES
1104   03BB             
1105   03BB FE 39               CP      $39             ; is key '9' ?
1106   03BD 28 AF               JR      Z,L034A         ; back to K-LOOK-UP - changed to $0F, GRAPHICS.
1107   03BF             
1108   03BF FE 30               CP      $30             ; is key '0' ?
1109   03C1 28 AB               JR      Z,L034A         ; back to K-LOOK-UP - changed to $0C, delete.
1110   03C3             
1111   03C3             ;   for keys '0' - '7' we assign a mosaic character depending on shift.
1112   03C3             
1113   03C3 E6 07               AND     $07             ; convert character to number. 0 - 7.
1114   03C5 C6 80               ADD     A,$80           ; add offset - they start at $80
1115   03C7             
1116   03C7 04                  INC     B               ; destructively test for shift
1117   03C8 C8                  RET     Z               ; and return if not pressed.
1118   03C9             
1119   03C9 EE 0F               XOR     $0F             ; toggle bits becomes range $88-$8F
1120   03CB C9                  RET                     ; return.
1121   03CC             
1122   03CC             ; ---
1123   03CC             
1124   03CC             ;   now digits in 'KLC' mode
1125   03CC             
1126   03CC             ;; K-KLC-DGT
1127   03CC 04          L039D:  INC     B               ; return with digit codes if neither
1128   03CD C8                  RET     Z               ; shift key pressed.
1129   03CE             
1130   03CE CB 68               BIT     5,B             ; test for caps shift.
1131   03D0             
1132   03D0 21 30 02            LD      HL,L0260-$30    ; prepare base of table CTL-CODES.
1133   03D3 20 99               JR      NZ,L034A        ; back to K-LOOK-UP if shift pressed.
1134   03D5             
1135   03D5             ;   must have been symbol shift
1136   03D5             
1137   03D5 D6 10               SUB     $10             ; for ASCII most will now be correct
1138   03D7                                             ; on a standard typewriter.
1139   03D7             
1140   03D7 FE 22               CP      $22             ; but '@' is not - see below.
1141   03D9 28 06               JR      Z,L03B2         ; forward to K-@-CHAR if so
1142   03DB             
1143   03DB FE 20               CP      $20             ; '_' is the other one that fails
1144   03DD C0                  RET     NZ              ; return if not.
1145   03DE             
1146   03DE 3E 5F               LD      A,$5F           ; substitute ASCII '_'
1147   03E0 C9                  RET                     ; return.
1148   03E1             
1149   03E1             ; ---
1150   03E1             
1151   03E1             ;; K-@-CHAR
1152   03E1 3E 40       L03B2:  LD      A,$40           ; substitute ASCII '@'
1153   03E3 C9                  RET                     ; return.
1154   03E4             
1155   03E4             
1156   03E4             ; ------------------------------------------------------------------------
1157   03E4             ;   The Spectrum Input character keys. One or two are abbreviated.
1158   03E4             ;   From $00 Flash 0 to $FF COPY. The routine above has decoded all these.
1159   03E4             
1160   03E4             ;  | 00 Fl0| 01 Fl1| 02 Br0| 03 Br1| 04 In0| 05 In1| 06 CAP| 07 EDT|
1161   03E4             ;  | 08 LFT| 09 RIG| 0A DWN| 0B UP | 0C DEL| 0D ENT| 0E SYM| 0F GRA|
1162   03E4             ;  | 10 Ik0| 11 Ik1| 12 Ik2| 13 Ik3| 14 Ik4| 15 Ik5| 16 Ik6| 17 Ik7|
1163   03E4             ;  | 18 Pa0| 19 Pa1| 1A Pa2| 1B Pa3| 1C Pa4| 1D Pa5| 1E Pa6| 1F Pa7|
1164   03E4             ;  | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
1165   03E4             ;  | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
1166   03E4             ;  | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
1167   03E4             ;  | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
1168   03E4             ;  | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
1169   03E4             ;  | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
1170   03E4             ;  | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
1171   03E4             ;  | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
1172   03E4             ;  | 60 ukp| 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
1173   03E4             ;  | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
1174   03E4             ;  | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
1175   03E4             ;  | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F (c)|
1176   03E4             ;  | 80 128| 81 129| 82 130| 83 131| 84 132| 85 133| 86 134| 87 135|
1177   03E4             ;  | 88 136| 89 137| 8A 138| 8B 139| 8C 140| 8D 141| 8E 142| 8F 143|
1178   03E4             ;  | 90 [A]| 91 [B]| 92 [C]| 93 [D]| 94 [E]| 95 [F]| 96 [G]| 97 [H]|
1179   03E4             ;  | 98 [I]| 99 [J]| 9A [K]| 9B [L]| 9C [M]| 9D [N]| 9E [O]| 9F [P]|
1180   03E4             ;  | A0 [Q]| A1 [R]| A2 [S]| A3 [T]| A4 [U]| A5 RND| A6 IK$| A7 PI |
1181   03E4             ;  | A8 FN | A9 PNT| AA SC$| AB ATT| AC AT | AD TAB| AE VL$| AF COD|
1182   03E4             ;  | B0 VAL| B1 LEN| B2 SIN| B3 COS| B4 TAN| B5 ASN| B6 ACS| B7 ATN|
1183   03E4             ;  | B8 LN | B9 EXP| BA INT| BB SQR| BC SGN| BD ABS| BE PEK| BF IN |
1184   03E4             ;  | C0 USR| C1 ST$| C2 CH$| C3 NOT| C4 BIN| C5 OR | C6 AND| C7 <= |
1185   03E4             ;  | C8 >= | C9 <> | CA LIN| CB THN| CC TO | CD STP| CE DEF| CF CAT|
1186   03E4             ;  | D0 FMT| D1 MOV| D2 ERS| D3 OPN| D4 CLO| D5 MRG| D6 VFY| D7 BEP|
1187   03E4             ;  | D8 CIR| D9 INK| DA PAP| DB FLA| DC BRI| DD INV| DE OVR| DF OUT|
1188   03E4             ;  | E0 LPR| E1 LLI| E2 STP| E3 REA| E4 DAT| E5 RES| E6 NEW| E7 BDR|
1189   03E4             ;  | E8 CON| E9 DIM| EA REM| EB FOR| EC GTO| ED GSB| EE INP| EF LOA|
1190   03E4             ;  | F0 LIS| F1 LET| F2 PAU| F3 NXT| F4 POK| F5 PRI| F6 PLO| F7 RUN|
1191   03E4             ;  | F8 SAV| F9 RAN| FA IF | FB CLS| FC DRW| FD CLR| FE RET| FF CPY|
1192   03E4             
1193   03E4             ;   Note that for simplicity, Sinclair have located all the control codes
1194   03E4             ;   below the space character.
1195   03E4             ;   ASCII DEL, $7F, has been made a copyright symbol.
1196   03E4             ;   Also $60, '`', not used in BASIC but used in other languages, has been
1197   03E4             ;   allocated the local currency symbol for the relevant country -
1198   03E4             ;   ukp in most Spectrums.
1199   03E4             
1200   03E4             ; ------------------------------------------------------------------------
1201   03E4             
1202   03E4             
1203   03E4             ;**********************************
1204   03E4             ;** Part 3. LOUDSPEAKER ROUTINES **
1205   03E4             ;**********************************
1206   03E4             
1207   03E4             ; Documented by Alvin Albrecht.
1208   03E4             
1209   03E4             ; ------------------------------
1210   03E4             ; Routine to control loudspeaker
1211   03E4             ; ------------------------------
1212   03E4             ; Outputs a square wave of given duration and frequency
1213   03E4             ; to the loudspeaker.
1214   03E4             ;   Enter with: DE = #cycles - 1
1215   03E4             ;               HL = tone period as described next
1216   03E4             ;
1217   03E4             ; The tone period is measured in T states and consists of
1218   03E4             ; three parts: a coarse part (H register), a medium part
1219   03E4             ; (bits 7..2 of L) and a fine part (bits 1..0 of L) which
1220   03E4             ; contribute to the waveform timing as follows:
1221   03E4             ;
1222   03E4             ;                          coarse    medium       fine
1223   03E4             ; duration of low  = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
1224   03E4             ; duration of hi   = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
1225   03E4             ; Tp = tone period = 236 + 2048*H + 32*(L>>2) + 8*(L&0x3)
1226   03E4             ;                  = 236 + 2048*H + 8*L = 236 + 8*HL
1227   03E4             ;
1228   03E4             ; As an example, to output five seconds of middle C (261.624 Hz):
1229   03E4             ;   (a) Tone period = 1/261.624 = 3.822ms
1230   03E4             ;   (b) Tone period in T-States = 3.822ms*fCPU = 13378
1231   03E4             ;         where fCPU = clock frequency of the CPU = 3.5MHz
1232   03E4             ;   (c) Find H and L for desired tone period:
1233   03E4             ;         HL = (Tp - 236) / 8 = (13378 - 236) / 8 = 1643 = 0x066B
1234   03E4             ;   (d) Tone duration in cycles = 5s/3.822ms = 1308 cycles
1235   03E4             ;         DE = 1308 - 1 = 0x051B
1236   03E4             ;
1237   03E4             ; The resulting waveform has a duty ratio of exactly 50%.
1238   03E4             ;
1239   03E4             ;
1240   03E4             ;; BEEPER
1241   03E4 F3          L03B5:  DI                      ; Disable Interrupts so they don't disturb timing
1242   03E5 7D                  LD      A,L             ;
1243   03E6 CB 3D               SRL     L               ;
1244   03E8 CB 3D               SRL     L               ; L = medium part of tone period
1245   03EA 2F                  CPL                     ;
1246   03EB E6 03               AND     $03             ; A = 3 - fine part of tone period
1247   03ED 4F                  LD      C,A             ;
1248   03EE 06 00               LD      B,$00           ;
1249   03F0 DD 21 00 04         LD      IX,L03D1        ; Address: BE-IX+3
1250   03F4 DD 09               ADD     IX,BC           ;   IX holds address of entry into the loop
1251   03F6                                             ;   the loop will contain 0-3 NOPs, implementing
1252   03F6                                             ;   the fine part of the tone period.
1253   03F6 3A 48 5C            LD      A,($5C48)       ; BORDCR
1254   03F9 E6 38               AND     $38             ; bits 5..3 contain border colour
1255   03FB 0F                  RRCA                    ; border colour bits moved to 2..0
1256   03FC 0F                  RRCA                    ;   to match border bits on port #FE
1257   03FD 0F                  RRCA                    ;
1258   03FE F6 08               OR       $08            ; bit 3 set (tape output bit on port #FE)
1259   0400                                             ;   for loud sound output
1260   0400             ;; BE-IX+3
1261   0400 00          L03D1:  NOP              ;(4)   ; optionally executed NOPs for small
1262   0401                                             ;   adjustments to tone period
1263   0401             ;; BE-IX+2
1264   0401 00          L03D2:  NOP              ;(4)   ;
1265   0402             
1266   0402             ;; BE-IX+1
1267   0402 00          L03D3:  NOP              ;(4)   ;
1268   0403             
1269   0403             ;; BE-IX+0
1270   0403 04          L03D4:  INC     B        ;(4)   ;
1271   0404 0C                  INC     C        ;(4)   ;
1272   0405             
1273   0405             ;; BE-H&L-LP
1274   0405 0D          L03D6:  DEC     C        ;(4)   ; timing loop for duration of
1275   0406 20 FD               JR      NZ,L03D6 ;(12/7);   high or low pulse of waveform
1276   0408             
1277   0408 0E 3F               LD      C,$3F    ;(7)   ;
1278   040A 05                  DEC     B        ;(4)   ;
1279   040B C2 05 04            JP      NZ,L03D6 ;(10)  ; to BE-H&L-LP
1280   040E             
1281   040E EE 10               XOR     $10      ;(7)   ; toggle output beep bit
1282   0410 D3 FE               OUT     ($FE),A  ;(11)  ; output pulse
1283   0412 44                  LD      B,H      ;(4)   ; B = coarse part of tone period
1284   0413 4F                  LD      C,A      ;(4)   ; save port #FE output byte
1285   0414 CB 67               BIT     4,A      ;(8)   ; if new output bit is high, go
1286   0416 20 09               JR      NZ,L03F2 ;(12/7);   to BE-AGAIN
1287   0418             
1288   0418 7A                  LD      A,D      ;(4)   ; one cycle of waveform has completed
1289   0419 B3                  OR      E        ;(4)   ;   (low->low). if cycle countdown = 0
1290   041A 28 09               JR      Z,L03F6  ;(12/7);   go to BE-END
1291   041C             
1292   041C 79                  LD      A,C      ;(4)   ; restore output byte for port #FE
1293   041D 4D                  LD      C,L      ;(4)   ; C = medium part of tone period
1294   041E 1B                  DEC     DE       ;(6)   ; decrement cycle count
1295   041F DD E9               JP      (IX)     ;(8)   ; do another cycle
1296   0421             
1297   0421             ;; BE-AGAIN                     ; halfway through cycle
1298   0421 4D          L03F2:  LD      C,L      ;(4)   ; C = medium part of tone period
1299   0422 0C                  INC     C        ;(4)   ; adds 16 cycles to make duration of high = duration of low
1300   0423 DD E9               JP      (IX)     ;(8)   ; do high pulse of tone
1301   0425             
1302   0425             ;; BE-END
1303   0425 FB          L03F6:  EI                      ; Enable Interrupts
1304   0426 C9                  RET                     ;
1305   0427             
1306   0427             
1307   0427             ; ------------------
1308   0427             ; THE 'BEEP' COMMAND
1309   0427             ; ------------------
1310   0427             ; BASIC interface to BEEPER subroutine.
1311   0427             ; Invoked in BASIC with:
1312   0427             ;   BEEP dur, pitch
1313   0427             ;   where dur   = duration in seconds
1314   0427             ;         pitch = # of semitones above/below middle C
1315   0427             ;
1316   0427             ; Enter with: pitch on top of calculator stack
1317   0427             ;             duration next on calculator stack
1318   0427             ;
1319   0427             ;; beep
1320   0427 EF          L03F8:  RST     28H             ;; FP-CALC
1321   0428 31                  DEFB    $31             ;;duplicate                  ; duplicate pitch
1322   0429 27                  DEFB    $27             ;;int                        ; convert to integer
1323   042A C0                  DEFB    $C0             ;;st-mem-0                   ; store integer pitch to memory 0
1324   042B 03                  DEFB    $03             ;;subtract                   ; calculate fractional part of pitch = fp_pitch - int_pitch
1325   042C 34                  DEFB    $34             ;;stk-data                   ; push constant
1326   042D EC                  DEFB    $EC             ;;Exponent: $7C, Bytes: 4    ; constant = 0.05762265
1327   042E 6C 98 1F F5         DEFB    $6C,$98,$1F,$F5 ;;($6C,$98,$1F,$F5)
1328   0432 04                  DEFB    $04             ;;multiply                   ; compute:
1329   0433 A1                  DEFB    $A1             ;;stk-one                    ; 1 + 0.05762265 * fraction_part(pitch)
1330   0434 0F                  DEFB    $0F             ;;addition
1331   0435 38                  DEFB    $38             ;;end-calc                   ; leave on calc stack
1332   0436             
1333   0436 21 92 5C            LD      HL,$5C92        ; MEM-0: number stored here is in 16 bit integer format (pitch)
1334   0439                                             ;   0, 0/FF (pos/neg), LSB, MSB, 0
1335   0439                                             ;   LSB/MSB is stored in two's complement
1336   0439                                             ; In the following, the pitch is checked if it is in the range -128<=p<=127
1337   0439 7E                  LD      A,(HL)          ; First byte must be zero, otherwise
1338   043A A7                  AND     A               ;   error in integer conversion
1339   043B 20 5E               JR      NZ,L046C        ; to REPORT-B
1340   043D             
1341   043D 23                  INC     HL              ;
1342   043E 4E                  LD      C,(HL)          ; C = pos/neg flag = 0/FF
1343   043F 23                  INC     HL              ;
1344   0440 46                  LD      B,(HL)          ; B = LSB, two's complement
1345   0441 78                  LD      A,B             ;
1346   0442 17                  RLA                     ;
1347   0443 9F                  SBC     A,A             ; A = 0/FF if B is pos/neg
1348   0444 B9                  CP      C               ; must be the same as C if the pitch is -128<=p<=127
1349   0445 20 54               JR      NZ,L046C        ; if no, error REPORT-B
1350   0447             
1351   0447 23                  INC     HL              ; if -128<=p<=127, MSB will be 0/FF if B is pos/neg
1352   0448 BE                  CP      (HL)            ; verify this
1353   0449 20 50               JR      NZ,L046C        ; if no, error REPORT-B
1354   044B                                             ; now we know -128<=p<=127
1355   044B 78                  LD      A,B             ; A = pitch + 60
1356   044C C6 3C               ADD     A,$3C           ; if -60<=pitch<=67,
1357   044E F2 54 04            JP      P,L0425         ;   goto BE-i-OK
1358   0451             
1359   0451 E2 9B 04            JP      PO,L046C        ; if pitch <= 67 goto REPORT-B
1360   0454                                             ;   lower bound of pitch set at -60
1361   0454             
1362   0454             ;; BE-I-OK                      ; here, -60<=pitch<=127
1363   0454                                             ; and A=pitch+60 -> 0<=A<=187
1364   0454             
1365   0454 06 FA       L0425:  LD      B,$FA           ; 6 octaves below middle C
1366   0456             
1367   0456             ;; BE-OCTAVE                    ; A=# semitones above 5 octaves below middle C
1368   0456 04          L0427:  INC     B               ; increment octave
1369   0457 D6 0C               SUB     $0C             ; 12 semitones = one octave
1370   0459 30 FB               JR      NC,L0427        ; to BE-OCTAVE
1371   045B             
1372   045B C6 0C               ADD     A,$0C           ; A = # semitones above C (0-11)
1373   045D C5                  PUSH    BC              ; B = octave displacement from middle C, 2's complement: -5<=B<=10
1374   045E 21 9D 04            LD      HL,L046E        ; Address: semi-tone
1375   0461 CD 35 34            CALL    L3406           ; routine LOC-MEM
1376   0464                                             ;   HL = 5*A + $046E
1377   0464 CD E3 33            CALL    L33B4           ; routine STACK-NUM
1378   0467                                             ;   read FP value (freq) from semitone table (HL) and push onto calc stack
1379   0467             
1380   0467 EF                  RST     28H             ;; FP-CALC
1381   0468 04                  DEFB    $04             ;;multiply   mult freq by 1 + 0.0576 * fraction_part(pitch) stacked earlier
1382   0469                                             ;;             thus taking into account fractional part of pitch.
1383   0469                                             ;;           the number 0.0576*frequency is the distance in Hz to the next
1384   0469                                             ;;             note (verify with the frequencies recorded in the semitone
1385   0469                                             ;;             table below) so that the fraction_part of the pitch does
1386   0469                                             ;;             indeed represent a fractional distance to the next note.
1387   0469 38                  DEFB    $38             ;;end-calc   HL points to first byte of fp num on stack = middle frequency to generate
1388   046A             
1389   046A F1                  POP     AF              ; A = octave displacement from middle C, 2's complement: -5<=A<=10
1390   046B 86                  ADD     A,(HL)          ; increase exponent by A (equivalent to multiplying by 2^A)
1391   046C 77                  LD      (HL),A          ;
1392   046D             
1393   046D EF                  RST     28H             ;; FP-CALC
1394   046E C0                  DEFB    $C0             ;;st-mem-0          ; store frequency in memory 0
1395   046F 02                  DEFB    $02             ;;delete            ; remove from calc stack
1396   0470 31                  DEFB    $31             ;;duplicate         ; duplicate duration (seconds)
1397   0471 38                  DEFB    $38             ;;end-calc
1398   0472             
1399   0472 CD C3 1E            CALL    L1E94           ; routine FIND-INT1 ; FP duration to A
1400   0475 FE 0B               CP      $0B             ; if dur > 10 seconds,
1401   0477 30 22               JR      NC,L046C        ;   goto REPORT-B
1402   0479             
1403   0479                     ;;; The following calculation finds the tone period for HL and the cycle count
1404   0479                     ;;; for DE expected in the BEEPER subroutine.  From the example in the BEEPER comments,
1405   0479                     ;;;
1406   0479                     ;;; HL = ((fCPU / f) - 236) / 8 = fCPU/8/f - 236/8 = 437500/f -29.5
1407   0479                     ;;; DE = duration * frequency - 1
1408   0479                     ;;;
1409   0479                     ;;; Note the different constant (30.125) used in the calculation of HL
1410   0479                     ;;; below.  This is probably an error.
1411   0479             
1412   0479 EF                  RST     28H             ;; FP-CALC
1413   047A E0                  DEFB    $E0             ;;get-mem-0                 ; push frequency
1414   047B 04                  DEFB    $04             ;;multiply                  ; result1: #cycles = duration * frequency
1415   047C E0                  DEFB    $E0             ;;get-mem-0                 ; push frequency
1416   047D 34                  DEFB    $34             ;;stk-data                  ; push constant
1417   047E 80                  DEFB    $80             ;;Exponent $93, Bytes: 3    ; constant = 437500
1418   047F 43 55 9F 80         DEFB    $43,$55,$9F,$80 ;;($55,$9F,$80,$00)
1419   0483 01                  DEFB    $01             ;;exchange                  ; frequency on top
1420   0484 05                  DEFB    $05             ;;division                  ; 437500 / frequency
1421   0485 34                  DEFB    $34             ;;stk-data                  ; push constant
1422   0486 35                  DEFB    $35             ;;Exponent: $85, Bytes: 1   ; constant = 30.125
1423   0487 71                  DEFB    $71             ;;($71,$00,$00,$00)
1424   0488 03                  DEFB    $03             ;;subtract                  ; result2: tone_period(HL) = 437500 / freq - 30.125
1425   0489 38                  DEFB    $38             ;;end-calc
1426   048A             
1427   048A CD C8 1E            CALL    L1E99           ; routine FIND-INT2
1428   048D C5                  PUSH    BC              ;   BC = tone_period(HL)
1429   048E CD C8 1E            CALL    L1E99           ; routine FIND-INT2, BC = #cycles to generate
1430   0491 E1                  POP     HL              ; HL = tone period
1431   0492 50                  LD      D,B             ;
1432   0493 59                  LD      E,C             ; DE = #cycles
1433   0494 7A                  LD      A,D             ;
1434   0495 B3                  OR      E               ;
1435   0496 C8                  RET     Z               ; if duration = 0, skip BEEP and avoid 65536 cycle
1436   0497                                             ;   boondoggle that would occur next
1437   0497 1B                  DEC     DE              ; DE = #cycles - 1
1438   0498 C3 E4 03            JP      L03B5           ; to BEEPER
1439   049B             
1440   049B             ; ---
1441   049B             
1442   049B             
1443   049B             ;; REPORT-B
1444   049B CF          L046C:  RST     08H             ; ERROR-1
1445   049C 0A                  DEFB    $0A             ; Error Report: Integer out of range
1446   049D             
1447   049D             
1448   049D             
1449   049D             ; ---------------------
1450   049D             ; THE 'SEMI-TONE' TABLE
1451   049D             ; ---------------------
1452   049D             ;
1453   049D             ;   Holds frequencies corresponding to semitones in middle octave.
1454   049D             ;   To move n octaves higher or lower, frequencies are multiplied by 2^n.
1455   049D             
1456   049D             ;; semi-tone         five byte fp         decimal freq     note (middle)
1457   049D 89 02 D0 12 L046E:  DEFB    $89, $02, $D0, $12, $86;  261.625565290         C
1457   04A1 86 
1458   04A2 89 0A 97 60         DEFB    $89, $0A, $97, $60, $75;  277.182631135         C#
1458   04A6 75 
1459   04A7 89 12 D5 17         DEFB    $89, $12, $D5, $17, $1F;  293.664768100         D
1459   04AB 1F 
1460   04AC 89 1B 90 41         DEFB    $89, $1B, $90, $41, $02;  311.126983881         D#
1460   04B0 02 
1461   04B1 89 24 D0 53         DEFB    $89, $24, $D0, $53, $CA;  329.627557039         E
1461   04B5 CA 
1462   04B6 89 2E 9D 36         DEFB    $89, $2E, $9D, $36, $B1;  349.228231549         F
1462   04BA B1 
1463   04BB 89 38 FF 49         DEFB    $89, $38, $FF, $49, $3E;  369.994422674         F#
1463   04BF 3E 
1464   04C0 89 43 FF 6A         DEFB    $89, $43, $FF, $6A, $73;  391.995436072         G
1464   04C4 73 
1465   04C5 89 4F A7 00         DEFB    $89, $4F, $A7, $00, $54;  415.304697513         G#
1465   04C9 54 
1466   04CA 89 5C 00 00         DEFB    $89, $5C, $00, $00, $00;  440.000000000         A
1466   04CE 00 
1467   04CF 89 69 14 F6         DEFB    $89, $69, $14, $F6, $24;  466.163761616         A#
1467   04D3 24 
1468   04D4 89 76 F1 10         DEFB    $89, $76, $F1, $10, $05;  493.883301378         B
1468   04D8 05 
1469   04D9             
1470   04D9             
1471   04D9             ;   "Music is the hidden mathematical endeavour of a soul unconscious it 
1472   04D9             ;    is calculating" - Gottfried Wilhelm Liebnitz 1646 - 1716
1473   04D9             
1474   04D9             
1475   04D9             ;****************************************
1476   04D9             ;** Part 4. CASSETTE HANDLING ROUTINES **
1477   04D9             ;****************************************
1478   04D9             
1479   04D9             ;   These routines begin with the service routines followed by a single
1480   04D9             ;   command entry point.
1481   04D9             ;   The first of these service routines is a curiosity.
1482   04D9             
1483   04D9             ; -----------------------
1484   04D9             ; THE 'ZX81 NAME' ROUTINE
1485   04D9             ; -----------------------
1486   04D9             ;   This routine fetches a filename in ZX81 format and is not used by the 
1487   04D9             ;   cassette handling routines in this ROM.
1488   04D9             
1489   04D9             ;; zx81-name
1490   04D9 CD 2A 25    L04AA:  CALL    L24FB           ; routine SCANNING to evaluate expression.
1491   04DC 3A 3B 5C            LD      A,($5C3B)       ; fetch system variable FLAGS.
1492   04DF 87                  ADD     A,A             ; test bit 7 - syntax, bit 6 - result type.
1493   04E0 FA B9 1C            JP      M,L1C8A         ; to REPORT-C if not string result
1494   04E3                                             ; 'Nonsense in BASIC'.
1495   04E3             
1496   04E3 E1                  POP     HL              ; drop return address.
1497   04E4 D0                  RET     NC              ; return early if checking syntax.
1498   04E5             
1499   04E5 E5                  PUSH    HL              ; re-save return address.
1500   04E6 CD 20 2C            CALL    L2BF1           ; routine STK-FETCH fetches string parameters.
1501   04E9 62                  LD      H,D             ; transfer start of filename
1502   04EA 6B                  LD      L,E             ; to the HL register.
1503   04EB 0D                  DEC     C               ; adjust to point to last character and
1504   04EC F8                  RET     M               ; return if the null string.
1505   04ED                                             ; or multiple of 256!
1506   04ED             
1507   04ED 09                  ADD     HL,BC           ; find last character of the filename.
1508   04EE                                             ; and also clear carry.
1509   04EE CB FE               SET     7,(HL)          ; invert it.
1510   04F0 C9                  RET                     ; return.
1511   04F1             
1512   04F1             ; =========================================
1513   04F1             ;
1514   04F1             ; PORT 254 ($FE)
1515   04F1             ;
1516   04F1             ;                      spk mic { border  }  
1517   04F1             ;          ___ ___ ___ ___ ___ ___ ___ ___ 
1518   04F1             ; PORT    |   |   |   |   |   |   |   |   |
1519   04F1             ; 254     |   |   |   |   |   |   |   |   |
1520   04F1             ; $FE     |___|___|___|___|___|___|___|___|
1521   04F1             ;           7   6   5   4   3   2   1   0
1522   04F1             ;
1523   04F1             
1524   04F1             ; ----------------------------------
1525   04F1             ; Save header and program/data bytes
1526   04F1             ; ----------------------------------
1527   04F1             ;   This routine saves a section of data. It is called from SA-CTRL to save the
1528   04F1             ;   seventeen bytes of header data. It is also the exit route from that routine
1529   04F1             ;   when it is set up to save the actual data.
1530   04F1             ;   On entry -
1531   04F1             ;   HL points to start of data.
1532   04F1             ;   IX points to descriptor.
1533   04F1             ;   The accumulator is set to  $00 for a header, $FF for data.
1534   04F1             
1535   04F1             ;; SA-BYTES
1536   04F1 21 6E 05    L04C2:  LD      HL,L053F        ; address: SA/LD-RET
1537   04F4 E5                  PUSH    HL              ; is pushed as common exit route.
1538   04F5                                             ; however there is only one non-terminal exit 
1539   04F5                                             ; point.
1540   04F5             
1541   04F5 21 80 1F            LD      HL,$1F80        ; a timing constant H=$1F, L=$80
1542   04F8                                             ; inner and outer loop counters
1543   04F8                                             ; a five second lead-in is used for a header.
1544   04F8             
1545   04F8 CB 7F               BIT     7,A             ; test one bit of accumulator.
1546   04FA                                             ; (AND A ?)
1547   04FA 28 03               JR      Z,L04D0         ; skip to SA-FLAG if a header is being saved.
1548   04FC             
1549   04FC             ;   else is data bytes and a shorter lead-in is used.
1550   04FC             
1551   04FC 21 98 0C            LD      HL,$0C98        ; another timing value H=$0C, L=$98.
1552   04FF                                             ; a two second lead-in is used for the data.
1553   04FF             
1554   04FF             
1555   04FF             ;; SA-FLAG
1556   04FF 08          L04D0:  EX      AF,AF'          ; save flag
1557   0500 13                  INC     DE              ; increase length by one.
1558   0501 DD 2B               DEC     IX              ; decrease start.
1559   0503             
1560   0503 F3                  DI                      ; disable interrupts
1561   0504             
1562   0504 3E 02               LD      A,$02           ; select red for border, microphone bit on.
1563   0506 47                  LD      B,A             ; also does as an initial slight counter value.
1564   0507             
1565   0507             ;; SA-LEADER
1566   0507 10 FE       L04D8:  DJNZ    L04D8           ; self loop to SA-LEADER for delay.
1567   0509                                             ; after initial loop, count is $A4 (or $A3)
1568   0509             
1569   0509 D3 FE               OUT     ($FE),A         ; output byte $02/$0D to tape port.
1570   050B             
1571   050B EE 0F               XOR     $0F             ; switch from RED (mic on) to CYAN (mic off).
1572   050D             
1573   050D 06 A4               LD      B,$A4           ; hold count. also timed instruction.
1574   050F             
1575   050F 2D                  DEC     L               ; originally $80 or $98.
1576   0510                                             ; but subsequently cycles 256 times.
1577   0510 20 F5               JR      NZ,L04D8        ; back to SA-LEADER until L is zero.
1578   0512             
1579   0512             ;   the outer loop is counted by H
1580   0512             
1581   0512 05                  DEC     B               ; decrement count
1582   0513 25                  DEC     H               ; originally  twelve or thirty-one.
1583   0514 F2 07 05            JP      P,L04D8         ; back to SA-LEADER until H becomes $FF
1584   0517             
1585   0517             ;   now send a sync pulse. At this stage mic is off and A holds value
1586   0517             ;   for mic on.
1587   0517             ;   A sync pulse is much shorter than the steady pulses of the lead-in.
1588   0517             
1589   0517 06 2F               LD      B,$2F           ; another short timed delay.
1590   0519             
1591   0519             ;; SA-SYNC-1
1592   0519 10 FE       L04EA:  DJNZ    L04EA           ; self loop to SA-SYNC-1
1593   051B             
1594   051B D3 FE               OUT     ($FE),A         ; switch to mic on and red.
1595   051D 3E 0D               LD      A,$0D           ; prepare mic off - cyan
1596   051F 06 37               LD      B,$37           ; another short timed delay.
1597   0521             
1598   0521             ;; SA-SYNC-2
1599   0521 10 FE       L04F2:  DJNZ    L04F2           ; self loop to SA-SYNC-2
1600   0523             
1601   0523 D3 FE               OUT     ($FE),A         ; output mic off, cyan border.
1602   0525 01 0E 3B            LD      BC,$3B0E        ; B=$3B time(*), C=$0E, YELLOW, MIC OFF.
1603   0528             
1604   0528             ; 
1605   0528             
1606   0528 08                  EX      AF,AF'          ; restore saved flag
1607   0529                                             ; which is 1st byte to be saved.
1608   0529             
1609   0529 6F                  LD      L,A             ; and transfer to L.
1610   052A                                             ; the initial parity is A, $FF or $00.
1611   052A C3 36 05            JP      L0507           ; JUMP forward to SA-START     ->
1612   052D                                             ; the mid entry point of loop.
1613   052D             
1614   052D             ; -------------------------
1615   052D             ;   During the save loop a parity byte is maintained in H.
1616   052D             ;   the save loop begins by testing if reduced length is zero and if so
1617   052D             ;   the final parity byte is saved reducing count to $FFFF.
1618   052D             
1619   052D             ;; SA-LOOP
1620   052D 7A          L04FE:  LD      A,D             ; fetch high byte
1621   052E B3                  OR      E               ; test against low byte.
1622   052F 28 0C               JR      Z,L050E         ; forward to SA-PARITY if zero.
1623   0531             
1624   0531 DD 6E 00            LD      L,(IX+$00)      ; load currently addressed byte to L.
1625   0534             
1626   0534             ;; SA-LOOP-P
1627   0534 7C          L0505:  LD      A,H             ; fetch parity byte.
1628   0535 AD                  XOR     L               ; exclusive or with new byte.
1629   0536             
1630   0536             ; -> the mid entry point of loop.
1631   0536             
1632   0536             ;; SA-START
1633   0536 67          L0507:  LD      H,A             ; put parity byte in H.
1634   0537 3E 01               LD      A,$01           ; prepare blue, mic=on.
1635   0539 37                  SCF                     ; set carry flag ready to rotate in.
1636   053A C3 54 05            JP      L0525           ; JUMP forward to SA-8-BITS            -8->
1637   053D             
1638   053D             ; ---
1639   053D             
1640   053D             ;; SA-PARITY
1641   053D 6C          L050E:  LD      L,H             ; transfer the running parity byte to L and
1642   053E 18 F4               JR      L0505           ; back to SA-LOOP-P 
1643   0540                                             ; to output that byte before quitting normally.
1644   0540             
1645   0540             ; ---
1646   0540             
1647   0540             ;   The entry point to save yellow part of bit.
1648   0540             ;   A bit consists of a period with mic on and blue border followed by 
1649   0540             ;   a period of mic off with yellow border. 
1650   0540             ;   Note. since the DJNZ instruction does not affect flags, the zero flag is 
1651   0540             ;   used to indicate which of the two passes is in effect and the carry 
1652   0540             ;   maintains the state of the bit to be saved.
1653   0540             
1654   0540             ;; SA-BIT-2
1655   0540 79          L0511:  LD      A,C             ; fetch 'mic on and yellow' which is 
1656   0541                                             ; held permanently in C.
1657   0541 CB 78               BIT     7,B             ; set the zero flag. B holds $3E.
1658   0543             
1659   0543             ;   The entry point to save 1 entire bit. For first bit B holds $3B(*).
1660   0543             ;   Carry is set if saved bit is 1. zero is reset NZ on entry.
1661   0543             
1662   0543             ;; SA-BIT-1
1663   0543 10 FE       L0514:  DJNZ    L0514           ; self loop for delay to SA-BIT-1
1664   0545             
1665   0545 30 04               JR      NC,L051C        ; forward to SA-OUT if bit is 0.
1666   0547             
1667   0547             ;   but if bit is 1 then the mic state is held for longer.
1668   0547             
1669   0547 06 42               LD      B,$42           ; set timed delay. (66 decimal)
1670   0549             
1671   0549             ;; SA-SET
1672   0549 10 FE       L051A:  DJNZ    L051A           ; self loop to SA-SET 
1673   054B                                             ; (roughly an extra 66*13 clock cycles)
1674   054B             
1675   054B             ;; SA-OUT
1676   054B D3 FE       L051C:  OUT     ($FE),A         ; blue and mic on OR  yellow and mic off.
1677   054D             
1678   054D 06 3E               LD      B,$3E           ; set up delay
1679   054F 20 EF               JR      NZ,L0511        ; back to SA-BIT-2 if zero reset NZ (first pass)
1680   0551             
1681   0551             ;   proceed when the blue and yellow bands have been output.
1682   0551             
1683   0551 05                  DEC     B               ; change value $3E to $3D.
1684   0552 AF                  XOR     A               ; clear carry flag (ready to rotate in).
1685   0553 3C                  INC     A               ; reset zero flag i.e. NZ.
1686   0554             
1687   0554             ; -8-> 
1688   0554             
1689   0554             ;; SA-8-BITS
1690   0554 CB 15       L0525:  RL      L               ; rotate left through carry
1691   0556                                             ; C<76543210<C  
1692   0556 C2 43 05            JP      NZ,L0514        ; JUMP back to SA-BIT-1 
1693   0559                                             ; until all 8 bits done.
1694   0559             
1695   0559             ;   when the initial set carry is passed out again then a byte is complete.
1696   0559             
1697   0559 1B                  DEC     DE              ; decrease length
1698   055A DD 23               INC     IX              ; increase byte pointer
1699   055C 06 31               LD      B,$31           ; set up timing.
1700   055E             
1701   055E 3E 7F               LD      A,$7F           ; test the space key and
1702   0560 DB FE               IN      A,($FE)         ; return to common exit (to restore border)
1703   0562 1F                  RRA                     ; if a space is pressed
1704   0563 D0                  RET     NC              ; return to SA/LD-RET.   - - >
1705   0564             
1706   0564             ;   now test if byte counter has reached $FFFF.
1707   0564             
1708   0564 7A                  LD      A,D             ; fetch high byte
1709   0565 3C                  INC     A               ; increment.
1710   0566 C2 2D 05            JP      NZ,L04FE        ; JUMP to SA-LOOP if more bytes.
1711   0569             
1712   0569 06 3B               LD      B,$3B           ; a final delay. 
1713   056B             
1714   056B             ;; SA-DELAY
1715   056B 10 FE       L053C:  DJNZ    L053C           ; self loop to SA-DELAY
1716   056D             
1717   056D C9                  RET                     ; return - - >
1718   056E             
1719   056E             ; ------------------------------
1720   056E             ; THE 'SAVE/LOAD RETURN' ROUTINE
1721   056E             ; ------------------------------
1722   056E             ;   The address of this routine is pushed on the stack prior to any load/save
1723   056E             ;   operation and it handles normal completion with the restoration of the
1724   056E             ;   border and also abnormal termination when the break key, or to be more
1725   056E             ;   precise the space key is pressed during a tape operation.
1726   056E             ;
1727   056E             ; - - >
1728   056E             
1729   056E             ;; SA/LD-RET
1730   056E F5          L053F:  PUSH    AF              ; preserve accumulator throughout.
1731   056F 3A 48 5C            LD      A,($5C48)       ; fetch border colour from BORDCR.
1732   0572 E6 38               AND     $38             ; mask off paper bits.
1733   0574 0F                  RRCA                    ; rotate
1734   0575 0F                  RRCA                    ; to the
1735   0576 0F                  RRCA                    ; range 0-7.
1736   0577             
1737   0577 D3 FE               OUT     ($FE),A         ; change the border colour.
1738   0579             
1739   0579 3E 7F               LD      A,$7F           ; read from port address $7FFE the
1740   057B DB FE               IN      A,($FE)         ; row with the space key at outside.
1741   057D              
1742   057D 1F                  RRA                     ; test for space key pressed.
1743   057E FB                  EI                      ; enable interrupts
1744   057F 38 02               JR      C,L0554         ; forward to SA/LD-END if not
1745   0581             
1746   0581             
1747   0581             ;; REPORT-Da
1748   0581 CF          L0552:  RST     08H             ; ERROR-1
1749   0582 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
1750   0583             
1751   0583             ; ---
1752   0583             
1753   0583             ;; SA/LD-END
1754   0583 F1          L0554:  POP     AF              ; restore the accumulator.
1755   0584 C9                  RET                     ; return.
1756   0585             
1757   0585             ; ------------------------------------
1758   0585             ; Load header or block of information
1759   0585             ; ------------------------------------
1760   0585             ;   This routine is used to load bytes and on entry A is set to $00 for a 
1761   0585             ;   header or to $FF for data.  IX points to the start of receiving location 
1762   0585             ;   and DE holds the length of bytes to be loaded. If, on entry the carry flag 
1763   0585             ;   is set then data is loaded, if reset then it is verified.
1764   0585             
1765   0585             ;; LD-BYTES
1766   0585 14          L0556:  INC     D               ; reset the zero flag without disturbing carry.
1767   0586 08                  EX      AF,AF'          ; preserve entry flags.
1768   0587 15                  DEC     D               ; restore high byte of length.
1769   0588             
1770   0588 F3                  DI                      ; disable interrupts
1771   0589             
1772   0589 3E 0F               LD      A,$0F           ; make the border white and mic off.
1773   058B D3 FE               OUT     ($FE),A         ; output to port.
1774   058D             
1775   058D 21 6E 05            LD      HL,L053F        ; Address: SA/LD-RET
1776   0590 E5                  PUSH    HL              ; is saved on stack as terminating routine.
1777   0591             
1778   0591             ;   the reading of the EAR bit (D6) will always be preceded by a test of the 
1779   0591             ;   space key (D0), so store the initial post-test state.
1780   0591             
1781   0591 DB FE               IN      A,($FE)         ; read the ear state - bit 6.
1782   0593 1F                  RRA                     ; rotate to bit 5.
1783   0594 E6 20               AND     $20             ; isolate this bit.
1784   0596 F6 02               OR      $02             ; combine with red border colour.
1785   0598 4F                  LD      C,A             ; and store initial state long-term in C.
1786   0599 BF                  CP      A               ; set the zero flag.
1787   059A             
1788   059A             ; 
1789   059A             
1790   059A             ;; LD-BREAK
1791   059A C0          L056B:  RET     NZ              ; return if at any time space is pressed.
1792   059B             
1793   059B             ;; LD-START
1794   059B CD 16 06    L056C:  CALL    L05E7           ; routine LD-EDGE-1
1795   059E 30 FA               JR      NC,L056B        ; back to LD-BREAK with time out and no
1796   05A0                                             ; edge present on tape.
1797   05A0             
1798   05A0             ;   but continue when a transition is found on tape.
1799   05A0             
1800   05A0 21 15 04            LD      HL,$0415        ; set up 16-bit outer loop counter for 
1801   05A3                                             ; approx 1 second delay.
1802   05A3             
1803   05A3             ;; LD-WAIT
1804   05A3 10 FE       L0574:  DJNZ    L0574           ; self loop to LD-WAIT (for 256 times)
1805   05A5             
1806   05A5 2B                  DEC     HL              ; decrease outer loop counter.
1807   05A6 7C                  LD      A,H             ; test for
1808   05A7 B5                  OR      L               ; zero.
1809   05A8 20 F9               JR      NZ,L0574        ; back to LD-WAIT, if not zero, with zero in B.
1810   05AA             
1811   05AA             ;   continue after delay with H holding zero and B also.
1812   05AA             ;   sample 256 edges to check that we are in the middle of a lead-in section. 
1813   05AA             
1814   05AA CD 12 06            CALL    L05E3           ; routine LD-EDGE-2
1815   05AD 30 EB               JR      NC,L056B        ; back to LD-BREAK
1816   05AF                                             ; if no edges at all.
1817   05AF             
1818   05AF             ;; LD-LEADER
1819   05AF 06 9C       L0580:  LD      B,$9C           ; set timing value.
1820   05B1 CD 12 06            CALL    L05E3           ; routine LD-EDGE-2
1821   05B4 30 E4               JR      NC,L056B        ; back to LD-BREAK if time-out
1822   05B6             
1823   05B6 3E C6               LD      A,$C6           ; two edges must be spaced apart.
1824   05B8 B8                  CP      B               ; compare
1825   05B9 30 E0               JR      NC,L056C        ; back to LD-START if too close together for a 
1826   05BB                                             ; lead-in.
1827   05BB             
1828   05BB 24                  INC     H               ; proceed to test 256 edged sample.
1829   05BC 20 F1               JR      NZ,L0580        ; back to LD-LEADER while more to do.
1830   05BE             
1831   05BE             ;   sample indicates we are in the middle of a two or five second lead-in.
1832   05BE             ;   Now test every edge looking for the terminal sync signal.
1833   05BE             
1834   05BE             ;; LD-SYNC
1835   05BE 06 C9       L058F:  LD      B,$C9           ; initial timing value in B.
1836   05C0 CD 16 06            CALL    L05E7           ; routine LD-EDGE-1
1837   05C3 30 D5               JR      NC,L056B        ; back to LD-BREAK with time-out.
1838   05C5             
1839   05C5 78                  LD      A,B             ; fetch augmented timing value from B.
1840   05C6 FE D4               CP      $D4             ; compare 
1841   05C8 30 F4               JR      NC,L058F        ; back to LD-SYNC if gap too big, that is,
1842   05CA                                             ; a normal lead-in edge gap.
1843   05CA             
1844   05CA             ;   but a short gap will be the sync pulse.
1845   05CA             ;   in which case another edge should appear before B rises to $FF
1846   05CA             
1847   05CA CD 16 06            CALL    L05E7           ; routine LD-EDGE-1
1848   05CD D0                  RET     NC              ; return with time-out.
1849   05CE             
1850   05CE             ; proceed when the sync at the end of the lead-in is found.
1851   05CE             ; We are about to load data so change the border colours.
1852   05CE             
1853   05CE 79                  LD      A,C             ; fetch long-term mask from C
1854   05CF EE 03               XOR     $03             ; and make blue/yellow.
1855   05D1             
1856   05D1 4F                  LD      C,A             ; store the new long-term byte.
1857   05D2             
1858   05D2 26 00               LD      H,$00           ; set up parity byte as zero.
1859   05D4 06 B0               LD      B,$B0           ; timing.
1860   05D6 18 1F               JR      L05C8           ; forward to LD-MARKER 
1861   05D8                                             ; the loop mid entry point with the alternate 
1862   05D8                                             ; zero flag reset to indicate first byte 
1863   05D8                                             ; is discarded.
1864   05D8             
1865   05D8             ; --------------
1866   05D8             ;   the loading loop loads each byte and is entered at the mid point.
1867   05D8             
1868   05D8             ;; LD-LOOP
1869   05D8 08          L05A9:  EX      AF,AF'          ; restore entry flags and type in A.
1870   05D9 20 07               JR      NZ,L05B3        ; forward to LD-FLAG if awaiting initial flag
1871   05DB                                             ; which is to be discarded.
1872   05DB             
1873   05DB 30 0F               JR      NC,L05BD        ; forward to LD-VERIFY if not to be loaded.
1874   05DD             
1875   05DD DD 75 00            LD      (IX+$00),L      ; place loaded byte at memory location.
1876   05E0 18 0F               JR      L05C2           ; forward to LD-NEXT
1877   05E2             
1878   05E2             ; ---
1879   05E2             
1880   05E2             ;; LD-FLAG
1881   05E2 CB 11       L05B3:  RL      C               ; preserve carry (verify) flag in long-term
1882   05E4                                             ; state byte. Bit 7 can be lost.
1883   05E4             
1884   05E4 AD                  XOR     L               ; compare type in A with first byte in L.
1885   05E5 C0                  RET     NZ              ; return if no match e.g. CODE vs. DATA.
1886   05E6             
1887   05E6             ;   continue when data type matches.
1888   05E6             
1889   05E6 79                  LD      A,C             ; fetch byte with stored carry
1890   05E7 1F                  RRA                     ; rotate it to carry flag again
1891   05E8 4F                  LD      C,A             ; restore long-term port state.
1892   05E9             
1893   05E9 13                  INC     DE              ; increment length ??
1894   05EA 18 07               JR      L05C4           ; forward to LD-DEC.
1895   05EC                                             ; but why not to location after ?
1896   05EC             
1897   05EC             ; ---
1898   05EC             ;   for verification the byte read from tape is compared with that in memory.
1899   05EC             
1900   05EC             ;; LD-VERIFY
1901   05EC DD 7E 00    L05BD:  LD      A,(IX+$00)      ; fetch byte from memory.
1902   05EF AD                  XOR     L               ; compare with that on tape
1903   05F0 C0                  RET     NZ              ; return if not zero. 
1904   05F1             
1905   05F1             ;; LD-NEXT
1906   05F1 DD 23       L05C2:  INC     IX              ; increment byte pointer.
1907   05F3             
1908   05F3             ;; LD-DEC
1909   05F3 1B          L05C4:  DEC     DE              ; decrement length.
1910   05F4 08                  EX      AF,AF'          ; store the flags.
1911   05F5 06 B2               LD      B,$B2           ; timing.
1912   05F7             
1913   05F7             ;   when starting to read 8 bits the receiving byte is marked with bit at right.
1914   05F7             ;   when this is rotated out again then 8 bits have been read.
1915   05F7             
1916   05F7             ;; LD-MARKER
1917   05F7 2E 01       L05C8:  LD      L,$01           ; initialize as %00000001
1918   05F9             
1919   05F9             ;; LD-8-BITS
1920   05F9 CD 12 06    L05CA:  CALL    L05E3           ; routine LD-EDGE-2 increments B relative to
1921   05FC                                             ; gap between 2 edges.
1922   05FC D0                  RET     NC              ; return with time-out.
1923   05FD             
1924   05FD 3E CB               LD      A,$CB           ; the comparison byte.
1925   05FF B8                  CP      B               ; compare to incremented value of B.
1926   0600                                             ; if B is higher then bit on tape was set.
1927   0600                                             ; if <= then bit on tape is reset. 
1928   0600             
1929   0600 CB 15               RL      L               ; rotate the carry bit into L.
1930   0602             
1931   0602 06 B0               LD      B,$B0           ; reset the B timer byte.
1932   0604 D2 F9 05            JP      NC,L05CA        ; JUMP back to LD-8-BITS
1933   0607             
1934   0607             ;   when carry set then marker bit has been passed out and byte is complete.
1935   0607             
1936   0607 7C                  LD      A,H             ; fetch the running parity byte.
1937   0608 AD                  XOR     L               ; include the new byte.
1938   0609 67                  LD      H,A             ; and store back in parity register.
1939   060A             
1940   060A 7A                  LD      A,D             ; check length of
1941   060B B3                  OR      E               ; expected bytes.
1942   060C 20 CA               JR      NZ,L05A9        ; back to LD-LOOP 
1943   060E                                             ; while there are more.
1944   060E             
1945   060E             ;   when all bytes loaded then parity byte should be zero.
1946   060E             
1947   060E 7C                  LD      A,H             ; fetch parity byte.
1948   060F FE 01               CP      $01             ; set carry if zero.
1949   0611 C9                  RET                     ; return
1950   0612                                             ; in no carry then error as checksum disagrees.
1951   0612             
1952   0612             ; -------------------------
1953   0612             ; Check signal being loaded
1954   0612             ; -------------------------
1955   0612             ;   An edge is a transition from one mic state to another.
1956   0612             ;   More specifically a change in bit 6 of value input from port $FE.
1957   0612             ;   Graphically it is a change of border colour, say, blue to yellow.
1958   0612             ;   The first entry point looks for two adjacent edges. The second entry point
1959   0612             ;   is used to find a single edge.
1960   0612             ;   The B register holds a count, up to 256, within which the edge (or edges) 
1961   0612             ;   must be found. The gap between two edges will be more for a '1' than a '0'
1962   0612             ;   so the value of B denotes the state of the bit (two edges) read from tape.
1963   0612             
1964   0612             ; ->
1965   0612             
1966   0612             ;; LD-EDGE-2
1967   0612 CD 16 06    L05E3:  CALL    L05E7           ; call routine LD-EDGE-1 below.
1968   0615 D0                  RET     NC              ; return if space pressed or time-out.
1969   0616                                             ; else continue and look for another adjacent 
1970   0616                                             ; edge which together represent a bit on the 
1971   0616                                             ; tape.
1972   0616             
1973   0616             ; -> 
1974   0616             ;   this entry point is used to find a single edge from above but also 
1975   0616             ;   when detecting a read-in signal on the tape.
1976   0616             
1977   0616             ;; LD-EDGE-1
1978   0616 3E 16       L05E7:  LD      A,$16           ; a delay value of twenty two.
1979   0618             
1980   0618             ;; LD-DELAY
1981   0618 3D          L05E9:  DEC     A               ; decrement counter
1982   0619 20 FD               JR      NZ,L05E9        ; loop back to LD-DELAY 22 times.
1983   061B             
1984   061B A7                  AND      A              ; clear carry.
1985   061C             
1986   061C             ;; LD-SAMPLE
1987   061C 04          L05ED:  INC     B               ; increment the time-out counter.
1988   061D C8                  RET     Z               ; return with failure when $FF passed.
1989   061E             
1990   061E 3E 7F               LD      A,$7F           ; prepare to read keyboard and EAR port
1991   0620 DB FE               IN      A,($FE)         ; row $7FFE. bit 6 is EAR, bit 0 is SPACE key.
1992   0622 1F                  RRA                     ; test outer key the space. (bit 6 moves to 5)
1993   0623 D0                  RET     NC              ; return if space pressed.  >>>
1994   0624             
1995   0624 A9                  XOR     C               ; compare with initial long-term state.
1996   0625 E6 20               AND     $20             ; isolate bit 5
1997   0627 28 F3               JR      Z,L05ED         ; back to LD-SAMPLE if no edge.
1998   0629             
1999   0629             ;   but an edge, a transition of the EAR bit, has been found so switch the
2000   0629             ;   long-term comparison byte containing both border colour and EAR bit. 
2001   0629             
2002   0629 79                  LD      A,C             ; fetch comparison value.
2003   062A 2F                  CPL                     ; switch the bits
2004   062B 4F                  LD      C,A             ; and put back in C for long-term.
2005   062C             
2006   062C E6 07               AND     $07             ; isolate new colour bits.
2007   062E F6 08               OR      $08             ; set bit 3 - MIC off.
2008   0630 D3 FE               OUT     ($FE),A         ; send to port to effect the change of colour. 
2009   0632             
2010   0632 37                  SCF                     ; set carry flag signaling edge found within
2011   0633                                             ; time allowed.
2012   0633 C9                  RET                     ; return.
2013   0634             
2014   0634             ; ---------------------------------
2015   0634             ; Entry point for all tape commands
2016   0634             ; ---------------------------------
2017   0634             ;   This is the single entry point for the four tape commands.
2018   0634             ;   The routine first determines in what context it has been called by examining
2019   0634             ;   the low byte of the Syntax table entry which was stored in T_ADDR.
2020   0634             ;   Subtracting $EO (the present arrangement) gives a value of
2021   0634             ;   $00 - SAVE
2022   0634             ;   $01 - LOAD
2023   0634             ;   $02 - VERIFY
2024   0634             ;   $03 - MERGE
2025   0634             ;   As with all commands the address STMT-RET is on the stack.
2026   0634             
2027   0634             ;; SAVE-ETC
2028   0634 F1          L0605:  POP     AF              ; discard address STMT-RET.
2029   0635 3A 74 5C            LD      A,($5C74)       ; fetch T_ADDR
2030   0638             
2031   0638             ;   Now reduce the low byte of the Syntax table entry to give command.
2032   0638             ;   Note. For ZASM use SUB $E0 as next instruction.
2033   0638             
2034   0638 D6 0F       L0609:  SUB     L1ADF + 1 % 256 ; subtract the known offset.
2035   063A                                             ; ( is SUB $E0 in standard ROM )
2036   063A             
2037   063A 32 74 5C            LD      ($5C74),A       ; and put back in T_ADDR as 0,1,2, or 3
2038   063D                                             ; for future reference.
2039   063D             
2040   063D CD BB 1C            CALL    L1C8C           ; routine EXPT-EXP checks that a string
2041   0640                                             ; expression follows and stacks the
2042   0640                                             ; parameters in run-time.
2043   0640             
2044   0640 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
2045   0643 28 3C               JR      Z,L0652         ; forward to SA-DATA if checking syntax.
2046   0645             
2047   0645 01 11 00            LD      BC,$0011        ; presume seventeen bytes for a header.
2048   0648 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
2049   064B A7                  AND     A               ; test for zero - SAVE.
2050   064C 28 02               JR      Z,L0621         ; forward to SA-SPACE if so.
2051   064E             
2052   064E 0E 22               LD      C,$22           ; else double length to thirty four.
2053   0650             
2054   0650             ;; SA-SPACE
2055   0650 F7          L0621:  RST     30H             ; BC-SPACES creates 17/34 bytes in workspace.
2056   0651             
2057   0651 D5                  PUSH    DE              ; transfer the start of new space to
2058   0652 DD E1               POP     IX              ; the available index register.
2059   0654             
2060   0654             ;   ten spaces are required for the default filename but it is simpler to
2061   0654             ;   overwrite the first file-type indicator byte as well.
2062   0654             
2063   0654 06 0B               LD      B,$0B           ; set counter to eleven.
2064   0656 3E 20               LD      A,$20           ; prepare a space.
2065   0658             
2066   0658             ;; SA-BLANK
2067   0658 12          L0629:  LD      (DE),A          ; set workspace location to space.
2068   0659 13                  INC     DE              ; next location.
2069   065A 10 FC               DJNZ    L0629           ; loop back to SA-BLANK till all eleven done.
2070   065C             
2071   065C DD 36 01 FF         LD      (IX+$01),$FF    ; set first byte of ten character filename
2072   0660                                             ; to $FF as a default to signal null string.
2073   0660             
2074   0660 CD 20 2C            CALL    L2BF1           ; routine STK-FETCH fetches the filename
2075   0663                                             ; parameters from the calculator stack.
2076   0663                                             ; length of string in BC.
2077   0663                                             ; start of string in DE.
2078   0663             
2079   0663 21 F6 FF            LD      HL,$FFF6        ; prepare the value minus ten.
2080   0666 0B                  DEC     BC              ; decrement length.
2081   0667                                             ; ten becomes nine, zero becomes $FFFF.
2082   0667 09                  ADD     HL,BC           ; trial addition.
2083   0668 03                  INC     BC              ; restore true length.
2084   0669 30 0F               JR      NC,L064B        ; forward to SA-NAME if length is one to ten.
2085   066B             
2086   066B             ;   the filename is more than ten characters in length or the null string.
2087   066B             
2088   066B 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
2089   066E A7                  AND     A               ; test for zero - SAVE.
2090   066F 20 02               JR      NZ,L0644        ; forward to SA-NULL if not the SAVE command.
2091   0671             
2092   0671             ;   but no more than ten characters are allowed for SAVE.
2093   0671             ;   The first ten characters of any other command parameter are acceptable.
2094   0671             ;   Weird, but necessary, if saving to sectors.
2095   0671             ;   Note. the golden rule that there are no restriction on anything is broken.
2096   0671             
2097   0671             ;; REPORT-Fa
2098   0671 CF          L0642:  RST     08H             ; ERROR-1
2099   0672 0E                  DEFB    $0E             ; Error Report: Invalid file name
2100   0673             
2101   0673             ;   continue with LOAD, MERGE, VERIFY and also SAVE within ten character limit.
2102   0673             
2103   0673             ;; SA-NULL
2104   0673 78          L0644:  LD      A,B             ; test length of filename
2105   0674 B1                  OR      C               ; for zero.
2106   0675 28 0A               JR      Z,L0652         ; forward to SA-DATA if so using the 255 
2107   0677                                             ; indicator followed by spaces.
2108   0677             
2109   0677 01 0A 00            LD      BC,$000A        ; else trim length to ten.
2110   067A             
2111   067A             ;   other paths rejoin here with BC holding length in range 1 - 10.
2112   067A             
2113   067A             ;; SA-NAME
2114   067A DD E5       L064B:  PUSH    IX              ; push start of file descriptor.
2115   067C E1                  POP     HL              ; and pop into HL.
2116   067D             
2117   067D 23                  INC     HL              ; HL now addresses first byte of filename.
2118   067E EB                  EX      DE,HL           ; transfer destination address to DE, start
2119   067F                                             ; of string in command to HL.
2120   067F ED B0               LDIR                    ; copy up to ten bytes
2121   0681                                             ; if less than ten then trailing spaces follow.
2122   0681             
2123   0681             ;   the case for the null string rejoins here.
2124   0681             
2125   0681             ;; SA-DATA
2126   0681 DF          L0652:  RST     18H             ; GET-CHAR
2127   0682 FE E4               CP      $E4             ; is character after filename the token 'DATA' ?
2128   0684 20 49               JR      NZ,L06A0        ; forward to SA-SCR$ to consider SCREEN$ if
2129   0686                                             ; not.
2130   0686             
2131   0686             ;   continue to consider DATA.
2132   0686             
2133   0686 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
2134   0689 FE 03               CP      $03             ; is it 'VERIFY' ?
2135   068B CA B9 1C            JP      Z,L1C8A         ; jump forward to REPORT-C if so.
2136   068E                                             ; 'Nonsense in BASIC'
2137   068E                                             ; VERIFY "d" DATA is not allowed.
2138   068E             
2139   068E             ;   continue with SAVE, LOAD, MERGE of DATA.
2140   068E             
2141   068E E7                  RST     20H             ; NEXT-CHAR
2142   068F CD E1 28            CALL    L28B2           ; routine LOOK-VARS searches variables area
2143   0692                                             ; returning with carry reset if found or
2144   0692                                             ; checking syntax.
2145   0692 CB F9               SET     7,C             ; this converts a simple string to a 
2146   0694                                             ; string array. The test for an array or string
2147   0694                                             ; comes later.
2148   0694 30 0B               JR      NC,L0672        ; forward to SA-V-OLD if variable found.
2149   0696             
2150   0696 21 00 00            LD      HL,$0000        ; set destination to zero as not fixed.
2151   0699 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
2152   069C 3D                  DEC     A               ; test for 1 - LOAD
2153   069D 28 15               JR      Z,L0685         ; forward to SA-V-NEW with LOAD DATA.
2154   069F                                             ; to load a new array.
2155   069F             
2156   069F             ;   otherwise the variable was not found in run-time with SAVE/MERGE.
2157   069F             
2158   069F             ;; REPORT-2a
2159   069F CF          L0670:  RST     08H             ; ERROR-1
2160   06A0 01                  DEFB    $01             ; Error Report: Variable not found
2161   06A1             
2162   06A1             ;   continue with SAVE/LOAD  DATA
2163   06A1             
2164   06A1             ;; SA-V-OLD
2165   06A1 C2 B9 1C    L0672:  JP      NZ,L1C8A        ; to REPORT-C if not an array variable.
2166   06A4                                             ; or erroneously a simple string.
2167   06A4                                             ; 'Nonsense in BASIC'
2168   06A4             
2169   06A4             
2170   06A4 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
2171   06A7 28 18               JR      Z,L0692         ; forward to SA-DATA-1 if checking syntax.
2172   06A9             
2173   06A9 23                  INC     HL              ; step past single character variable name.
2174   06AA 7E                  LD      A,(HL)          ; fetch low byte of length.
2175   06AB DD 77 0B            LD      (IX+$0B),A      ; place in descriptor.
2176   06AE 23                  INC     HL              ; point to high byte.
2177   06AF 7E                  LD      A,(HL)          ; and transfer that
2178   06B0 DD 77 0C            LD      (IX+$0C),A      ; to descriptor.
2179   06B3 23                  INC     HL              ; increase pointer within variable.
2180   06B4             
2181   06B4             ;; SA-V-NEW
2182   06B4 DD 71 0E    L0685:  LD      (IX+$0E),C      ; place character array name in  header.
2183   06B7 3E 01               LD      A,$01           ; default to type numeric.
2184   06B9 CB 71               BIT     6,C             ; test result from look-vars.
2185   06BB 28 01               JR      Z,L068F         ; forward to SA-V-TYPE if numeric.
2186   06BD             
2187   06BD 3C                  INC     A               ; set type to 2 - string array.
2188   06BE             
2189   06BE             ;; SA-V-TYPE
2190   06BE DD 77 00    L068F:  LD      (IX+$00),A      ; place type 0, 1 or 2 in descriptor.
2191   06C1             
2192   06C1             ;; SA-DATA-1
2193   06C1 EB          L0692:  EX      DE,HL           ; save var pointer in DE
2194   06C2             
2195   06C2 E7                  RST     20H             ; NEXT-CHAR
2196   06C3 FE 29               CP      $29             ; is character ')' ?
2197   06C5 20 DA               JR      NZ,L0672        ; back if not to SA-V-OLD to report
2198   06C7                                             ; 'Nonsense in BASIC'
2199   06C7             
2200   06C7 E7                  RST     20H             ; NEXT-CHAR advances character address.
2201   06C8 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END errors if not end of
2202   06CB                                             ; the statement.
2203   06CB             
2204   06CB EB                  EX      DE,HL           ; bring back variables data pointer.
2205   06CC C3 89 07            JP      L075A           ; jump forward to SA-ALL
2206   06CF             
2207   06CF             ; ---
2208   06CF             ;   the branch was here to consider a 'SCREEN$', the display file.
2209   06CF             
2210   06CF             ;; SA-SCR$
2211   06CF FE AA       L06A0:  CP      $AA             ; is character the token 'SCREEN$' ?
2212   06D1 20 1F               JR      NZ,L06C3        ; forward to SA-CODE if not.
2213   06D3             
2214   06D3 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
2215   06D6 FE 03               CP      $03             ; is it MERGE ?
2216   06D8 CA B9 1C            JP       Z,L1C8A        ; jump to REPORT-C if so.
2217   06DB                                             ; 'Nonsense in BASIC'
2218   06DB             
2219   06DB             ;   continue with SAVE/LOAD/VERIFY SCREEN$.
2220   06DB             
2221   06DB E7                  RST     20H             ; NEXT-CHAR
2222   06DC CD 1D 1C            CALL    L1BEE           ; routine CHECK-END errors if not at end of
2223   06DF                                             ; statement.
2224   06DF             
2225   06DF             ;   continue in runtime.
2226   06DF             
2227   06DF DD 36 0B 00         LD      (IX+$0B),$00    ; set descriptor length
2228   06E3 DD 36 0C 1B         LD      (IX+$0C),$1B    ; to $1b00 to include bitmaps and attributes.
2229   06E7             
2230   06E7 21 00 40            LD      HL,$4000        ; set start to display file start.
2231   06EA DD 75 0D            LD      (IX+$0D),L      ; place start in
2232   06ED DD 74 0E            LD      (IX+$0E),H      ; the descriptor.
2233   06F0 18 4D               JR      L0710           ; forward to SA-TYPE-3
2234   06F2             
2235   06F2             ; ---
2236   06F2             ;   the branch was here to consider CODE.
2237   06F2             
2238   06F2             ;; SA-CODE
2239   06F2 FE AF       L06C3:  CP      $AF             ; is character the token 'CODE' ?
2240   06F4 20 4F               JR      NZ,L0716        ; forward if not to SA-LINE to consider an
2241   06F6                                             ; auto-started BASIC program.
2242   06F6             
2243   06F6 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
2244   06F9 FE 03               CP      $03             ; is it MERGE ?
2245   06FB CA B9 1C            JP      Z,L1C8A         ; jump forward to REPORT-C if so.
2246   06FE                                             ; 'Nonsense in BASIC'
2247   06FE             
2248   06FE             
2249   06FE E7                  RST     20H             ; NEXT-CHAR advances character address.
2250   06FF CD 77 20            CALL    L2048           ; routine PR-ST-END checks if a carriage
2251   0702                                             ; return or ':' follows.
2252   0702 20 0C               JR      NZ,L06E1        ; forward to SA-CODE-1 if there are parameters.
2253   0704             
2254   0704 3A 74 5C            LD      A,($5C74)       ; else fetch the command from T_ADDR.
2255   0707 A7                  AND     A               ; test for zero - SAVE without a specification.
2256   0708 CA B9 1C            JP      Z,L1C8A         ; jump to REPORT-C if so.
2257   070B                                             ; 'Nonsense in BASIC'
2258   070B             
2259   070B             ;   for LOAD/VERIFY put zero on stack to signify handle at location saved from.
2260   070B             
2261   070B CD 15 1D            CALL    L1CE6           ; routine USE-ZERO
2262   070E 18 0F               JR      L06F0           ; forward to SA-CODE-2
2263   0710             
2264   0710             ; ---
2265   0710             
2266   0710             ;   if there are more characters after CODE expect start and possibly length.
2267   0710             
2268   0710             ;; SA-CODE-1
2269   0710 CD B1 1C    L06E1:  CALL    L1C82           ; routine EXPT-1NUM checks for numeric
2270   0713                                             ; expression and stacks it in run-time.
2271   0713             
2272   0713 DF                  RST     18H             ; GET-CHAR
2273   0714 FE 2C               CP      $2C             ; does a comma follow ?
2274   0716 28 0C               JR      Z,L06F5         ; forward if so to SA-CODE-3
2275   0718             
2276   0718             ;   else allow saved code to be loaded to a specified address.
2277   0718             
2278   0718 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
2279   071B A7                  AND     A               ; is the command SAVE which requires length ?
2280   071C CA B9 1C            JP      Z,L1C8A         ; jump to REPORT-C if so.
2281   071F                                             ; 'Nonsense in BASIC'
2282   071F             
2283   071F             ;   the command LOAD code may rejoin here with zero stacked as start.
2284   071F             
2285   071F             ;; SA-CODE-2
2286   071F CD 15 1D    L06F0:  CALL    L1CE6           ; routine USE-ZERO stacks zero for length.
2287   0722 18 04               JR      L06F9           ; forward to SA-CODE-4
2288   0724             
2289   0724             ; ---
2290   0724             ;   the branch was here with SAVE CODE start, 
2291   0724             
2292   0724             ;; SA-CODE-3
2293   0724 E7          L06F5:  RST     20H             ; NEXT-CHAR advances character address.
2294   0725 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM checks for expression
2295   0728                                             ; and stacks in run-time.
2296   0728             
2297   0728             ;   paths converge here and nothing must follow.
2298   0728             
2299   0728             ;; SA-CODE-4
2300   0728 CD 1D 1C    L06F9:  CALL    L1BEE           ; routine CHECK-END errors with extraneous
2301   072B                                             ; characters and quits if checking syntax.
2302   072B             
2303   072B             ;   in run-time there are two 16-bit parameters on the calculator stack.
2304   072B             
2305   072B CD C8 1E            CALL    L1E99           ; routine FIND-INT2 gets length.
2306   072E DD 71 0B            LD      (IX+$0B),C      ; place length 
2307   0731 DD 70 0C            LD      (IX+$0C),B      ; in descriptor.
2308   0734 CD C8 1E            CALL    L1E99           ; routine FIND-INT2 gets start.
2309   0737 DD 71 0D            LD      (IX+$0D),C      ; place start
2310   073A DD 70 0E            LD      (IX+$0E),B      ; in descriptor.
2311   073D 60                  LD      H,B             ; transfer the
2312   073E 69                  LD      L,C             ; start to HL also.
2313   073F             
2314   073F             ;; SA-TYPE-3
2315   073F DD 36 00 03 L0710:  LD      (IX+$00),$03    ; place type 3 - code in descriptor. 
2316   0743 18 44               JR      L075A           ; forward to SA-ALL.
2317   0745             
2318   0745             ; ---
2319   0745             ;   the branch was here with BASIC to consider an optional auto-start line
2320   0745             ;   number.
2321   0745             
2322   0745             ;; SA-LINE
2323   0745 FE CA       L0716:  CP      $CA             ; is character the token 'LINE' ?
2324   0747 28 09               JR      Z,L0723         ; forward to SA-LINE-1 if so.
2325   0749             
2326   0749             ;   else all possibilities have been considered and nothing must follow.
2327   0749             
2328   0749 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END
2329   074C             
2330   074C             ;   continue in run-time to save BASIC without auto-start.
2331   074C             
2332   074C DD 36 0E 80         LD      (IX+$0E),$80    ; place high line number in descriptor to
2333   0750                                             ; disable auto-start.
2334   0750 18 17               JR      L073A           ; forward to SA-TYPE-0 to save program.
2335   0752             
2336   0752             ; ---
2337   0752             ;   the branch was here to consider auto-start.
2338   0752             
2339   0752             ;; SA-LINE-1
2340   0752 3A 74 5C    L0723:  LD      A,($5C74)       ; fetch command from T_ADDR
2341   0755 A7                  AND     A               ; test for SAVE.
2342   0756 C2 B9 1C            JP      NZ,L1C8A        ; jump forward to REPORT-C with anything else.
2343   0759                                             ; 'Nonsense in BASIC'
2344   0759             
2345   0759             ; 
2346   0759             
2347   0759 E7                  RST     20H             ; NEXT-CHAR
2348   075A CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM checks for numeric
2349   075D                                             ; expression and stacks in run-time.
2350   075D CD 1D 1C            CALL    L1BEE           ; routine CHECK-END quits if syntax path.
2351   0760 CD C8 1E            CALL    L1E99           ; routine FIND-INT2 fetches the numeric
2352   0763                                             ; expression.
2353   0763 DD 71 0D            LD      (IX+$0D),C      ; place the auto-start
2354   0766 DD 70 0E            LD      (IX+$0E),B      ; line number in the descriptor.
2355   0769             
2356   0769             ;   Note. this isn't checked, but is subsequently handled by the system.
2357   0769             ;   If the user typed 40000 instead of 4000 then it won't auto-start
2358   0769             ;   at line 4000, or indeed, at all.
2359   0769             
2360   0769             ;   continue to save program and any variables.
2361   0769             
2362   0769             ;; SA-TYPE-0
2363   0769 DD 36 00 00 L073A:  LD      (IX+$00),$00    ; place type zero - program in descriptor.
2364   076D 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE to HL.
2365   0770 ED 5B 53 5C         LD      DE,($5C53)      ; fetch PROG to DE.
2366   0774 37                  SCF                     ; set carry flag to calculate from end of
2367   0775                                             ; variables E_LINE -1.
2368   0775 ED 52               SBC     HL,DE           ; subtract to give total length.
2369   0777             
2370   0777 DD 75 0B            LD      (IX+$0B),L      ; place total length
2371   077A DD 74 0C            LD      (IX+$0C),H      ; in descriptor.
2372   077D 2A 4B 5C            LD      HL,($5C4B)      ; load HL from system variable VARS
2373   0780 ED 52               SBC     HL,DE           ; subtract to give program length.
2374   0782 DD 75 0F            LD      (IX+$0F),L      ; place length of program
2375   0785 DD 74 10            LD      (IX+$10),H      ; in the descriptor.
2376   0788 EB                  EX      DE,HL           ; start to HL, length to DE.
2377   0789             
2378   0789             ;; SA-ALL
2379   0789 3A 74 5C    L075A:  LD      A,($5C74)       ; fetch command from T_ADDR
2380   078C A7                  AND     A               ; test for zero - SAVE.
2381   078D CA 9F 09            JP      Z,L0970         ; jump forward to SA-CONTRL with SAVE  ->
2382   0790             
2383   0790             ; ---
2384   0790             ;   continue with LOAD, MERGE and VERIFY.
2385   0790             
2386   0790 E5                  PUSH    HL              ; save start.
2387   0791 01 11 00            LD      BC,$0011        ; prepare to add seventeen
2388   0794 DD 09               ADD     IX,BC           ; to point IX at second descriptor.
2389   0796             
2390   0796             ;; LD-LOOK-H
2391   0796 DD E5       L0767:  PUSH    IX              ; save IX
2392   0798 11 11 00            LD      DE,$0011        ; seventeen bytes
2393   079B AF                  XOR     A               ; reset zero flag
2394   079C 37                  SCF                     ; set carry flag
2395   079D CD 85 05            CALL    L0556           ; routine LD-BYTES loads a header from tape
2396   07A0                                             ; to second descriptor.
2397   07A0 DD E1               POP     IX              ; restore IX.
2398   07A2 30 F2               JR      NC,L0767        ; loop back to LD-LOOK-H until header found.
2399   07A4             
2400   07A4 3E FE               LD      A,$FE           ; select system channel 'S'
2401   07A6 CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it.
2402   07A9             
2403   07A9 FD 36 52 03         LD      (IY+$52),$03    ; set SCR_CT to 3 lines.
2404   07AD             
2405   07AD 0E 80               LD      C,$80           ; C has bit 7 set to indicate type mismatch as
2406   07AF                                             ; a default startpoint.
2407   07AF             
2408   07AF DD 7E 00            LD      A,(IX+$00)      ; fetch loaded header type to A
2409   07B2 DD BE EF            CP      (IX-$11)        ; compare with expected type.
2410   07B5 20 02               JR      NZ,L078A        ; forward to LD-TYPE with mis-match.
2411   07B7             
2412   07B7 0E F6               LD      C,$F6           ; set C to minus ten - will count characters
2413   07B9                                             ; up to zero.
2414   07B9             
2415   07B9             ;; LD-TYPE
2416   07B9 FE 04       L078A:  CP      $04             ; check if type in acceptable range 0 - 3.
2417   07BB 30 D9               JR      NC,L0767        ; back to LD-LOOK-H with 4 and over.
2418   07BD             
2419   07BD             ;   else A indicates type 0-3.
2420   07BD             
2421   07BD 11 EF 09            LD      DE,L09C0        ; address base of last 4 tape messages
2422   07C0 C5                  PUSH    BC              ; save BC
2423   07C1 CD 39 0C            CALL    L0C0A           ; routine PO-MSG outputs relevant message.
2424   07C4                                             ; Note. all messages have a leading newline.
2425   07C4 C1                  POP     BC              ; restore BC
2426   07C5             
2427   07C5 DD E5               PUSH    IX              ; transfer IX,
2428   07C7 D1                  POP     DE              ; the 2nd descriptor, to DE.
2429   07C8 21 F0 FF            LD      HL,$FFF0        ; prepare minus seventeen.
2430   07CB 19                  ADD     HL,DE           ; add to point HL to 1st descriptor.
2431   07CC 06 0A               LD      B,$0A           ; the count will be ten characters for the
2432   07CE                                             ; filename.
2433   07CE             
2434   07CE 7E                  LD      A,(HL)          ; fetch first character and test for 
2435   07CF 3C                  INC     A               ; value 255.
2436   07D0 20 03               JR      NZ,L07A6        ; forward to LD-NAME if not the wildcard.
2437   07D2             
2438   07D2             ;   but if it is the wildcard, then add ten to C which is minus ten for a type
2439   07D2             ;   match or -128 for a type mismatch. Although characters have to be counted
2440   07D2             ;   bit 7 of C will not alter from state set here.
2441   07D2             
2442   07D2 79                  LD      A,C             ; transfer $F6 or $80 to A
2443   07D3 80                  ADD     A,B             ; add $0A
2444   07D4 4F                  LD      C,A             ; place result, zero or -118, in C.
2445   07D5             
2446   07D5             ;   At this point we have either a type mismatch, a wildcard match or ten
2447   07D5             ;   characters to be counted. The characters must be shown on the screen.
2448   07D5             
2449   07D5             ;; LD-NAME
2450   07D5 13          L07A6:  INC     DE              ; address next input character
2451   07D6 1A                  LD      A,(DE)          ; fetch character
2452   07D7 BE                  CP      (HL)            ; compare to expected
2453   07D8 23                  INC     HL              ; address next expected character
2454   07D9 20 01               JR      NZ,L07AD        ; forward to LD-CH-PR with mismatch
2455   07DB             
2456   07DB 0C                  INC     C               ; increment matched character count
2457   07DC             
2458   07DC             ;; LD-CH-PR
2459   07DC D7          L07AD:  RST     10H             ; PRINT-A prints character
2460   07DD 10 F6               DJNZ    L07A6           ; loop back to LD-NAME for ten characters.
2461   07DF             
2462   07DF             ;   if ten characters matched and the types previously matched then C will 
2463   07DF             ;   now hold zero.
2464   07DF             
2465   07DF CB 79               BIT     7,C             ; test if all matched
2466   07E1 20 B3               JR      NZ,L0767        ; back to LD-LOOK-H if not
2467   07E3             
2468   07E3             ;   else print a terminal carriage return.
2469   07E3             
2470   07E3 3E 0D               LD      A,$0D           ; prepare carriage return.
2471   07E5 D7                  RST     10H             ; PRINT-A outputs it.
2472   07E6             
2473   07E6             ;   The various control routines for LOAD, VERIFY and MERGE are executed 
2474   07E6             ;   during the one-second gap following the header on tape.
2475   07E6             
2476   07E6 E1                  POP     HL              ; restore xx
2477   07E7 DD 7E 00            LD      A,(IX+$00)      ; fetch incoming type 
2478   07EA FE 03               CP      $03             ; compare with CODE
2479   07EC 28 0C               JR      Z,L07CB         ; forward to VR-CONTRL if it is CODE.
2480   07EE             
2481   07EE             ;  type is a program or an array.
2482   07EE             
2483   07EE 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
2484   07F1 3D                  DEC     A               ; was it LOAD ?
2485   07F2 CA 37 08            JP      Z,L0808         ; JUMP forward to LD-CONTRL if so to 
2486   07F5                                             ; load BASIC or variables.
2487   07F5             
2488   07F5 FE 02               CP      $02             ; was command MERGE ?
2489   07F7 CA E5 08            JP      Z,L08B6         ; jump forward to ME-CONTRL if so.
2490   07FA             
2491   07FA             ;   else continue into VERIFY control routine to verify.
2492   07FA             
2493   07FA             ; ----------------------------
2494   07FA             ; THE 'VERIFY CONTROL' ROUTINE
2495   07FA             ; ----------------------------
2496   07FA             ;   There are two branches to this routine.
2497   07FA             ;   1) From above to verify a program or array
2498   07FA             ;   2) from earlier with no carry to load or verify code.
2499   07FA             
2500   07FA             ;; VR-CONTRL
2501   07FA E5          L07CB:  PUSH    HL              ; save pointer to data.
2502   07FB DD 6E FA            LD      L,(IX-$06)      ; fetch length of old data 
2503   07FE DD 66 FB            LD      H,(IX-$05)      ; to HL.
2504   0801 DD 5E 0B            LD      E,(IX+$0B)      ; fetch length of new data
2505   0804 DD 56 0C            LD      D,(IX+$0C)      ; to DE.
2506   0807 7C                  LD      A,H             ; check length of old
2507   0808 B5                  OR      L               ; for zero.
2508   0809 28 0D               JR      Z,L07E9         ; forward to VR-CONT-1 if length unspecified
2509   080B                                             ; e.g. LOAD "x" CODE
2510   080B             
2511   080B             ;   as opposed to, say, LOAD 'x' CODE 32768,300.
2512   080B             
2513   080B ED 52               SBC     HL,DE           ; subtract the two lengths.
2514   080D 38 26               JR      C,L0806         ; forward to REPORT-R if the length on tape is 
2515   080F                                             ; larger than that specified in command.
2516   080F                                             ; 'Tape loading error'
2517   080F             
2518   080F 28 07               JR      Z,L07E9         ; forward to VR-CONT-1 if lengths match.
2519   0811             
2520   0811             ;   a length on tape shorter than expected is not allowed for CODE
2521   0811             
2522   0811 DD 7E 00            LD      A,(IX+$00)      ; else fetch type from tape.
2523   0814 FE 03               CP      $03             ; is it CODE ?
2524   0816 20 1D               JR      NZ,L0806        ; forward to REPORT-R if so
2525   0818                                             ; 'Tape loading error'
2526   0818             
2527   0818             ;; VR-CONT-1
2528   0818 E1          L07E9:  POP     HL              ; pop pointer to data
2529   0819 7C                  LD      A,H             ; test for zero
2530   081A B5                  OR      L               ; e.g. LOAD 'x' CODE
2531   081B 20 06               JR      NZ,L07F4        ; forward to VR-CONT-2 if destination specified.
2532   081D             
2533   081D DD 6E 0D            LD      L,(IX+$0D)      ; else use the destination in the header
2534   0820 DD 66 0E            LD      H,(IX+$0E)      ; and load code at address saved from.
2535   0823             
2536   0823             ;; VR-CONT-2
2537   0823 E5          L07F4:  PUSH    HL              ; push pointer to start of data block.
2538   0824 DD E1               POP     IX              ; transfer to IX.
2539   0826 3A 74 5C            LD      A,($5C74)       ; fetch reduced command from T_ADDR
2540   0829 FE 02               CP      $02             ; is it VERIFY ?
2541   082B 37                  SCF                     ; prepare a set carry flag
2542   082C 20 01               JR      NZ,L0800        ; skip to VR-CONT-3 if not
2543   082E             
2544   082E A7                  AND     A               ; clear carry flag for VERIFY so that 
2545   082F                                             ; data is not loaded.
2546   082F             
2547   082F             ;; VR-CONT-3
2548   082F 3E FF       L0800:  LD      A,$FF           ; signal data block to be loaded
2549   0831             
2550   0831             ; -----------------
2551   0831             ; Load a data block
2552   0831             ; -----------------
2553   0831             ;   This routine is called from 3 places other than above to load a data block.
2554   0831             ;   In all cases the accumulator is first set to $FF so the routine could be 
2555   0831             ;   called at the previous instruction.
2556   0831             
2557   0831             ;; LD-BLOCK
2558   0831 CD 85 05    L0802:  CALL    L0556           ; routine LD-BYTES
2559   0834 D8                  RET     C               ; return if successful.
2560   0835             
2561   0835             
2562   0835             ;; REPORT-R
2563   0835 CF          L0806:  RST     08H             ; ERROR-1
2564   0836 1A                  DEFB    $1A             ; Error Report: Tape loading error
2565   0837             
2566   0837             ; --------------------------
2567   0837             ; THE 'LOAD CONTROL' ROUTINE
2568   0837             ; --------------------------
2569   0837             ;   This branch is taken when the command is LOAD with type 0, 1 or 2. 
2570   0837             
2571   0837             ;; LD-CONTRL
2572   0837 DD 5E 0B    L0808:  LD      E,(IX+$0B)      ; fetch length of found data block 
2573   083A DD 56 0C            LD      D,(IX+$0C)      ; from 2nd descriptor.
2574   083D E5                  PUSH    HL              ; save destination
2575   083E 7C                  LD      A,H             ; test for zero
2576   083F B5                  OR      L               ;
2577   0840 20 06               JR      NZ,L0819        ; forward if not to LD-CONT-1
2578   0842             
2579   0842 13                  INC     DE              ; increase length
2580   0843 13                  INC     DE              ; for letter name
2581   0844 13                  INC     DE              ; and 16-bit length
2582   0845 EB                  EX      DE,HL           ; length to HL, 
2583   0846 18 0C               JR      L0825           ; forward to LD-CONT-2
2584   0848             
2585   0848             ; ---
2586   0848             
2587   0848             ;; LD-CONT-1
2588   0848 DD 6E FA    L0819:  LD      L,(IX-$06)      ; fetch length from 
2589   084B DD 66 FB            LD      H,(IX-$05)      ; the first header.
2590   084E EB                  EX      DE,HL           ;
2591   084F 37                  SCF                     ; set carry flag
2592   0850 ED 52               SBC     HL,DE           ;
2593   0852 38 09               JR      C,L082E         ; to LD-DATA
2594   0854             
2595   0854             ;; LD-CONT-2
2596   0854 11 05 00    L0825:  LD      DE,$0005        ; allow overhead of five bytes.
2597   0857 19                  ADD     HL,DE           ; add in the difference in data lengths.
2598   0858 44                  LD      B,H             ; transfer to
2599   0859 4D                  LD      C,L             ; the BC register pair
2600   085A CD 34 1F            CALL    L1F05           ; routine TEST-ROOM fails if not enough room.
2601   085D             
2602   085D             ;; LD-DATA
2603   085D E1          L082E:  POP     HL              ; pop destination
2604   085E DD 7E 00            LD      A,(IX+$00)      ; fetch type 0, 1 or 2.
2605   0861 A7                  AND     A               ; test for program and variables.
2606   0862 28 3E               JR      Z,L0873         ; forward if so to LD-PROG
2607   0864             
2608   0864             ;   the type is a numeric or string array.
2609   0864             
2610   0864 7C                  LD      A,H             ; test the destination for zero
2611   0865 B5                  OR      L               ; indicating variable does not already exist.
2612   0866 28 13               JR      Z,L084C         ; forward if so to LD-DATA-1
2613   0868             
2614   0868             ;   else the destination is the first dimension within the array structure
2615   0868             
2616   0868 2B                  DEC     HL              ; address high byte of total length
2617   0869 46                  LD      B,(HL)          ; transfer to B.
2618   086A 2B                  DEC     HL              ; address low byte of total length.
2619   086B 4E                  LD      C,(HL)          ; transfer to C.
2620   086C 2B                  DEC     HL              ; point to letter of variable.
2621   086D 03                  INC     BC              ; adjust length to
2622   086E 03                  INC     BC              ; include these
2623   086F 03                  INC     BC              ; three bytes also.
2624   0870 DD 22 5F 5C         LD      ($5C5F),IX      ; save header pointer in X_PTR.
2625   0874 CD 17 1A            CALL    L19E8           ; routine RECLAIM-2 reclaims the old variable
2626   0877                                             ; sliding workspace including the two headers 
2627   0877                                             ; downwards.
2628   0877 DD 2A 5F 5C         LD      IX,($5C5F)      ; reload IX from X_PTR which will have been
2629   087B                                             ; adjusted down by POINTERS routine.
2630   087B             
2631   087B             ;; LD-DATA-1
2632   087B 2A 59 5C    L084C:  LD      HL,($5C59)      ; address E_LINE
2633   087E 2B                  DEC     HL              ; now point to the $80 variables end-marker.
2634   087F DD 4E 0B            LD      C,(IX+$0B)      ; fetch new data length 
2635   0882 DD 46 0C            LD      B,(IX+$0C)      ; from 2nd header.
2636   0885 C5                  PUSH    BC              ; * save it.
2637   0886 03                  INC     BC              ; adjust the 
2638   0887 03                  INC     BC              ; length to include
2639   0888 03                  INC     BC              ; letter name and total length.
2640   0889 DD 7E FD            LD      A,(IX-$03)      ; fetch letter name from old header.
2641   088C F5                  PUSH    AF              ; preserve accumulator though not corrupted.
2642   088D             
2643   088D CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates space for variable
2644   0890                                             ; sliding workspace up. IX no longer addresses
2645   0890                                             ; anywhere meaningful.
2646   0890 23                  INC     HL              ; point to first new location.
2647   0891             
2648   0891 F1                  POP     AF              ; fetch back the letter name.
2649   0892 77                  LD      (HL),A          ; place in first new location.
2650   0893 D1                  POP     DE              ; * pop the data length.
2651   0894 23                  INC     HL              ; address 2nd location
2652   0895 73                  LD      (HL),E          ; store low byte of length.
2653   0896 23                  INC     HL              ; address next.
2654   0897 72                  LD      (HL),D          ; store high byte.
2655   0898 23                  INC     HL              ; address start of data.
2656   0899 E5                  PUSH    HL              ; transfer address
2657   089A DD E1               POP     IX              ; to IX register pair.
2658   089C 37                  SCF                     ; set carry flag indicating load not verify.
2659   089D 3E FF               LD      A,$FF           ; signal data not header.
2660   089F C3 31 08            JP      L0802           ; JUMP back to LD-BLOCK
2661   08A2             
2662   08A2             ; -----------------
2663   08A2             ;   the branch is here when a program as opposed to an array is to be loaded.
2664   08A2             
2665   08A2             ;; LD-PROG
2666   08A2 EB          L0873:  EX      DE,HL           ; transfer dest to DE.
2667   08A3 2A 59 5C            LD      HL,($5C59)      ; address E_LINE
2668   08A6 2B                  DEC     HL              ; now variables end-marker.
2669   08A7 DD 22 5F 5C         LD      ($5C5F),IX      ; place the IX header pointer in X_PTR
2670   08AB DD 4E 0B            LD      C,(IX+$0B)      ; get new length
2671   08AE DD 46 0C            LD      B,(IX+$0C)      ; from 2nd header
2672   08B1 C5                  PUSH    BC              ; and save it.
2673   08B2             
2674   08B2 CD 14 1A            CALL    L19E5           ; routine RECLAIM-1 reclaims program and vars.
2675   08B5                                             ; adjusting X-PTR.
2676   08B5             
2677   08B5 C1                  POP     BC              ; restore new length.
2678   08B6 E5                  PUSH    HL              ; * save start
2679   08B7 C5                  PUSH    BC              ; ** and length.
2680   08B8             
2681   08B8 CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates the space.
2682   08BB             
2683   08BB DD 2A 5F 5C         LD      IX,($5C5F)      ; reload IX from adjusted X_PTR
2684   08BF 23                  INC     HL              ; point to start of new area.
2685   08C0 DD 4E 0F            LD      C,(IX+$0F)      ; fetch length of BASIC on tape
2686   08C3 DD 46 10            LD      B,(IX+$10)      ; from 2nd descriptor
2687   08C6 09                  ADD     HL,BC           ; add to address the start of variables.
2688   08C7 22 4B 5C            LD      ($5C4B),HL      ; set system variable VARS
2689   08CA             
2690   08CA DD 66 0E            LD      H,(IX+$0E)      ; fetch high byte of autostart line number.
2691   08CD 7C                  LD      A,H             ; transfer to A
2692   08CE E6 C0               AND     $C0             ; test if greater than $3F.
2693   08D0 20 0A               JR      NZ,L08AD        ; forward to LD-PROG-1 if so with no autostart.
2694   08D2             
2695   08D2 DD 6E 0D            LD      L,(IX+$0D)      ; else fetch the low byte.
2696   08D5 22 42 5C            LD      ($5C42),HL      ; set system variable to line number NEWPPC
2697   08D8 FD 36 0A 00         LD      (IY+$0A),$00    ; set statement NSPPC to zero.
2698   08DC             
2699   08DC             ;; LD-PROG-1
2700   08DC D1          L08AD:  POP     DE              ; ** pop the length
2701   08DD DD E1               POP     IX              ; * and start.
2702   08DF 37                  SCF                     ; set carry flag
2703   08E0 3E FF               LD      A,$FF           ; signal data as opposed to a header.
2704   08E2 C3 31 08            JP      L0802           ; jump back to LD-BLOCK
2705   08E5             
2706   08E5             ; ---------------------------
2707   08E5             ; THE 'MERGE CONTROL' ROUTINE
2708   08E5             ; ---------------------------
2709   08E5             ;   the branch was here to merge a program and its variables or an array.
2710   08E5             ;
2711   08E5             
2712   08E5             ;; ME-CONTRL
2713   08E5 DD 4E 0B    L08B6:  LD      C,(IX+$0B)      ; fetch length
2714   08E8 DD 46 0C            LD      B,(IX+$0C)      ; of data block on tape.
2715   08EB C5                  PUSH    BC              ; save it.
2716   08EC 03                  INC     BC              ; one for the pot.
2717   08ED             
2718   08ED F7                  RST     30H             ; BC-SPACES creates room in workspace.
2719   08EE                                             ; HL addresses last new location.
2720   08EE 36 80               LD      (HL),$80        ; place end-marker at end.
2721   08F0 EB                  EX      DE,HL           ; transfer first location to HL.
2722   08F1 D1                  POP     DE              ; restore length to DE.
2723   08F2 E5                  PUSH    HL              ; save start.
2724   08F3             
2725   08F3 E5                  PUSH    HL              ; and transfer it
2726   08F4 DD E1               POP     IX              ; to IX register.
2727   08F6 37                  SCF                     ; set carry flag to load data on tape.
2728   08F7 3E FF               LD      A,$FF           ; signal data not a header.
2729   08F9 CD 31 08            CALL    L0802           ; routine LD-BLOCK loads to workspace.
2730   08FC E1                  POP     HL              ; restore first location in workspace to HL.
2731   08FD ED 5B 53 5C X08CE   LD      DE,($5C53)      ; set DE from system variable PROG.
2732   0901             
2733   0901             ;   now enter a loop to merge the data block in workspace with the program and 
2734   0901             ;   variables. 
2735   0901             
2736   0901             ;; ME-NEW-LP
2737   0901 7E          L08D2:  LD      A,(HL)          ; fetch next byte from workspace.
2738   0902 E6 C0               AND     $C0             ; compare with $3F.
2739   0904 20 19               JR      NZ,L08F0        ; forward to ME-VAR-LP if a variable or 
2740   0906                                             ; end-marker.
2741   0906             
2742   0906             ;   continue when HL addresses a BASIC line number.
2743   0906             
2744   0906             ;; ME-OLD-LP
2745   0906 1A          L08D7:  LD      A,(DE)          ; fetch high byte from program area.
2746   0907 13                  INC     DE              ; bump prog address.
2747   0908 BE                  CP      (HL)            ; compare with that in workspace.
2748   0909 23                  INC     HL              ; bump workspace address.
2749   090A 20 02               JR      NZ,L08DF        ; forward to ME-OLD-L1 if high bytes don't match
2750   090C             
2751   090C 1A                  LD      A,(DE)          ; fetch the low byte of program line number.
2752   090D BE                  CP      (HL)            ; compare with that in workspace.
2753   090E             
2754   090E             ;; ME-OLD-L1
2755   090E 1B          L08DF:  DEC     DE              ; point to start of
2756   090F 2B                  DEC     HL              ; respective lines again.
2757   0910 30 08               JR      NC,L08EB        ; forward to ME-NEW-L2 if line number in 
2758   0912                                             ; workspace is less than or equal to current
2759   0912                                             ; program line as has to be added to program.
2760   0912             
2761   0912 E5                  PUSH    HL              ; else save workspace pointer. 
2762   0913 EB                  EX      DE,HL           ; transfer prog pointer to HL
2763   0914 CD E7 19            CALL    L19B8           ; routine NEXT-ONE finds next line in DE.
2764   0917 E1                  POP     HL              ; restore workspace pointer
2765   0918 18 EC               JR      L08D7           ; back to ME-OLD-LP until destination position 
2766   091A                                             ; in program area found.
2767   091A             
2768   091A             ; ---
2769   091A             ;   the branch was here with an insertion or replacement point.
2770   091A             
2771   091A             ;; ME-NEW-L2
2772   091A CD 5B 09    L08EB:  CALL    L092C           ; routine ME-ENTER enters the line
2773   091D 18 E2               JR      L08D2           ; loop back to ME-NEW-LP.
2774   091F             
2775   091F             ; ---
2776   091F             ;   the branch was here when the location in workspace held a variable.
2777   091F             
2778   091F             ;; ME-VAR-LP
2779   091F 7E          L08F0:  LD      A,(HL)          ; fetch first byte of workspace variable.
2780   0920 4F                  LD      C,A             ; copy to C also.
2781   0921 FE 80               CP      $80             ; is it the end-marker ?
2782   0923 C8                  RET     Z               ; return if so as complete.  >>>>>
2783   0924             
2784   0924 E5                  PUSH    HL              ; save workspace area pointer.
2785   0925 2A 4B 5C            LD      HL,($5C4B)      ; load HL with VARS - start of variables area.
2786   0928             
2787   0928             ;; ME-OLD-VP
2788   0928 7E          L08F9:  LD      A,(HL)          ; fetch first byte.
2789   0929 FE 80               CP      $80             ; is it the end-marker ?
2790   092B 28 25               JR      Z,L0923         ; forward if so to ME-VAR-L2 to add
2791   092D                                             ; variable at end of variables area.
2792   092D             
2793   092D B9                  CP      C               ; compare with variable in workspace area.
2794   092E 28 08               JR      Z,L0909         ; forward to ME-OLD-V2 if a match to replace.
2795   0930             
2796   0930             ;   else entire variables area has to be searched.
2797   0930             
2798   0930             ;; ME-OLD-V1
2799   0930 C5          L0901:  PUSH    BC              ; save character in C.
2800   0931 CD E7 19            CALL    L19B8           ; routine NEXT-ONE gets following variable 
2801   0934                                             ; address in DE.
2802   0934 C1                  POP     BC              ; restore character in C
2803   0935 EB                  EX      DE,HL           ; transfer next address to HL.
2804   0936 18 F0               JR      L08F9           ; loop back to ME-OLD-VP
2805   0938             
2806   0938             ; --- 
2807   0938             ;   the branch was here when first characters of name matched. 
2808   0938             
2809   0938             ;; ME-OLD-V2
2810   0938 E6 E0       L0909:  AND     $E0             ; keep bits 11100000
2811   093A FE A0               CP      $A0             ; compare   10100000 - a long-named variable.
2812   093C             
2813   093C 20 12               JR      NZ,L0921        ; forward to ME-VAR-L1 if just one-character.
2814   093E             
2815   093E             ;   but long-named variables have to be matched character by character.
2816   093E             
2817   093E D1                  POP     DE              ; fetch workspace 1st character pointer
2818   093F D5                  PUSH    DE              ; and save it on the stack again.
2819   0940 E5                  PUSH    HL              ; save variables area pointer on stack.
2820   0941             
2821   0941             ;; ME-OLD-V3
2822   0941 23          L0912:  INC     HL              ; address next character in vars area.
2823   0942 13                  INC     DE              ; address next character in workspace area.
2824   0943 1A                  LD      A,(DE)          ; fetch workspace character.
2825   0944 BE                  CP      (HL)            ; compare to variables character.
2826   0945 20 06               JR      NZ,L091E        ; forward to ME-OLD-V4 with a mismatch.
2827   0947             
2828   0947 17                  RLA                     ; test if the terminal inverted character.
2829   0948 30 F7               JR      NC,L0912        ; loop back to ME-OLD-V3 if more to test.
2830   094A             
2831   094A             ;   otherwise the long name matches in its entirety.
2832   094A             
2833   094A E1                  POP     HL              ; restore pointer to first character of variable
2834   094B 18 03               JR      L0921           ; forward to ME-VAR-L1
2835   094D             
2836   094D             ; ---
2837   094D             ;   the branch is here when two characters don't match
2838   094D             
2839   094D             ;; ME-OLD-V4
2840   094D E1          L091E:  POP     HL              ; restore the prog/vars pointer.
2841   094E 18 E0               JR      L0901           ; back to ME-OLD-V1 to resume search.
2842   0950             
2843   0950             ; ---
2844   0950             ;   branch here when variable is to replace an existing one
2845   0950             
2846   0950             ;; ME-VAR-L1
2847   0950 3E FF       L0921:  LD      A,$FF           ; indicate a replacement.
2848   0952             
2849   0952             ;   this entry point is when A holds $80 indicating a new variable.
2850   0952             
2851   0952             ;; ME-VAR-L2
2852   0952 D1          L0923:  POP     DE              ; pop workspace pointer.
2853   0953 EB                  EX      DE,HL           ; now make HL workspace pointer, DE vars pointer
2854   0954 3C                  INC     A               ; zero flag set if replacement.
2855   0955 37                  SCF                     ; set carry flag indicating a variable not a
2856   0956                                             ; program line.
2857   0956 CD 5B 09            CALL    L092C           ; routine ME-ENTER copies variable in.
2858   0959 18 C4               JR      L08F0           ; loop back to ME-VAR-LP
2859   095B             
2860   095B             ; ------------------------
2861   095B             ; Merge a Line or Variable
2862   095B             ; ------------------------
2863   095B             ;   A BASIC line or variable is inserted at the current point. If the line 
2864   095B             ;   number or variable names match (zero flag set) then a replacement takes 
2865   095B             ;   place.
2866   095B             
2867   095B             ;; ME-ENTER
2868   095B 20 10       L092C:  JR      NZ,L093E        ; forward to ME-ENT-1 for insertion only.
2869   095D             
2870   095D             ;   but the program line or variable matches so old one is reclaimed.
2871   095D             
2872   095D 08                  EX      AF,AF'          ; save flag??
2873   095E 22 5F 5C            LD      ($5C5F),HL      ; preserve workspace pointer in dynamic X_PTR
2874   0961 EB                  EX      DE,HL           ; transfer program dest pointer to HL.
2875   0962 CD E7 19            CALL    L19B8           ; routine NEXT-ONE finds following location
2876   0965                                             ; in program or variables area.
2877   0965 CD 17 1A            CALL    L19E8           ; routine RECLAIM-2 reclaims the space between.
2878   0968 EB                  EX      DE,HL           ; transfer program dest pointer back to DE.
2879   0969 2A 5F 5C            LD      HL,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
2880   096C 08                  EX      AF,AF'          ; restore flags.
2881   096D             
2882   096D             ;   now the new line or variable is entered.
2883   096D             
2884   096D             ;; ME-ENT-1
2885   096D 08          L093E:  EX      AF,AF'          ; save or re-save flags.
2886   096E D5                  PUSH    DE              ; save dest pointer in prog/vars area.
2887   096F CD E7 19            CALL    L19B8           ; routine NEXT-ONE finds next in workspace.
2888   0972                                             ; gets next in DE, difference in BC.
2889   0972                                             ; prev addr in HL
2890   0972 22 5F 5C            LD      ($5C5F),HL      ; store pointer in X_PTR
2891   0975 2A 53 5C            LD      HL,($5C53)      ; load HL from system variable PROG
2892   0978 E3                  EX      (SP),HL         ; swap with prog/vars pointer on stack. 
2893   0979 C5                  PUSH    BC              ; ** save length of new program line/variable.
2894   097A 08                  EX      AF,AF'          ; fetch flags back.
2895   097B 38 07               JR      C,L0955         ; skip to ME-ENT-2 if variable
2896   097D             
2897   097D 2B                  DEC     HL              ; address location before pointer
2898   097E CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates room for BASIC line
2899   0981 23                  INC     HL              ; address next.
2900   0982 18 03               JR      L0958           ; forward to ME-ENT-3
2901   0984             
2902   0984             ; ---
2903   0984             
2904   0984             ;; ME-ENT-2
2905   0984 CD 84 16    L0955:  CALL    L1655           ; routine MAKE-ROOM creates room for variable.
2906   0987             
2907   0987             ;; ME-ENT-3
2908   0987 23          L0958:  INC     HL              ; address next?
2909   0988             
2910   0988 C1                  POP     BC              ; ** pop length
2911   0989 D1                  POP     DE              ; * pop value for PROG which may have been 
2912   098A                                             ; altered by POINTERS if first line.
2913   098A ED 53 53 5C         LD      ($5C53),DE      ; set PROG to original value.
2914   098E ED 5B 5F 5C         LD      DE,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
2915   0992 C5                  PUSH    BC              ; save length
2916   0993 D5                  PUSH    DE              ; and workspace pointer
2917   0994 EB                  EX      DE,HL           ; make workspace pointer source, prog/vars
2918   0995                                             ; pointer the destination
2919   0995 ED B0               LDIR                    ; copy bytes of line or variable into new area.
2920   0997 E1                  POP     HL              ; restore workspace pointer.
2921   0998 C1                  POP     BC              ; restore length.
2922   0999 D5                  PUSH    DE              ; save new prog/vars pointer.
2923   099A CD 17 1A            CALL    L19E8           ; routine RECLAIM-2 reclaims the space used
2924   099D                                             ; by the line or variable in workspace block
2925   099D                                             ; as no longer required and space could be 
2926   099D                                             ; useful for adding more lines.
2927   099D D1                  POP     DE              ; restore the prog/vars pointer
2928   099E C9                  RET                     ; return.
2929   099F             
2930   099F             ; --------------------------
2931   099F             ; THE 'SAVE CONTROL' ROUTINE
2932   099F             ; --------------------------
2933   099F             ;   A branch from the main SAVE-ETC routine at SAVE-ALL.
2934   099F             ;   First the header data is saved. Then after a wait of 1 second
2935   099F             ;   the data itself is saved.
2936   099F             ;   HL points to start of data.
2937   099F             ;   IX points to start of descriptor.
2938   099F             
2939   099F             ;; SA-CONTRL
2940   099F E5          L0970:  PUSH    HL              ; save start of data
2941   09A0             
2942   09A0 3E FD               LD      A,$FD           ; select system channel 'S'
2943   09A2 CD 30 16            CALL    L1601           ; routine CHAN-OPEN
2944   09A5             
2945   09A5 AF                  XOR     A               ; clear to address table directly
2946   09A6 11 D0 09            LD      DE,L09A1        ; address: tape-msgs
2947   09A9 CD 39 0C            CALL    L0C0A           ; routine PO-MSG -
2948   09AC                                             ; 'Start tape then press any key.'
2949   09AC             
2950   09AC FD CB 02 EE         SET     5,(IY+$02)      ; TV_FLAG  - Signal lower screen requires
2951   09B0                                             ; clearing
2952   09B0 CD 03 16            CALL    L15D4           ; routine WAIT-KEY
2953   09B3             
2954   09B3 DD E5               PUSH    IX              ; save pointer to descriptor.
2955   09B5 11 11 00            LD      DE,$0011        ; there are seventeen bytes.
2956   09B8 AF                  XOR     A               ; signal a header.
2957   09B9 CD F1 04            CALL    L04C2           ; routine SA-BYTES
2958   09BC             
2959   09BC DD E1               POP     IX              ; restore descriptor pointer.
2960   09BE             
2961   09BE 06 32               LD      B,$32           ; wait for a second - 50 interrupts.
2962   09C0             
2963   09C0             ;; SA-1-SEC
2964   09C0 76          L0991:  HALT                    ; wait for interrupt
2965   09C1 10 FD               DJNZ    L0991           ; back to SA-1-SEC until pause complete.
2966   09C3             
2967   09C3 DD 5E 0B            LD      E,(IX+$0B)      ; fetch length of bytes from the
2968   09C6 DD 56 0C            LD      D,(IX+$0C)      ; descriptor.
2969   09C9             
2970   09C9 3E FF               LD      A,$FF           ; signal data bytes.
2971   09CB             
2972   09CB DD E1               POP     IX              ; retrieve pointer to start
2973   09CD C3 F1 04            JP      L04C2           ; jump back to SA-BYTES
2974   09D0             
2975   09D0             
2976   09D0             ;   Arrangement of two headers in workspace.
2977   09D0             ;   Originally IX addresses first location and only one header is required
2978   09D0             ;   when saving.
2979   09D0             ;
2980   09D0             ;   OLD     NEW         PROG   DATA  DATA  CODE 
2981   09D0             ;   HEADER  HEADER             num   chr          NOTES.
2982   09D0             ;   ------  ------      ----   ----  ----  ----   -----------------------------
2983   09D0             ;   IX-$11  IX+$00      0      1     2     3      Type.
2984   09D0             ;   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
2985   09D0             ;   IX-$0F  IX+$02      x      x     x     x      i
2986   09D0             ;   IX-$0E  IX+$03      x      x     x     x      l
2987   09D0             ;   IX-$0D  IX+$04      x      x     x     x      e
2988   09D0             ;   IX-$0C  IX+$05      x      x     x     x      n
2989   09D0             ;   IX-$0B  IX+$06      x      x     x     x      a
2990   09D0             ;   IX-$0A  IX+$07      x      x     x     x      m
2991   09D0             ;   IX-$09  IX+$08      x      x     x     x      e
2992   09D0             ;   IX-$08  IX+$09      x      x     x     x      .
2993   09D0             ;   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
2994   09D0             ;   IX-$06  IX+$0B      lo     lo    lo    lo     Total  
2995   09D0             ;   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
2996   09D0             ;   IX-$04  IX+$0D      Auto   -     -     Start  Various
2997   09D0             ;   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
2998   09D0             ;   IX-$02  IX+$0F      lo     -     -     -      Length of Program 
2999   09D0             ;   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.
3000   09D0             ;
3001   09D0             
3002   09D0             
3003   09D0             ; ------------------------
3004   09D0             ; Canned cassette messages
3005   09D0             ; ------------------------
3006   09D0             ;   The last-character-inverted Cassette messages.
3007   09D0             ;   Starts with normal initial step-over byte.
3008   09D0             
3009   09D0             ;; tape-msgs
3010   09D0 80          L09A1:  DEFB    $80
3011   09D1 53 74 61 72         DEFM    "Start tape, then press any key"
3011   09D5 74 20 74 61 
3011   09D9 70 65 2C 20 
3011   09DD 74 68 65 6E 
3011   09E1 20 70 72 65 
3011   09E5 73 73 20 61 
3011   09E9 6E 79 20 6B 
3011   09ED 65 79 
3012   09EF AE          L09C0:  DEFB    '.'+$80
3013   09F0 0D                  DEFB    $0D
3014   09F1 50 72 6F 67         DEFM    "Program:"
3014   09F5 72 61 6D 3A 
3015   09F9 A0                  DEFB    ' '+$80
3016   09FA 0D                  DEFB    $0D
3017   09FB 4E 75 6D 62         DEFM    "Number array:"
3017   09FF 65 72 20 61 
3017   0A03 72 72 61 79 
3017   0A07 3A 
3018   0A08 A0                  DEFB    ' '+$80
3019   0A09 0D                  DEFB    $0D
3020   0A0A 43 68 61 72         DEFM    "Character array:"
3020   0A0E 61 63 74 65 
3020   0A12 72 20 61 72 
3020   0A16 72 61 79 3A 
3021   0A1A A0                  DEFB    ' '+$80
3022   0A1B 0D                  DEFB    $0D
3023   0A1C 42 79 74 65         DEFM    "Bytes:"
3023   0A20 73 3A 
3024   0A22 A0                  DEFB    ' '+$80
3025   0A23             
3026   0A23             
3027   0A23             ;**************************************************
3028   0A23             ;** Part 5. SCREEN AND PRINTER HANDLING ROUTINES **
3029   0A23             ;**************************************************
3030   0A23             
3031   0A23             ; --------------------------
3032   0A23             ; THE 'PRINT OUTPUT' ROUTINE
3033   0A23             ; --------------------------
3034   0A23             ;   This is the routine most often used by the RST 10 restart although the
3035   0A23             ;   subroutine is on two occasions called directly when it is known that
3036   0A23             ;   output will definitely be to the lower screen.
3037   0A23             
3038   0A23             ;; PRINT-OUT
3039   0A23 CD 32 0B    L09F4:  CALL    L0B03           ; routine PO-FETCH fetches print position
3040   0A26                                             ; to HL register pair.
3041   0A26 FE 20               CP      $20             ; is character a space or higher ?
3042   0A28 D2 08 0B            JP      NC,L0AD9        ; jump forward to PO-ABLE if so.
3043   0A2B             
3044   0A2B FE 06               CP      $06             ; is character in range 00-05 ?
3045   0A2D 38 69               JR      C,L0A69         ; to PO-QUEST to print '?' if so.
3046   0A2F             
3047   0A2F FE 18               CP      $18             ; is character in range 24d - 31d ?
3048   0A31 30 65               JR      NC,L0A69        ; to PO-QUEST to also print '?' if so.
3049   0A33             
3050   0A33 21 3A 0A            LD      HL,L0A11 - 6    ; address 0A0B - the base address of control
3051   0A36                                             ; character table - where zero would be.
3052   0A36 5F                  LD      E,A             ; control character 06 - 23d
3053   0A37 16 00               LD      D,$00           ; is transferred to DE.
3054   0A39             
3055   0A39 19                  ADD     HL,DE           ; index into table.
3056   0A3A             
3057   0A3A 5E                  LD      E,(HL)          ; fetch the offset to routine.
3058   0A3B 19                  ADD     HL,DE           ; add to make HL the address.
3059   0A3C E5                  PUSH    HL              ; push the address.
3060   0A3D             
3061   0A3D C3 32 0B            JP      L0B03           ; Jump forward to PO-FETCH, 
3062   0A40                                             ; as the screen/printer position has been 
3063   0A40                                             ; disturbed, and then indirectly to the PO-STORE
3064   0A40                                             ; routine on stack.
3065   0A40             
3066   0A40             ; -----------------------------
3067   0A40             ; THE 'CONTROL CHARACTER' TABLE
3068   0A40             ; -----------------------------
3069   0A40             ;   For control characters in the range 6 - 23d the following table
3070   0A40             ;   is indexed to provide an offset to the handling routine that
3071   0A40             ;   follows the table.
3072   0A40             
3073   0A40             ;; ctlchrtab
3074   0A40 4E          L0A11:  DEFB    L0A5F - $       ; 06d offset $4E to Address: PO-COMMA
3075   0A41 57                  DEFB    L0A69 - $       ; 07d offset $57 to Address: PO-QUEST
3076   0A42 10                  DEFB    L0A23 - $       ; 08d offset $10 to Address: PO-BACK-1
3077   0A43 29                  DEFB    L0A3D - $       ; 09d offset $29 to Address: PO-RIGHT
3078   0A44 54                  DEFB    L0A69 - $       ; 10d offset $54 to Address: PO-QUEST
3079   0A45 53                  DEFB    L0A69 - $       ; 11d offset $53 to Address: PO-QUEST
3080   0A46 52                  DEFB    L0A69 - $       ; 12d offset $52 to Address: PO-QUEST
3081   0A47 37                  DEFB    L0A4F - $       ; 13d offset $37 to Address: PO-ENTER
3082   0A48 50                  DEFB    L0A69 - $       ; 14d offset $50 to Address: PO-QUEST
3083   0A49 4F                  DEFB    L0A69 - $       ; 15d offset $4F to Address: PO-QUEST
3084   0A4A 5F                  DEFB    L0A7A - $       ; 16d offset $5F to Address: PO-1-OPER
3085   0A4B 5E                  DEFB    L0A7A - $       ; 17d offset $5E to Address: PO-1-OPER
3086   0A4C 5D                  DEFB    L0A7A - $       ; 18d offset $5D to Address: PO-1-OPER
3087   0A4D 5C                  DEFB    L0A7A - $       ; 19d offset $5C to Address: PO-1-OPER
3088   0A4E 5B                  DEFB    L0A7A - $       ; 20d offset $5B to Address: PO-1-OPER
3089   0A4F 5A                  DEFB    L0A7A - $       ; 21d offset $5A to Address: PO-1-OPER
3090   0A50 54                  DEFB    L0A75 - $       ; 22d offset $54 to Address: PO-2-OPER
3091   0A51 53                  DEFB    L0A75 - $       ; 23d offset $53 to Address: PO-2-OPER
3092   0A52             
3093   0A52             
3094   0A52             ; -------------------------
3095   0A52             ; THE 'CURSOR LEFT' ROUTINE
3096   0A52             ; -------------------------
3097   0A52             ;   Backspace and up a line if that action is from the left of screen.
3098   0A52             ;   For ZX printer backspace up to first column but not beyond.
3099   0A52             
3100   0A52             ;; PO-BACK-1
3101   0A52 0C          L0A23:  INC     C               ; move left one column.
3102   0A53 3E 22               LD      A,$22           ; value $21 is leftmost column.
3103   0A55 B9                  CP      C               ; have we passed ?
3104   0A56 20 11               JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
3105   0A58             
3106   0A58 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3107   0A5C 20 09               JR      NZ,L0A38        ; to PO-BACK-2 if so, as we are unable to
3108   0A5E                                             ; backspace from the leftmost position.
3109   0A5E             
3110   0A5E             
3111   0A5E 04                  INC     B               ; move up one screen line
3112   0A5F 0E 02               LD      C,$02           ; the rightmost column position.
3113   0A61 3E 18               LD      A,$18           ; Note. This should be $19
3114   0A63                                             ; credit. Dr. Frank O'Hara, 1982
3115   0A63             
3116   0A63 B8                  CP      B               ; has position moved past top of screen ?
3117   0A64 20 03               JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
3118   0A66             
3119   0A66 05                  DEC     B               ; else back to $18.
3120   0A67             
3121   0A67             ;; PO-BACK-2
3122   0A67 0E 21       L0A38:  LD      C,$21           ; the leftmost column position.
3123   0A69             
3124   0A69             ;; PO-BACK-3
3125   0A69 C3 08 0E    L0A3A:  JP      L0DD9           ; to CL-SET and PO-STORE to save new
3126   0A6C                                             ; position in system variables.
3127   0A6C             
3128   0A6C             ; --------------------------
3129   0A6C             ; THE 'CURSOR RIGHT' ROUTINE
3130   0A6C             ; --------------------------
3131   0A6C             ;   This moves the print position to the right leaving a trail in the
3132   0A6C             ;   current background colour.
3133   0A6C             ;   "However the programmer has failed to store the new print position
3134   0A6C             ;   so CHR$ 9 will only work if the next print position is at a newly
3135   0A6C             ;   defined place.
3136   0A6C             ;   e.g. PRINT PAPER 2; CHR$ 9; AT 4,0;
3137   0A6C             ;   does work but is not very helpful"
3138   0A6C             ;   - Dr. Ian Logan, Understanding Your Spectrum, 1982.
3139   0A6C             
3140   0A6C             ;; PO-RIGHT
3141   0A6C 3A 91 5C    L0A3D:  LD      A,($5C91)       ; fetch P_FLAG value
3142   0A6F F5                  PUSH    AF              ; and save it on stack.
3143   0A70             
3144   0A70 FD 36 57 01         LD      (IY+$57),$01    ; temporarily set P_FLAG 'OVER 1'.
3145   0A74 3E 20               LD      A,$20           ; prepare a space.
3146   0A76 CD 94 0B            CALL    L0B65           ; routine PO-CHAR to print it.
3147   0A79                                             ; Note. could be PO-ABLE which would update
3148   0A79                                             ; the column position.
3149   0A79             
3150   0A79 F1                  POP     AF              ; restore the permanent flag.
3151   0A7A 32 91 5C            LD      ($5C91),A       ; and restore system variable P_FLAG
3152   0A7D             
3153   0A7D C9                  RET                     ; return without updating column position
3154   0A7E             
3155   0A7E             ; -----------------------
3156   0A7E             ; Perform carriage return
3157   0A7E             ; -----------------------
3158   0A7E             ; A carriage return is 'printed' to screen or printer buffer.
3159   0A7E             
3160   0A7E             ;; PO-ENTER
3161   0A7E FD CB 01 4E L0A4F:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3162   0A82 C2 FC 0E            JP      NZ,L0ECD        ; to COPY-BUFF if so, to flush buffer and reset
3163   0A85                                             ; the print position.
3164   0A85             
3165   0A85 0E 21               LD      C,$21           ; the leftmost column position.
3166   0A87 CD 84 0C            CALL    L0C55           ; routine PO-SCR handles any scrolling required.
3167   0A8A 05                  DEC     B               ; to next screen line.
3168   0A8B C3 08 0E            JP      L0DD9           ; jump forward to CL-SET to store new position.
3169   0A8E             
3170   0A8E             ; -----------
3171   0A8E             ; Print comma
3172   0A8E             ; -----------
3173   0A8E             ; The comma control character. The 32 column screen has two 16 character
3174   0A8E             ; tabstops.  The routine is only reached via the control character table.
3175   0A8E             
3176   0A8E             ;; PO-COMMA
3177   0A8E CD 32 0B    L0A5F:  CALL    L0B03           ; routine PO-FETCH - seems unnecessary.
3178   0A91             
3179   0A91 79                  LD      A,C             ; the column position. $21-$01
3180   0A92 3D                  DEC     A               ; move right. $20-$00
3181   0A93 3D                  DEC     A               ; and again   $1F-$00 or $FF if trailing
3182   0A94 E6 10               AND     $10             ; will be $00 or $10.
3183   0A96 18 5A               JR      L0AC3           ; forward to PO-FILL
3184   0A98             
3185   0A98             ; -------------------
3186   0A98             ; Print question mark
3187   0A98             ; -------------------
3188   0A98             ; This routine prints a question mark which is commonly
3189   0A98             ; used to print an unassigned control character in range 0-31d.
3190   0A98             ; there are a surprising number yet to be assigned.
3191   0A98             
3192   0A98             ;; PO-QUEST
3193   0A98 3E 3F       L0A69:  LD      A,$3F           ; prepare the character '?'.
3194   0A9A 18 6C               JR      L0AD9           ; forward to PO-ABLE.
3195   0A9C             
3196   0A9C             ; --------------------------------
3197   0A9C             ; Control characters with operands
3198   0A9C             ; --------------------------------
3199   0A9C             ; Certain control characters are followed by 1 or 2 operands.
3200   0A9C             ; The entry points from control character table are PO-2-OPER and PO-1-OPER.
3201   0A9C             ; The routines alter the output address of the current channel so that
3202   0A9C             ; subsequent RST $10 instructions take the appropriate action
3203   0A9C             ; before finally resetting the output address back to PRINT-OUT.
3204   0A9C             
3205   0A9C             ;; PO-TV-2
3206   0A9C 11 B6 0A    L0A6D:  LD      DE,L0A87        ; address: PO-CONT will be next output routine
3207   0A9F 32 0F 5C            LD      ($5C0F),A       ; store first operand in TVDATA-hi
3208   0AA2 18 0B               JR      L0A80           ; forward to PO-CHANGE >>
3209   0AA4             
3210   0AA4             ; ---
3211   0AA4             
3212   0AA4             ; -> This initial entry point deals with two operands - AT or TAB.
3213   0AA4             
3214   0AA4             ;; PO-2-OPER
3215   0AA4 11 9C 0A    L0A75:  LD      DE,L0A6D        ; address: PO-TV-2 will be next output routine
3216   0AA7 18 03               JR      L0A7D           ; forward to PO-TV-1
3217   0AA9             
3218   0AA9             ; ---
3219   0AA9             
3220   0AA9             ; -> This initial entry point deals with one operand INK to OVER.
3221   0AA9             
3222   0AA9             ;; PO-1-OPER
3223   0AA9 11 B6 0A    L0A7A:  LD      DE,L0A87        ; address: PO-CONT will be next output routine
3224   0AAC             
3225   0AAC             ;; PO-TV-1
3226   0AAC 32 0E 5C    L0A7D:  LD      ($5C0E),A       ; store control code in TVDATA-lo
3227   0AAF             
3228   0AAF             ;; PO-CHANGE
3229   0AAF 2A 51 5C    L0A80:  LD      HL,($5C51)      ; use CURCHL to find current output channel.
3230   0AB2 73                  LD      (HL),E          ; make it
3231   0AB3 23                  INC     HL              ; the supplied
3232   0AB4 72                  LD      (HL),D          ; address from DE.
3233   0AB5 C9                  RET                     ; return.
3234   0AB6             
3235   0AB6             ; ---
3236   0AB6             
3237   0AB6             ;; PO-CONT
3238   0AB6 11 23 0A    L0A87:  LD      DE,L09F4        ; Address: PRINT-OUT
3239   0AB9 CD AF 0A            CALL    L0A80           ; routine PO-CHANGE to restore normal channel.
3240   0ABC 2A 0E 5C            LD      HL,($5C0E)      ; TVDATA gives control code and possible
3241   0ABF                                             ; subsequent character
3242   0ABF 57                  LD      D,A             ; save current character
3243   0AC0 7D                  LD      A,L             ; the stored control code
3244   0AC1 FE 16               CP      $16             ; was it INK to OVER (1 operand) ?
3245   0AC3 DA 40 22            JP      C,L2211         ; to CO-TEMP-5
3246   0AC6             
3247   0AC6 20 29               JR      NZ,L0AC2        ; to PO-TAB if not 22d i.e. 23d TAB.
3248   0AC8             
3249   0AC8                                             ; else must have been 22d AT.
3250   0AC8 44                  LD      B,H             ; line to H   (0-23d)
3251   0AC9 4A                  LD      C,D             ; column to C (0-31d)
3252   0ACA 3E 1F               LD      A,$1F           ; the value 31d
3253   0ACC 91                  SUB     C               ; reverse the column number.
3254   0ACD 38 0C               JR      C,L0AAC         ; to PO-AT-ERR if C was greater than 31d.
3255   0ACF             
3256   0ACF C6 02               ADD     A,$02           ; transform to system range $02-$21
3257   0AD1 4F                  LD      C,A             ; and place in column register.
3258   0AD2             
3259   0AD2 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3260   0AD6 20 16               JR      NZ,L0ABF        ; to PO-AT-SET as line can be ignored.
3261   0AD8             
3262   0AD8 3E 16               LD      A,$16           ; 22 decimal
3263   0ADA 90                  SUB     B               ; subtract line number to reverse
3264   0ADB                                             ; 0 - 22 becomes 22 - 0.
3265   0ADB             
3266   0ADB             ;; PO-AT-ERR
3267   0ADB DA CE 1E    L0AAC:  JP      C,L1E9F         ; to REPORT-B if higher than 22 decimal
3268   0ADE                                             ; Integer out of range.
3269   0ADE             
3270   0ADE 3C                  INC     A               ; adjust for system range $01-$17
3271   0ADF 47                  LD      B,A             ; place in line register
3272   0AE0 04                  INC     B               ; adjust to system range  $02-$18
3273   0AE1 FD CB 02 46         BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?
3274   0AE5 C2 84 0C            JP      NZ,L0C55        ; exit to PO-SCR to test for scrolling
3275   0AE8             
3276   0AE8 FD BE 31            CP      (IY+$31)        ; Compare against DF_SZ
3277   0AEB DA B5 0C            JP      C,L0C86         ; to REPORT-5 if too low
3278   0AEE                                             ; Out of screen.
3279   0AEE             
3280   0AEE             ;; PO-AT-SET
3281   0AEE C3 08 0E    L0ABF:  JP      L0DD9           ; print position is valid so exit via CL-SET
3282   0AF1             
3283   0AF1             ; ---
3284   0AF1             
3285   0AF1             ; Continue here when dealing with TAB.
3286   0AF1             ; Note. In BASIC, TAB is followed by a 16-bit number and was initially
3287   0AF1             ; designed to work with any output device.
3288   0AF1             
3289   0AF1             ;; PO-TAB
3290   0AF1 7C          L0AC2:  LD      A,H             ; transfer parameter to A
3291   0AF2                                             ; Losing current character -
3292   0AF2                                             ; High byte of TAB parameter.
3293   0AF2             
3294   0AF2             
3295   0AF2             ;; PO-FILL
3296   0AF2 CD 32 0B    L0AC3:  CALL    L0B03           ; routine PO-FETCH, HL-addr, BC=line/column.
3297   0AF5                                             ; column 1 (right), $21 (left)
3298   0AF5 81                  ADD     A,C             ; add operand to current column
3299   0AF6 3D                  DEC     A               ; range 0 - 31+
3300   0AF7 E6 1F               AND     $1F             ; make range 0 - 31d
3301   0AF9 C8                  RET     Z               ; return if result zero
3302   0AFA             
3303   0AFA 57                  LD      D,A             ; Counter to D
3304   0AFB FD CB 01 C6         SET     0,(IY+$01)      ; update FLAGS  - signal suppress leading space.
3305   0AFF             
3306   0AFF             ;; PO-SPACE
3307   0AFF 3E 20       L0AD0:  LD      A,$20           ; space character.
3308   0B01             
3309   0B01 CD 6A 0C            CALL    L0C3B           ; routine PO-SAVE prints the character
3310   0B04                                             ; using alternate set (normal output routine)
3311   0B04             
3312   0B04 15                  DEC     D               ; decrement counter.
3313   0B05 20 F8               JR      NZ,L0AD0        ; to PO-SPACE until done
3314   0B07             
3315   0B07 C9                  RET                     ; return
3316   0B08             
3317   0B08             ; ----------------------
3318   0B08             ; Printable character(s)
3319   0B08             ; ----------------------
3320   0B08             ; This routine prints printable characters and continues into
3321   0B08             ; the position store routine
3322   0B08             
3323   0B08             ;; PO-ABLE
3324   0B08 CD 53 0B    L0AD9:  CALL    L0B24           ; routine PO-ANY
3325   0B0B                                             ; and continue into position store routine.
3326   0B0B             
3327   0B0B             ; ----------------------------
3328   0B0B             ; THE 'POSITION STORE' ROUTINE
3329   0B0B             ; ----------------------------
3330   0B0B             ;   This routine updates the system variables associated with the main screen, 
3331   0B0B             ;   the lower screen/input buffer or the ZX printer.
3332   0B0B             
3333   0B0B             ;; PO-STORE
3334   0B0B FD CB 01 4E L0ADC:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
3335   0B0F 20 1A               JR      NZ,L0AFC        ; Forward, if so, to PO-ST-PR
3336   0B11             
3337   0B11 FD CB 02 46         BIT     0,(IY+$02)      ; Test TV_FLAG - is lower screen in use ?
3338   0B15 20 08               JR      NZ,L0AF0        ; Forward, if so, to PO-ST-E
3339   0B17             
3340   0B17             ;   This section deals with the upper screen.
3341   0B17             
3342   0B17 ED 43 88 5C         LD      ($5C88),BC      ; Update S_POSN - line/column upper screen
3343   0B1B 22 84 5C            LD      ($5C84),HL      ; Update DF_CC - upper display file address
3344   0B1E             
3345   0B1E C9                  RET                     ; Return.
3346   0B1F             
3347   0B1F             ; ---
3348   0B1F             
3349   0B1F             ;   This section deals with the lower screen.
3350   0B1F             
3351   0B1F             ;; PO-ST-E
3352   0B1F ED 43 8A 5C L0AF0:  LD      ($5C8A),BC      ; Update SPOSNL line/column lower screen
3353   0B23 ED 43 82 5C         LD      ($5C82),BC      ; Update ECHO_E line/column input buffer
3354   0B27 22 86 5C            LD      ($5C86),HL      ; Update DFCCL  lower screen memory address
3355   0B2A C9                  RET                     ; Return.
3356   0B2B             
3357   0B2B             ; ---
3358   0B2B             
3359   0B2B             ;   This section deals with the ZX Printer.
3360   0B2B             
3361   0B2B             ;; PO-ST-PR
3362   0B2B FD 71 45    L0AFC:  LD      (IY+$45),C      ; Update P_POSN column position printer
3363   0B2E 22 80 5C            LD      ($5C80),HL      ; Update PR_CC - full printer buffer memory 
3364   0B31                                             ; address
3365   0B31 C9                  RET                     ; Return.
3366   0B32             
3367   0B32             ;   Note. that any values stored in location 23681 will be overwritten with 
3368   0B32             ;   the value 91 decimal. 
3369   0B32             ;   Credit April 1983, Dilwyn Jones. "Delving Deeper into your ZX Spectrum".
3370   0B32             
3371   0B32             ; ----------------------------
3372   0B32             ; THE 'POSITION FETCH' ROUTINE
3373   0B32             ; ----------------------------
3374   0B32             ;   This routine fetches the line/column and display file address of the upper 
3375   0B32             ;   and lower screen or, if the printer is in use, the column position and 
3376   0B32             ;   absolute memory address.
3377   0B32             ;   Note. that PR-CC-hi (23681) is used by this routine and if, in accordance 
3378   0B32             ;   with the manual (that says this is unused), the location has been used for 
3379   0B32             ;   other purposes, then subsequent output to the printer buffer could corrupt 
3380   0B32             ;   a 256-byte section of memory.
3381   0B32             
3382   0B32             ;; PO-FETCH
3383   0B32 FD CB 01 4E L0B03:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
3384   0B36 20 14               JR      NZ,L0B1D        ; Forward, if so, to PO-F-PR
3385   0B38             
3386   0B38             ;   assume upper screen in use and thus optimize for path that requires speed.
3387   0B38             
3388   0B38 ED 4B 88 5C         LD      BC,($5C88)      ; Fetch line/column from S_POSN
3389   0B3C 2A 84 5C            LD      HL,($5C84)      ; Fetch DF_CC display file address
3390   0B3F             
3391   0B3F FD CB 02 46         BIT     0,(IY+$02)      ; Test TV_FLAG - lower screen in use ?
3392   0B43 C8                  RET     Z               ; Return if upper screen in use.
3393   0B44             
3394   0B44             ;   Overwrite registers with values for lower screen.
3395   0B44             
3396   0B44 ED 4B 8A 5C         LD      BC,($5C8A)      ; Fetch line/column from SPOSNL
3397   0B48 2A 86 5C            LD      HL,($5C86)      ; Fetch display file address from DFCCL
3398   0B4B C9                  RET                     ; Return.
3399   0B4C             
3400   0B4C             ; ---
3401   0B4C             
3402   0B4C             ;   This section deals with the ZX Printer.
3403   0B4C             
3404   0B4C             ;; PO-F-PR
3405   0B4C FD 4E 45    L0B1D:  LD      C,(IY+$45)      ; Fetch column from P_POSN.
3406   0B4F 2A 80 5C            LD      HL,($5C80)      ; Fetch printer buffer address from PR_CC.
3407   0B52 C9                  RET                     ; Return.
3408   0B53             
3409   0B53             ; ---------------------------------
3410   0B53             ; THE 'PRINT ANY CHARACTER' ROUTINE
3411   0B53             ; ---------------------------------
3412   0B53             ;   This routine is used to print any character in range 32d - 255d
3413   0B53             ;   It is only called from PO-ABLE which continues into PO-STORE
3414   0B53             
3415   0B53             ;; PO-ANY
3416   0B53 FE 80       L0B24:  CP      $80             ; ASCII ?
3417   0B55 38 3D               JR      C,L0B65         ; to PO-CHAR is so.
3418   0B57             
3419   0B57 FE 90               CP      $90             ; test if a block graphic character.
3420   0B59 30 26               JR      NC,L0B52        ; to PO-T&UDG to print tokens and UDGs
3421   0B5B             
3422   0B5B             ; The 16 2*2 mosaic characters 128-143 decimal are formed from
3423   0B5B             ; bits 0-3 of the character.
3424   0B5B             
3425   0B5B 47                  LD      B,A             ; save character
3426   0B5C CD 67 0B            CALL    L0B38           ; routine PO-GR-1 to construct top half
3427   0B5F                                             ; then bottom half.
3428   0B5F CD 32 0B            CALL    L0B03           ; routine PO-FETCH fetches print position.
3429   0B62 11 92 5C            LD      DE,$5C92        ; MEM-0 is location of 8 bytes of character
3430   0B65 18 47               JR      L0B7F           ; to PR-ALL to print to screen or printer
3431   0B67             
3432   0B67             ; ---
3433   0B67             
3434   0B67             ;; PO-GR-1
3435   0B67 21 92 5C    L0B38:  LD      HL,$5C92        ; address MEM-0 - a temporary buffer in
3436   0B6A                                             ; systems variables which is normally used
3437   0B6A                                             ; by the calculator.
3438   0B6A CD 6D 0B            CALL    L0B3E           ; routine PO-GR-2 to construct top half
3439   0B6D                                             ; and continue into routine to construct
3440   0B6D                                             ; bottom half.
3441   0B6D             
3442   0B6D             ;; PO-GR-2
3443   0B6D CB 18       L0B3E:  RR      B               ; rotate bit 0/2 to carry
3444   0B6F 9F                  SBC     A,A             ; result $00 or $FF
3445   0B70 E6 0F               AND     $0F             ; mask off right hand side
3446   0B72 4F                  LD      C,A             ; store part in C
3447   0B73 CB 18               RR      B               ; rotate bit 1/3 of original chr to carry
3448   0B75 9F                  SBC     A,A             ; result $00 or $FF
3449   0B76 E6 F0               AND     $F0             ; mask off left hand side
3450   0B78 B1                  OR      C               ; combine with stored pattern
3451   0B79 0E 04               LD      C,$04           ; four bytes for top/bottom half
3452   0B7B             
3453   0B7B             ;; PO-GR-3
3454   0B7B 77          L0B4C:  LD      (HL),A          ; store bit patterns in temporary buffer
3455   0B7C 23                  INC     HL              ; next address
3456   0B7D 0D                  DEC     C               ; jump back to
3457   0B7E 20 FB               JR      NZ,L0B4C        ; to PO-GR-3 until byte is stored 4 times
3458   0B80             
3459   0B80 C9                  RET                     ; return
3460   0B81             
3461   0B81             ; ---
3462   0B81             
3463   0B81             ; Tokens and User defined graphics are now separated.
3464   0B81             
3465   0B81             ;; PO-T&UDG
3466   0B81 D6 A5       L0B52:  SUB     $A5             ; the 'RND' character
3467   0B83 30 09               JR      NC,L0B5F        ; to PO-T to print tokens
3468   0B85             
3469   0B85 C6 15               ADD     A,$15           ; add 21d to restore to 0 - 20
3470   0B87 C5                  PUSH    BC              ; save current print position
3471   0B88 ED 4B 7B 5C         LD      BC,($5C7B)      ; fetch UDG to address bit patterns
3472   0B8C 18 0B               JR      L0B6A           ; to PO-CHAR-2 - common code to lay down
3473   0B8E                                             ; a bit patterned character
3474   0B8E             
3475   0B8E             ; ---
3476   0B8E             
3477   0B8E             ;; PO-T
3478   0B8E CD 3F 0C    L0B5F:  CALL    L0C10           ; routine PO-TOKENS prints tokens
3479   0B91 C3 32 0B            JP      L0B03           ; exit via a JUMP to PO-FETCH as this routine 
3480   0B94                                             ; must continue into PO-STORE. 
3481   0B94                                             ; A JR instruction could be used.
3482   0B94             
3483   0B94             ; This point is used to print ASCII characters  32d - 127d.
3484   0B94             
3485   0B94             ;; PO-CHAR
3486   0B94 C5          L0B65:  PUSH    BC              ; save print position
3487   0B95 ED 4B 36 5C         LD      BC,($5C36)      ; address CHARS
3488   0B99             
3489   0B99             ; This common code is used to transfer the character bytes to memory.
3490   0B99             
3491   0B99             ;; PO-CHAR-2
3492   0B99 EB          L0B6A:  EX      DE,HL           ; transfer destination address to DE
3493   0B9A 21 3B 5C            LD      HL,$5C3B        ; point to FLAGS
3494   0B9D CB 86               RES     0,(HL)          ; allow for leading space
3495   0B9F FE 20               CP      $20             ; is it a space ?
3496   0BA1 20 02               JR      NZ,L0B76        ; to PO-CHAR-3 if not
3497   0BA3             
3498   0BA3 CB C6               SET     0,(HL)          ; signal no leading space to FLAGS
3499   0BA5             
3500   0BA5             ;; PO-CHAR-3
3501   0BA5 26 00       L0B76:  LD      H,$00           ; set high byte to 0
3502   0BA7 6F                  LD      L,A             ; character to A
3503   0BA8                                             ; 0-21 UDG or 32-127 ASCII.
3504   0BA8 29                  ADD     HL,HL           ; multiply
3505   0BA9 29                  ADD     HL,HL           ; by
3506   0BAA 29                  ADD     HL,HL           ; eight
3507   0BAB 09                  ADD     HL,BC           ; HL now points to first byte of character
3508   0BAC C1                  POP     BC              ; the source address CHARS or UDG
3509   0BAD EB                  EX      DE,HL           ; character address to DE
3510   0BAE             
3511   0BAE             ; ----------------------------------
3512   0BAE             ; THE 'PRINT ALL CHARACTERS' ROUTINE
3513   0BAE             ; ----------------------------------
3514   0BAE             ;   This entry point entered from above to print ASCII and UDGs but also from 
3515   0BAE             ;   earlier to print mosaic characters.
3516   0BAE             ;   HL=destination
3517   0BAE             ;   DE=character source
3518   0BAE             ;   BC=line/column
3519   0BAE             
3520   0BAE             ;; PR-ALL
3521   0BAE 79          L0B7F:  LD      A,C             ; column to A
3522   0BAF 3D                  DEC     A               ; move right
3523   0BB0 3E 21               LD      A,$21           ; pre-load with leftmost position
3524   0BB2 20 0E               JR      NZ,L0B93        ; but if not zero to PR-ALL-1
3525   0BB4             
3526   0BB4 05                  DEC     B               ; down one line
3527   0BB5 4F                  LD      C,A             ; load C with $21
3528   0BB6 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use
3529   0BBA 28 06               JR      Z,L0B93         ; to PR-ALL-1 if not
3530   0BBC             
3531   0BBC D5                  PUSH    DE              ; save source address
3532   0BBD CD FC 0E            CALL    L0ECD           ; routine COPY-BUFF outputs line to printer
3533   0BC0 D1                  POP     DE              ; restore character source address
3534   0BC1 79                  LD      A,C             ; the new column number ($21) to C
3535   0BC2             
3536   0BC2             ;; PR-ALL-1
3537   0BC2 B9          L0B93:  CP      C               ; this test is really for screen - new line ?
3538   0BC3 D5                  PUSH    DE              ; save source
3539   0BC4             
3540   0BC4 CC 84 0C            CALL    Z,L0C55         ; routine PO-SCR considers scrolling
3541   0BC7             
3542   0BC7 D1                  POP     DE              ; restore source
3543   0BC8 C5                  PUSH    BC              ; save line/column
3544   0BC9 E5                  PUSH    HL              ; and destination
3545   0BCA 3A 91 5C            LD      A,($5C91)       ; fetch P_FLAG to accumulator
3546   0BCD 06 FF               LD      B,$FF           ; prepare OVER mask in B.
3547   0BCF 1F                  RRA                     ; bit 0 set if OVER 1
3548   0BD0 38 01               JR      C,L0BA4         ; to PR-ALL-2
3549   0BD2             
3550   0BD2 04                  INC     B               ; set OVER mask to 0
3551   0BD3             
3552   0BD3             ;; PR-ALL-2
3553   0BD3 1F          L0BA4:  RRA                     ; skip bit 1 of P_FLAG
3554   0BD4 1F                  RRA                     ; bit 2 is INVERSE
3555   0BD5 9F                  SBC     A,A             ; will be FF for INVERSE 1 else zero
3556   0BD6 4F                  LD      C,A             ; transfer INVERSE mask to C
3557   0BD7 3E 08               LD      A,$08           ; prepare to count 8 bytes
3558   0BD9 A7                  AND     A               ; clear carry to signal screen
3559   0BDA FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3560   0BDE 28 05               JR      Z,L0BB6         ; to PR-ALL-3 if screen
3561   0BE0             
3562   0BE0 FD CB 30 CE         SET     1,(IY+$30)      ; update FLAGS2  - signal printer buffer has 
3563   0BE4                                             ; been used.
3564   0BE4 37                  SCF                     ; set carry flag to signal printer.
3565   0BE5             
3566   0BE5             ;; PR-ALL-3
3567   0BE5 EB          L0BB6:  EX      DE,HL           ; now HL=source, DE=destination
3568   0BE6             
3569   0BE6             ;; PR-ALL-4
3570   0BE6 08          L0BB7:  EX      AF,AF'          ; save printer/screen flag
3571   0BE7 1A                  LD      A,(DE)          ; fetch existing destination byte
3572   0BE8 A0                  AND     B               ; consider OVER
3573   0BE9 AE                  XOR     (HL)            ; now XOR with source
3574   0BEA A9                  XOR     C               ; now with INVERSE MASK
3575   0BEB 12                  LD      (DE),A          ; update screen/printer
3576   0BEC 08                  EX      AF,AF'          ; restore flag
3577   0BED 38 13               JR      C,L0BD3         ; to PR-ALL-6 - printer address update
3578   0BEF             
3579   0BEF 14                  INC     D               ; gives next pixel line down screen
3580   0BF0             
3581   0BF0             ;; PR-ALL-5
3582   0BF0 23          L0BC1:  INC     HL              ; address next character byte
3583   0BF1 3D                  DEC     A               ; the byte count is decremented
3584   0BF2 20 F2               JR      NZ,L0BB7        ; back to PR-ALL-4 for all 8 bytes
3585   0BF4             
3586   0BF4 EB                  EX      DE,HL           ; destination to HL
3587   0BF5 25                  DEC     H               ; bring back to last updated screen position
3588   0BF6 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3589   0BFA CC 0A 0C            CALL    Z,L0BDB         ; if not, call routine PO-ATTR to update
3590   0BFD                                             ; corresponding colour attribute.
3591   0BFD E1                  POP     HL              ; restore original screen/printer position
3592   0BFE C1                  POP     BC              ; and line column
3593   0BFF 0D                  DEC     C               ; move column to right
3594   0C00 23                  INC     HL              ; increase screen/printer position
3595   0C01 C9                  RET                     ; return and continue into PO-STORE
3596   0C02                                             ; within PO-ABLE
3597   0C02             
3598   0C02             ; ---
3599   0C02             
3600   0C02             ;   This branch is used to update the printer position by 32 places
3601   0C02             ;   Note. The high byte of the address D remains constant (which it should).
3602   0C02             
3603   0C02             ;; PR-ALL-6
3604   0C02 08          L0BD3:  EX      AF,AF'          ; save the flag
3605   0C03 3E 20               LD      A,$20           ; load A with 32 decimal
3606   0C05 83                  ADD     A,E             ; add this to E
3607   0C06 5F                  LD      E,A             ; and store result in E
3608   0C07 08                  EX      AF,AF'          ; fetch the flag
3609   0C08 18 E6               JR      L0BC1           ; back to PR-ALL-5
3610   0C0A             
3611   0C0A             ; -----------------------------------
3612   0C0A             ; THE 'GET ATTRIBUTE ADDRESS' ROUTINE
3613   0C0A             ; -----------------------------------
3614   0C0A             ;   This routine is entered with the HL register holding the last screen
3615   0C0A             ;   address to be updated by PRINT or PLOT.
3616   0C0A             ;   The Spectrum screen arrangement leads to the L register holding the correct
3617   0C0A             ;   value for the attribute file and it is only necessary to manipulate H to 
3618   0C0A             ;   form the correct colour attribute address.
3619   0C0A             
3620   0C0A             ;; PO-ATTR
3621   0C0A 7C          L0BDB:  LD       A,H            ; fetch high byte $40 - $57
3622   0C0B 0F                  RRCA                    ; shift
3623   0C0C 0F                  RRCA                    ; bits 3 and 4
3624   0C0D 0F                  RRCA                    ; to right.
3625   0C0E E6 03               AND     $03             ; range is now 0 - 2
3626   0C10 F6 58               OR      $58             ; form correct high byte for third of screen
3627   0C12 67                  LD      H,A             ; HL is now correct
3628   0C13 ED 5B 8F 5C         LD      DE,($5C8F)      ; make D hold ATTR_T, E hold MASK-T
3629   0C17 7E                  LD      A,(HL)          ; fetch existing attribute
3630   0C18 AB                  XOR     E               ; apply masks
3631   0C19 A2                  AND     D               ;
3632   0C1A AB                  XOR     E               ;
3633   0C1B FD CB 57 76         BIT     6,(IY+$57)      ; test P_FLAG  - is this PAPER 9 ??
3634   0C1F 28 08               JR      Z,L0BFA         ; skip to PO-ATTR-1 if not.
3635   0C21             
3636   0C21 E6 C7               AND     $C7             ; set paper
3637   0C23 CB 57               BIT     2,A             ; to contrast with ink
3638   0C25 20 02               JR      NZ,L0BFA        ; skip to PO-ATTR-1
3639   0C27             
3640   0C27 EE 38               XOR     $38             ;
3641   0C29             
3642   0C29             ;; PO-ATTR-1
3643   0C29 FD CB 57 66 L0BFA:  BIT     4,(IY+$57)      ; test P_FLAG  - Is this INK 9 ??
3644   0C2D 28 08               JR      Z,L0C08         ; skip to PO-ATTR-2 if not
3645   0C2F             
3646   0C2F E6 F8               AND     $F8             ; make ink
3647   0C31 CB 6F               BIT     5,A             ; contrast with paper.
3648   0C33 20 02               JR      NZ,L0C08        ; to PO-ATTR-2
3649   0C35             
3650   0C35 EE 07               XOR     $07             ;
3651   0C37             
3652   0C37             ;; PO-ATTR-2
3653   0C37 77          L0C08:  LD      (HL),A          ; save the new attribute.
3654   0C38 C9                  RET                     ; return.
3655   0C39             
3656   0C39             ; ---------------------------------
3657   0C39             ; THE 'MESSAGE PRINTING' SUBROUTINE
3658   0C39             ; ---------------------------------
3659   0C39             ;   This entry point is used to print tape, boot-up, scroll? and error messages.
3660   0C39             ;   On entry the DE register points to an initial step-over byte or the 
3661   0C39             ;   inverted end-marker of the previous entry in the table.
3662   0C39             ;   Register A contains the message number, often zero to print first message.
3663   0C39             ;   (HL has nothing important usually P_FLAG)
3664   0C39             
3665   0C39             ;; PO-MSG
3666   0C39 E5          L0C0A:  PUSH    HL              ; put hi-byte zero on stack to suppress
3667   0C3A 26 00               LD      H,$00           ; trailing spaces
3668   0C3C E3                  EX      (SP),HL         ; ld h,0; push hl would have done ?.
3669   0C3D 18 04               JR      L0C14           ; forward to PO-TABLE.
3670   0C3F             
3671   0C3F             ; ---
3672   0C3F             
3673   0C3F             ;   This entry point prints the BASIC keywords, '<>' etc. from alt set
3674   0C3F             
3675   0C3F             ;; PO-TOKENS
3676   0C3F 11 95 00    L0C10:  LD      DE,L0095        ; address: TKN-TABLE
3677   0C42 F5                  PUSH    AF              ; save the token number to control
3678   0C43                                             ; trailing spaces - see later *
3679   0C43             
3680   0C43             ; ->
3681   0C43             
3682   0C43             ;; PO-TABLE
3683   0C43 CD 70 0C    L0C14:  CALL    L0C41           ; routine PO-SEARCH will set carry for
3684   0C46                                             ; all messages and function words.
3685   0C46             
3686   0C46 38 09               JR      C,L0C22         ; forward to PO-EACH if not a command, '<>' etc.
3687   0C48             
3688   0C48 3E 20               LD      A,$20           ; prepare leading space
3689   0C4A FD CB 01 46         BIT     0,(IY+$01)      ; test FLAGS  - leading space if not set
3690   0C4E             
3691   0C4E CC 6A 0C            CALL    Z,L0C3B         ; routine PO-SAVE to print a space without 
3692   0C51                                             ; disturbing registers.
3693   0C51             
3694   0C51             ;; PO-EACH
3695   0C51 1A          L0C22:  LD      A,(DE)          ; Fetch character from the table.
3696   0C52 E6 7F               AND     $7F             ; Cancel any inverted bit.
3697   0C54             
3698   0C54 CD 6A 0C            CALL    L0C3B           ; Routine PO-SAVE to print using the alternate
3699   0C57                                             ; set of registers.
3700   0C57             
3701   0C57 1A                  LD      A,(DE)          ; Re-fetch character from table.
3702   0C58 13                  INC     DE              ; Address next character in the table.
3703   0C59             
3704   0C59 87                  ADD     A,A             ; Was character inverted ?
3705   0C5A                                             ; (this also doubles character)
3706   0C5A 30 F5               JR      NC,L0C22        ; back to PO-EACH if not.
3707   0C5C             
3708   0C5C D1                  POP     DE              ; * re-fetch trailing space byte to D 
3709   0C5D             
3710   0C5D FE 48               CP      $48             ; was the last character '$' ?
3711   0C5F 28 03               JR      Z,L0C35         ; forward to PO-TR-SP to consider trailing
3712   0C61                                             ; space if so.
3713   0C61             
3714   0C61 FE 82               CP      $82             ; was it < 'A' i.e. '#','>','=' from tokens
3715   0C63                                             ; or ' ','.' (from tape) or '?' from scroll
3716   0C63             
3717   0C63 D8                  RET     C               ; Return if so as no trailing space required.
3718   0C64             
3719   0C64             ;; PO-TR-SP
3720   0C64 7A          L0C35:  LD      A,D             ; The trailing space flag (zero if an error msg)
3721   0C65             
3722   0C65 FE 03               CP      $03             ; Test against RND, INKEY$ and PI which have no
3723   0C67                                             ; parameters and therefore no trailing space.
3724   0C67             
3725   0C67 D8                  RET     C               ; Return if no trailing space.
3726   0C68             
3727   0C68 3E 20               LD      A,$20           ; Prepare the space character and continue to
3728   0C6A                                             ; print and make an indirect return.
3729   0C6A             
3730   0C6A             ; -----------------------------------
3731   0C6A             ; THE 'RECURSIVE PRINTING' SUBROUTINE
3732   0C6A             ; -----------------------------------
3733   0C6A             ;   This routine which is part of PRINT-OUT allows RST $10 to be used 
3734   0C6A             ;   recursively to print tokens and the spaces associated with them.
3735   0C6A             ;   It is called on three occasions when the value of DE must be preserved.
3736   0C6A             
3737   0C6A             ;; PO-SAVE
3738   0C6A D5          L0C3B:  PUSH    DE              ; Save DE value.
3739   0C6B D9                  EXX                     ; Switch in main set
3740   0C6C             
3741   0C6C D7                  RST     10H             ; PRINT-A prints using this alternate set.
3742   0C6D             
3743   0C6D D9                  EXX                     ; Switch back to this alternate set.
3744   0C6E D1                  POP     DE              ; Restore the initial DE value.
3745   0C6F             
3746   0C6F C9                  RET                     ; Return.
3747   0C70             
3748   0C70             ; ------------
3749   0C70             ; Table search
3750   0C70             ; ------------
3751   0C70             ; This subroutine searches a message or the token table for the
3752   0C70             ; message number held in A. DE holds the address of the table.
3753   0C70             
3754   0C70             ;; PO-SEARCH
3755   0C70 F5          L0C41:  PUSH    AF              ; save the message/token number
3756   0C71 EB                  EX      DE,HL           ; transfer DE to HL
3757   0C72 3C                  INC     A               ; adjust for initial step-over byte
3758   0C73             
3759   0C73             ;; PO-STEP
3760   0C73 CB 7E       L0C44:  BIT     7,(HL)          ; is character inverted ?
3761   0C75 23                  INC     HL              ; address next
3762   0C76 28 FB               JR      Z,L0C44         ; back to PO-STEP if not inverted.
3763   0C78             
3764   0C78 3D                  DEC     A               ; decrease counter
3765   0C79 20 F8               JR      NZ,L0C44        ; back to PO-STEP if not zero
3766   0C7B             
3767   0C7B EB                  EX      DE,HL           ; transfer address to DE
3768   0C7C F1                  POP     AF              ; restore message/token number
3769   0C7D FE 20               CP      $20             ; return with carry set
3770   0C7F D8                  RET     C               ; for all messages and function tokens
3771   0C80             
3772   0C80 1A                  LD      A,(DE)          ; test first character of token
3773   0C81 D6 41               SUB     $41             ; and return with carry set
3774   0C83 C9                  RET                     ; if it is less that 'A'
3775   0C84                                             ; i.e. '<>', '<=', '>='
3776   0C84             
3777   0C84             ; ---------------
3778   0C84             ; Test for scroll
3779   0C84             ; ---------------
3780   0C84             ; This test routine is called when printing carriage return, when considering
3781   0C84             ; PRINT AT and from the general PRINT ALL characters routine to test if
3782   0C84             ; scrolling is required, prompting the user if necessary.
3783   0C84             ; This is therefore using the alternate set.
3784   0C84             ; The B register holds the current line.
3785   0C84             
3786   0C84             ;; PO-SCR
3787   0C84 FD CB 01 4E L0C55:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
3788   0C88 C0                  RET     NZ              ; return immediately if so.
3789   0C89             
3790   0C89 11 08 0E            LD      DE,L0DD9        ; set DE to address: CL-SET
3791   0C8C D5                  PUSH    DE              ; and push for return address.
3792   0C8D             
3793   0C8D 78                  LD      A,B             ; transfer the line to A.
3794   0C8E FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG - lower screen in use ?
3795   0C92 C2 31 0D            JP      NZ,L0D02        ; jump forward to PO-SCR-4 if so.
3796   0C95             
3797   0C95 FD BE 31            CP      (IY+$31)        ; greater than DF_SZ display file size ?
3798   0C98 38 1B               JR      C,L0C86         ; forward to REPORT-5 if less.
3799   0C9A                                             ; 'Out of screen'
3800   0C9A             
3801   0C9A C0                  RET     NZ              ; return (via CL-SET) if greater
3802   0C9B             
3803   0C9B FD CB 02 66         BIT     4,(IY+$02)      ; test TV_FLAG  - Automatic listing ?
3804   0C9F 28 16               JR      Z,L0C88         ; forward to PO-SCR-2 if not.
3805   0CA1             
3806   0CA1 FD 5E 2D            LD      E,(IY+$2D)      ; fetch BREG - the count of scroll lines to E.
3807   0CA4 1D                  DEC     E               ; decrease and jump
3808   0CA5 28 5A               JR      Z,L0CD2         ; to PO-SCR-3 if zero and scrolling required.
3809   0CA7             
3810   0CA7 3E 00               LD      A,$00           ; explicit - select channel zero.
3811   0CA9 CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it.
3812   0CAC             
3813   0CAC ED 7B 3F 5C         LD      SP,($5C3F)      ; set stack pointer to LIST_SP
3814   0CB0             
3815   0CB0 FD CB 02 A6         RES     4,(IY+$02)      ; reset TV_FLAG  - signal auto listing finished.
3816   0CB4 C9                  RET                     ; return ignoring pushed value, CL-SET
3817   0CB5                                             ; to MAIN or EDITOR without updating
3818   0CB5                                             ; print position                         >>
3819   0CB5             
3820   0CB5             ; ---
3821   0CB5             
3822   0CB5             
3823   0CB5             ;; REPORT-5
3824   0CB5 CF          L0C86:  RST     08H             ; ERROR-1
3825   0CB6 04                  DEFB    $04             ; Error Report: Out of screen
3826   0CB7             
3827   0CB7             ; continue here if not an automatic listing.
3828   0CB7             
3829   0CB7             ;; PO-SCR-2
3830   0CB7 FD 35 52    L0C88:  DEC     (IY+$52)        ; decrease SCR_CT
3831   0CBA 20 45               JR      NZ,L0CD2        ; forward to PO-SCR-3 to scroll display if
3832   0CBC                                             ; result not zero.
3833   0CBC             
3834   0CBC             ; now produce prompt.
3835   0CBC             
3836   0CBC 3E 18               LD      A,$18           ; reset
3837   0CBE 90                  SUB     B               ; the
3838   0CBF 32 8C 5C            LD      ($5C8C),A       ; SCR_CT scroll count
3839   0CC2 2A 8F 5C            LD      HL,($5C8F)      ; L=ATTR_T, H=MASK_T
3840   0CC5 E5                  PUSH    HL              ; save on stack
3841   0CC6 3A 91 5C            LD      A,($5C91)       ; P_FLAG
3842   0CC9 F5                  PUSH    AF              ; save on stack to prevent lower screen
3843   0CCA                                             ; attributes (BORDCR etc.) being applied.
3844   0CCA 3E FD               LD      A,$FD           ; select system channel 'K'
3845   0CCC CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it
3846   0CCF AF                  XOR     A               ; clear to address message directly
3847   0CD0 11 27 0D            LD      DE,L0CF8        ; make DE address: scrl-mssg
3848   0CD3 CD 39 0C            CALL    L0C0A           ; routine PO-MSG prints to lower screen
3849   0CD6 FD CB 02 EE         SET     5,(IY+$02)      ; set TV_FLAG  - signal lower screen requires
3850   0CDA                                             ; clearing
3851   0CDA 21 3B 5C            LD      HL,$5C3B        ; make HL address FLAGS
3852   0CDD CB DE               SET     3,(HL)          ; signal 'L' mode.
3853   0CDF CB AE               RES     5,(HL)          ; signal 'no new key'.
3854   0CE1 D9                  EXX                     ; switch to main set.
3855   0CE2                                             ; as calling chr input from alternative set.
3856   0CE2 CD 03 16            CALL    L15D4           ; routine WAIT-KEY waits for new key
3857   0CE5                                             ; Note. this is the right routine but the
3858   0CE5                                             ; stream in use is unsatisfactory. From the
3859   0CE5                                             ; choices available, it is however the best.
3860   0CE5             
3861   0CE5 D9                  EXX                     ; switch back to alternate set.
3862   0CE6 FE 20               CP      $20             ; space is considered as BREAK
3863   0CE8 28 45               JR      Z,L0D00         ; forward to REPORT-D if so
3864   0CEA                                             ; 'BREAK - CONT repeats'
3865   0CEA             
3866   0CEA FE E2               CP      $E2             ; is character 'STOP' ?
3867   0CEC 28 41               JR      Z,L0D00         ; forward to REPORT-D if so
3868   0CEE             
3869   0CEE F6 20               OR      $20             ; convert to lower-case
3870   0CF0 FE 6E               CP      $6E             ; is character 'n' ?
3871   0CF2 28 3B               JR      Z,L0D00         ; forward to REPORT-D if so else scroll.
3872   0CF4             
3873   0CF4 3E FE               LD      A,$FE           ; select system channel 'S'
3874   0CF6 CD 30 16            CALL    L1601           ; routine CHAN-OPEN
3875   0CF9 F1                  POP     AF              ; restore original P_FLAG
3876   0CFA 32 91 5C            LD      ($5C91),A       ; and save in P_FLAG.
3877   0CFD E1                  POP     HL              ; restore original ATTR_T, MASK_T
3878   0CFE 22 8F 5C            LD      ($5C8F),HL      ; and reset ATTR_T, MASK-T as 'scroll?' has
3879   0D01                                             ; been printed.
3880   0D01             
3881   0D01             ;; PO-SCR-3
3882   0D01 CD 2D 0E    L0CD2:  CALL    L0DFE           ; routine CL-SC-ALL to scroll whole display
3883   0D04 FD 46 31            LD      B,(IY+$31)      ; fetch DF_SZ to B
3884   0D07 04                  INC     B               ; increase to address last line of display
3885   0D08 0E 21               LD      C,$21           ; set C to $21 (was $21 from above routine)
3886   0D0A C5                  PUSH    BC              ; save the line and column in BC.
3887   0D0B             
3888   0D0B CD CA 0E            CALL    L0E9B           ; routine CL-ADDR finds display address.
3889   0D0E             
3890   0D0E 7C                  LD      A,H             ; now find the corresponding attribute byte
3891   0D0F 0F                  RRCA                    ; (this code sequence is used twice
3892   0D10 0F                  RRCA                    ; elsewhere and is a candidate for
3893   0D11 0F                  RRCA                    ; a subroutine.)
3894   0D12 E6 03               AND     $03             ;
3895   0D14 F6 58               OR      $58             ;
3896   0D16 67                  LD      H,A             ;
3897   0D17             
3898   0D17 11 E0 5A            LD      DE,$5AE0        ; start of last 'line' of attribute area
3899   0D1A 1A                  LD      A,(DE)          ; get attribute for last line
3900   0D1B 4E                  LD      C,(HL)          ; transfer to base line of upper part
3901   0D1C 06 20               LD      B,$20           ; there are thirty two bytes
3902   0D1E EB                  EX      DE,HL           ; swap the pointers.
3903   0D1F             
3904   0D1F             ;; PO-SCR-3A
3905   0D1F 12          L0CF0:  LD      (DE),A          ; transfer
3906   0D20 71                  LD      (HL),C          ; attributes.
3907   0D21 13                  INC     DE              ; address next.
3908   0D22 23                  INC     HL              ; address next.
3909   0D23 10 FA               DJNZ    L0CF0           ; loop back to PO-SCR-3A for all adjacent
3910   0D25                                             ; attribute lines.
3911   0D25             
3912   0D25 C1                  POP     BC              ; restore the line/column.
3913   0D26 C9                  RET                     ; return via CL-SET (was pushed on stack).
3914   0D27             
3915   0D27             ; ---
3916   0D27             
3917   0D27             ; The message 'scroll?' appears here with last byte inverted.
3918   0D27             
3919   0D27             ;; scrl-mssg
3920   0D27 80          L0CF8:  DEFB    $80             ; initial step-over byte.
3921   0D28 73 63 72 6F         DEFM    "scroll"
3921   0D2C 6C 6C 
3922   0D2E BF                  DEFB    '?'+$80
3923   0D2F             
3924   0D2F             ;; REPORT-D
3925   0D2F CF          L0D00:  RST     08H             ; ERROR-1
3926   0D30 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
3927   0D31             
3928   0D31             ; continue here if using lower display - A holds line number.
3929   0D31             
3930   0D31             ;; PO-SCR-4
3931   0D31 FE 02       L0D02:  CP      $02             ; is line number less than 2 ?
3932   0D33 38 80               JR      C,L0C86         ; to REPORT-5 if so
3933   0D35                                             ; 'Out of Screen'.
3934   0D35             
3935   0D35 FD 86 31            ADD     A,(IY+$31)      ; add DF_SZ
3936   0D38 D6 19               SUB     $19             ;
3937   0D3A D0                  RET     NC              ; return if scrolling unnecessary
3938   0D3B             
3939   0D3B ED 44               NEG                     ; Negate to give number of scrolls required.
3940   0D3D C5                  PUSH    BC              ; save line/column
3941   0D3E 47                  LD      B,A             ; count to B
3942   0D3F 2A 8F 5C            LD      HL,($5C8F)      ; fetch current ATTR_T, MASK_T to HL.
3943   0D42 E5                  PUSH    HL              ; and save
3944   0D43 2A 91 5C            LD      HL,($5C91)      ; fetch P_FLAG
3945   0D46 E5                  PUSH    HL              ; and save.
3946   0D47                                             ; to prevent corruption by input AT
3947   0D47             
3948   0D47 CD 7C 0D            CALL    L0D4D           ; routine TEMPS sets to BORDCR etc
3949   0D4A 78                  LD      A,B             ; transfer scroll number to A.
3950   0D4B             
3951   0D4B             ;; PO-SCR-4A
3952   0D4B F5          L0D1C:  PUSH    AF              ; save scroll number.
3953   0D4C 21 6B 5C            LD      HL,$5C6B        ; address DF_SZ
3954   0D4F 46                  LD      B,(HL)          ; fetch old value
3955   0D50 78                  LD      A,B             ; transfer to A
3956   0D51 3C                  INC     A               ; and increment
3957   0D52 77                  LD      (HL),A          ; then put back.
3958   0D53 21 89 5C            LD      HL,$5C89        ; address S_POSN_hi - line
3959   0D56 BE                  CP      (HL)            ; compare
3960   0D57 38 03               JR      C,L0D2D         ; forward to PO-SCR-4B if scrolling required
3961   0D59             
3962   0D59 34                  INC     (HL)            ; else increment S_POSN_hi
3963   0D5A 06 18               LD      B,$18           ; set count to whole display ??
3964   0D5C                                             ; Note. should be $17 and the top line will be 
3965   0D5C                                             ; scrolled into the ROM which is harmless on 
3966   0D5C                                             ; the standard set up.
3967   0D5C                                             ; credit P.Giblin 1984.
3968   0D5C             
3969   0D5C             ;; PO-SCR-4B
3970   0D5C CD 2F 0E    L0D2D:  CALL    L0E00           ; routine CL-SCROLL scrolls B lines
3971   0D5F F1                  POP     AF              ; restore scroll counter.
3972   0D60 3D                  DEC     A               ; decrease
3973   0D61 20 E8               JR      NZ,L0D1C        ; back to PO-SCR-4A until done
3974   0D63             
3975   0D63 E1                  POP     HL              ; restore original P_FLAG.
3976   0D64 FD 75 57            LD      (IY+$57),L      ; and overwrite system variable P_FLAG.
3977   0D67             
3978   0D67 E1                  POP     HL              ; restore original ATTR_T/MASK_T.
3979   0D68 22 8F 5C            LD      ($5C8F),HL      ; and update system variables.
3980   0D6B             
3981   0D6B ED 4B 88 5C         LD      BC,($5C88)      ; fetch S_POSN to BC.
3982   0D6F FD CB 02 86         RES     0,(IY+$02)      ; signal to TV_FLAG  - main screen in use.
3983   0D73 CD 08 0E            CALL    L0DD9           ; call routine CL-SET for upper display.
3984   0D76             
3985   0D76 FD CB 02 C6         SET     0,(IY+$02)      ; signal to TV_FLAG  - lower screen in use.
3986   0D7A C1                  POP     BC              ; restore line/column
3987   0D7B C9                  RET                     ; return via CL-SET for lower display.
3988   0D7C             
3989   0D7C             ; ----------------------
3990   0D7C             ; Temporary colour items
3991   0D7C             ; ----------------------
3992   0D7C             ; This subroutine is called 11 times to copy the permanent colour items
3993   0D7C             ; to the temporary ones.
3994   0D7C             
3995   0D7C             ;; TEMPS
3996   0D7C AF          L0D4D:  XOR     A               ; clear the accumulator
3997   0D7D 2A 8D 5C            LD      HL,($5C8D)      ; fetch L=ATTR_P and H=MASK_P
3998   0D80 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - is lower screen in use ?
3999   0D84 28 04               JR      Z,L0D5B         ; skip to TEMPS-1 if not
4000   0D86             
4001   0D86 67                  LD      H,A             ; set H, MASK P, to 00000000.
4002   0D87 FD 6E 0E            LD      L,(IY+$0E)      ; fetch BORDCR to L which is used for lower
4003   0D8A                                             ; screen.
4004   0D8A             
4005   0D8A             ;; TEMPS-1
4006   0D8A 22 8F 5C    L0D5B:  LD      ($5C8F),HL      ; transfer values to ATTR_T and MASK_T
4007   0D8D             
4008   0D8D             ; for the print flag the permanent values are odd bits, temporary even bits.
4009   0D8D             
4010   0D8D 21 91 5C            LD      HL,$5C91        ; address P_FLAG.
4011   0D90 20 02               JR      NZ,L0D65        ; skip to TEMPS-2 if lower screen using A=0.
4012   0D92             
4013   0D92 7E                  LD      A,(HL)          ; else pick up flag bits.
4014   0D93 0F                  RRCA                    ; rotate permanent bits to temporary bits.
4015   0D94             
4016   0D94             ;; TEMPS-2
4017   0D94 AE          L0D65:  XOR     (HL)            ;
4018   0D95 E6 55               AND     $55             ; BIN 01010101
4019   0D97 AE                  XOR     (HL)            ; permanent now as original
4020   0D98 77                  LD      (HL),A          ; apply permanent bits to temporary bits.
4021   0D99 C9                  RET                     ; and return.
4022   0D9A             
4023   0D9A             ; -----------------
4024   0D9A             ; THE 'CLS' COMMAND 
4025   0D9A             ; -----------------
4026   0D9A             ;    This command clears the display.
4027   0D9A             ;    The routine is also called during initialization and by the CLEAR command.
4028   0D9A             ;    If it's difficult to write it should be difficult to read.
4029   0D9A             
4030   0D9A             ;; CLS
4031   0D9A CD DE 0D    L0D6B:  CALL    L0DAF           ; Routine CL-ALL clears the entire display and
4032   0D9D                                             ; sets the attributes to the permanent ones
4033   0D9D                                             ; from ATTR-P.
4034   0D9D             
4035   0D9D             ;   Having cleared all 24 lines of the display area, continue into the 
4036   0D9D             ;   subroutine that clears the lower display area.  Note that at the moment 
4037   0D9D             ;   the attributes for the lower lines are the same as upper ones and have 
4038   0D9D             ;   to be changed to match the BORDER colour.
4039   0D9D             
4040   0D9D             ; --------------------------
4041   0D9D             ; THE 'CLS-LOWER' SUBROUTINE 
4042   0D9D             ; --------------------------
4043   0D9D             ;   This routine is called from INPUT, and from the MAIN execution loop.
4044   0D9D             ;   This is very much a housekeeping routine which clears between 2 and 23
4045   0D9D             ;   lines of the display, setting attributes and correcting situations where
4046   0D9D             ;   errors have occurred while the normal input and output routines have been
4047   0D9D             ;   temporarily diverted to deal with, say colour control codes. 
4048   0D9D             
4049   0D9D             ;; CLS-LOWER
4050   0D9D 21 3C 5C    L0D6E:  LD      HL,$5C3C        ; address System Variable TV_FLAG.
4051   0DA0 CB AE               RES     5,(HL)          ; TV_FLAG - signal do not clear lower screen.
4052   0DA2 CB C6               SET     0,(HL)          ; TV_FLAG - signal lower screen in use.
4053   0DA4             
4054   0DA4 CD 7C 0D            CALL    L0D4D           ; routine TEMPS applies permanent attributes,
4055   0DA7                                             ; in this case BORDCR to ATTR_T.
4056   0DA7                                             ; Note. this seems unnecessary and is repeated 
4057   0DA7                                             ; within CL-LINE.
4058   0DA7             
4059   0DA7 FD 46 31            LD      B,(IY+$31)      ; fetch lower screen display file size DF_SZ
4060   0DAA             
4061   0DAA CD 73 0E            CALL    L0E44           ; routine CL-LINE clears lines to bottom of the
4062   0DAD                                             ; display and sets attributes from BORDCR while
4063   0DAD                                             ; preserving the B register.
4064   0DAD             
4065   0DAD 21 C0 5A            LD      HL,$5AC0        ; set initial attribute address to the leftmost 
4066   0DB0                                             ; cell of second line up.
4067   0DB0             
4068   0DB0 3A 8D 5C            LD      A,($5C8D)       ; fetch permanent attribute from ATTR_P.
4069   0DB3             
4070   0DB3 05                  DEC     B               ; decrement lower screen display file size.
4071   0DB4             
4072   0DB4 18 07               JR      L0D8E           ; forward to enter the backfill loop at CLS-3 
4073   0DB6                                             ; where B is decremented again.
4074   0DB6             
4075   0DB6             ; ---
4076   0DB6             
4077   0DB6             ;   The backfill loop is entered at midpoint and ensures, if more than 2
4078   0DB6             ;   lines have been cleared, that any other lines take the permanent screen
4079   0DB6             ;   attributes.
4080   0DB6             
4081   0DB6             ;; CLS-1
4082   0DB6 0E 20       L0D87:  LD      C,$20           ; set counter to 32 character cells per line
4083   0DB8             
4084   0DB8             ;; CLS-2
4085   0DB8 2B          L0D89:  DEC     HL              ; decrease attribute address.
4086   0DB9 77                  LD      (HL),A          ; and place attributes in next line up.
4087   0DBA 0D                  DEC     C               ; decrease the 32 counter.
4088   0DBB 20 FB               JR      NZ,L0D89        ; loop back to CLS-2 until all 32 cells done.
4089   0DBD             
4090   0DBD             ;; CLS-3
4091   0DBD 10 F7       L0D8E:  DJNZ    L0D87           ; decrease B counter and back to CLS-1
4092   0DBF                                             ; if not zero.
4093   0DBF             
4094   0DBF FD 36 31 02         LD      (IY+$31),$02    ; now set DF_SZ lower screen to 2
4095   0DC3             
4096   0DC3             ; This entry point is also called from CL-ALL below to
4097   0DC3             ; reset the system channel input and output addresses to normal.
4098   0DC3             
4099   0DC3             ;; CL-CHAN
4100   0DC3 3E FD       L0D94:  LD      A,$FD           ; select system channel 'K'
4101   0DC5             
4102   0DC5 CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it.
4103   0DC8             
4104   0DC8 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL to HL to address current channel
4105   0DCB 11 23 0A            LD      DE,L09F4        ; set address to PRINT-OUT for first pass.
4106   0DCE A7                  AND     A               ; clear carry for first pass.
4107   0DCF             
4108   0DCF             ;; CL-CHAN-A
4109   0DCF 73          L0DA0:  LD      (HL),E          ; Insert the output address on the first pass 
4110   0DD0 23                  INC     HL              ; or the input address on the second pass.
4111   0DD1 72                  LD      (HL),D          ;
4112   0DD2 23                  INC     HL              ;
4113   0DD3             
4114   0DD3 11 D7 10            LD      DE,L10A8        ; fetch address KEY-INPUT for second pass
4115   0DD6 3F                  CCF                     ; complement carry flag - will set on pass 1.
4116   0DD7             
4117   0DD7 38 F6               JR      C,L0DA0         ; back to CL-CHAN-A if first pass else done.
4118   0DD9             
4119   0DD9 01 21 17            LD      BC,$1721        ; line 23 for lower screen
4120   0DDC 18 2A               JR      L0DD9           ; exit via CL-SET to set column
4121   0DDE                                             ; for lower display
4122   0DDE             
4123   0DDE             ; ---------------------------
4124   0DDE             ; Clearing whole display area
4125   0DDE             ; ---------------------------
4126   0DDE             ; This subroutine called from CLS, AUTO-LIST and MAIN-3
4127   0DDE             ; clears 24 lines of the display and resets the relevant system variables.
4128   0DDE             ; This routine also recovers from an error situation where, for instance, an 
4129   0DDE             ; invalid colour or position control code has left the output routine addressing
4130   0DDE             ; PO-TV-2 or PO-CONT.
4131   0DDE             
4132   0DDE             ;; CL-ALL
4133   0DDE 21 00 00    L0DAF:  LD      HL,$0000        ; Initialize plot coordinates.
4134   0DE1 22 7D 5C            LD      ($5C7D),HL      ; Set system variable COORDS to 0,0.
4135   0DE4             
4136   0DE4 FD CB 30 86         RES     0,(IY+$30)      ; update FLAGS2  - signal main screen is clear.
4137   0DE8             
4138   0DE8 CD C3 0D            CALL    L0D94           ; routine CL-CHAN makes channel 'K' 'normal'.
4139   0DEB             
4140   0DEB 3E FE               LD      A,$FE           ; select system channel 'S'
4141   0DED CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it.
4142   0DF0             
4143   0DF0 CD 7C 0D            CALL    L0D4D           ; routine TEMPS applies permanent attributes,
4144   0DF3                                             ; in this case ATTR_P, to ATTR_T. 
4145   0DF3                                             ; Note. this seems unnecessary.
4146   0DF3             
4147   0DF3 06 18               LD      B,$18           ; There are 24 lines.
4148   0DF5             
4149   0DF5 CD 73 0E            CALL    L0E44           ; routine CL-LINE clears 24 text lines and sets
4150   0DF8                                             ; attributes from ATTR-P.
4151   0DF8                                             ; This routine preserves B and sets C to $21.
4152   0DF8             
4153   0DF8 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL make HL address output routine.
4154   0DFB             
4155   0DFB 11 23 0A            LD      DE,L09F4        ; address: PRINT-OUT
4156   0DFE 73                  LD      (HL),E          ; is made
4157   0DFF 23                  INC     HL              ; the normal
4158   0E00 72                  LD      (HL),D          ; output address.
4159   0E01             
4160   0E01 FD 36 52 01         LD      (IY+$52),$01    ; set SCR_CT - scroll count - to default.
4161   0E05             
4162   0E05             ;   Note. BC already contains $1821.
4163   0E05             
4164   0E05 01 21 18            LD      BC,$1821        ; reset column and line to 0,0
4165   0E08                                             ; and continue into CL-SET, below, exiting
4166   0E08                                             ; via PO-STORE (for the upper screen).
4167   0E08             
4168   0E08             ; --------------------
4169   0E08             ; THE 'CL-SET' ROUTINE
4170   0E08             ; --------------------
4171   0E08             ; This important subroutine is used to calculate the character output
4172   0E08             ; address for screens or printer based on the line/column for screens
4173   0E08             ; or the column for printer.
4174   0E08             
4175   0E08             ;; CL-SET
4176   0E08 21 00 5B    L0DD9:  LD      HL,$5B00        ; the base address of printer buffer
4177   0E0B FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
4178   0E0F 20 12               JR      NZ,L0DF4        ; forward to CL-SET-2 if so.
4179   0E11             
4180   0E11 78                  LD      A,B             ; transfer line to A.
4181   0E12 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
4182   0E16 28 05               JR      Z,L0DEE         ; skip to CL-SET-1 if handling upper part
4183   0E18             
4184   0E18 FD 86 31            ADD     A,(IY+$31)      ; add DF_SZ for lower screen
4185   0E1B D6 18               SUB     $18             ; and adjust.
4186   0E1D             
4187   0E1D             ;; CL-SET-1
4188   0E1D C5          L0DEE:  PUSH    BC              ; save the line/column.
4189   0E1E 47                  LD      B,A             ; transfer line to B
4190   0E1F                                             ; (adjusted if lower screen)
4191   0E1F             
4192   0E1F CD CA 0E            CALL    L0E9B           ; routine CL-ADDR calculates address at left
4193   0E22                                             ; of screen.
4194   0E22 C1                  POP     BC              ; restore the line/column.
4195   0E23             
4196   0E23             ;; CL-SET-2
4197   0E23 3E 21       L0DF4:  LD      A,$21           ; the column $01-$21 is reversed
4198   0E25 91                  SUB     C               ; to range $00 - $20
4199   0E26 5F                  LD      E,A             ; now transfer to DE
4200   0E27 16 00               LD      D,$00           ; prepare for addition
4201   0E29 19                  ADD     HL,DE           ; and add to base address
4202   0E2A             
4203   0E2A C3 0B 0B            JP      L0ADC           ; exit via PO-STORE to update the relevant
4204   0E2D                                             ; system variables.
4205   0E2D             ; ----------------
4206   0E2D             ; Handle scrolling
4207   0E2D             ; ----------------
4208   0E2D             ; The routine CL-SC-ALL is called once from PO to scroll all the display
4209   0E2D             ; and from the routine CL-SCROLL, once, to scroll part of the display.
4210   0E2D             
4211   0E2D             ;; CL-SC-ALL
4212   0E2D 06 17       L0DFE:  LD      B,$17           ; scroll 23 lines, after 'scroll?'.
4213   0E2F             
4214   0E2F             ;; CL-SCROLL
4215   0E2F CD CA 0E    L0E00:  CALL    L0E9B           ; routine CL-ADDR gets screen address in HL.
4216   0E32 0E 08               LD      C,$08           ; there are 8 pixel lines to scroll.
4217   0E34             
4218   0E34             ;; CL-SCR-1
4219   0E34 C5          L0E05:  PUSH    BC              ; save counters.
4220   0E35 E5                  PUSH    HL              ; and initial address.
4221   0E36 78                  LD      A,B             ; get line count.
4222   0E37 E6 07               AND     $07             ; will set zero if all third to be scrolled.
4223   0E39 78                  LD      A,B             ; re-fetch the line count.
4224   0E3A 20 0C               JR      NZ,L0E19        ; forward to CL-SCR-3 if partial scroll.
4225   0E3C             
4226   0E3C             ; HL points to top line of third and must be copied to bottom of previous 3rd.
4227   0E3C             ; ( so HL = $4800 or $5000 ) ( but also sometimes $4000 )
4228   0E3C             
4229   0E3C             ;; CL-SCR-2
4230   0E3C EB          L0E0D:  EX      DE,HL           ; copy HL to DE.
4231   0E3D 21 E0 F8            LD      HL,$F8E0        ; subtract $08 from H and add $E0 to L -
4232   0E40 19                  ADD     HL,DE           ; to make destination bottom line of previous
4233   0E41                                             ; third.
4234   0E41 EB                  EX      DE,HL           ; restore the source and destination.
4235   0E42 01 20 00            LD      BC,$0020        ; thirty-two bytes are to be copied.
4236   0E45 3D                  DEC     A               ; decrement the line count.
4237   0E46 ED B0               LDIR                    ; copy a pixel line to previous third.
4238   0E48             
4239   0E48             ;; CL-SCR-3
4240   0E48 EB          L0E19:  EX      DE,HL           ; save source in DE.
4241   0E49 21 E0 FF            LD      HL,$FFE0        ; load the value -32.
4242   0E4C 19                  ADD     HL,DE           ; add to form destination in HL.
4243   0E4D EB                  EX      DE,HL           ; switch source and destination
4244   0E4E 47                  LD      B,A             ; save the count in B.
4245   0E4F E6 07               AND     $07             ; mask to find count applicable to current
4246   0E51 0F                  RRCA                    ; third and
4247   0E52 0F                  RRCA                    ; multiply by
4248   0E53 0F                  RRCA                    ; thirty two (same as 5 RLCAs)
4249   0E54             
4250   0E54 4F                  LD      C,A             ; transfer byte count to C ($E0 at most)
4251   0E55 78                  LD      A,B             ; store line count to A
4252   0E56 06 00               LD      B,$00           ; make B zero
4253   0E58 ED B0               LDIR                    ; copy bytes (BC=0, H incremented, L=0)
4254   0E5A 06 07               LD      B,$07           ; set B to 7, C is zero.
4255   0E5C 09                  ADD     HL,BC           ; add 7 to H to address next third.
4256   0E5D E6 F8               AND     $F8             ; has last third been done ?
4257   0E5F 20 DB               JR      NZ,L0E0D        ; back to CL-SCR-2 if not.
4258   0E61             
4259   0E61 E1                  POP     HL              ; restore topmost address.
4260   0E62 24                  INC     H               ; next pixel line down.
4261   0E63 C1                  POP     BC              ; restore counts.
4262   0E64 0D                  DEC     C               ; reduce pixel line count.
4263   0E65 20 CD               JR      NZ,L0E05        ; back to CL-SCR-1 if all eight not done.
4264   0E67             
4265   0E67 CD B7 0E            CALL    L0E88           ; routine CL-ATTR gets address in attributes
4266   0E6A                                             ; from current 'ninth line', count in BC.
4267   0E6A             
4268   0E6A 21 E0 FF            LD      HL,$FFE0        ; set HL to the 16-bit value -32.
4269   0E6D 19                  ADD     HL,DE           ; and add to form destination address.
4270   0E6E EB                  EX      DE,HL           ; swap source and destination addresses.
4271   0E6F ED B0               LDIR                    ; copy bytes scrolling the linear attributes.
4272   0E71 06 01               LD      B,$01           ; continue to clear the bottom line.
4273   0E73             
4274   0E73             ; ------------------------------
4275   0E73             ; THE 'CLEAR TEXT LINES' ROUTINE
4276   0E73             ; ------------------------------
4277   0E73             ; This subroutine, called from CL-ALL, CLS-LOWER and AUTO-LIST and above,
4278   0E73             ; clears text lines at bottom of display.
4279   0E73             ; The B register holds on entry the number of lines to be cleared 1-24.
4280   0E73             
4281   0E73             ;; CL-LINE
4282   0E73 C5          L0E44:  PUSH    BC              ; save line count
4283   0E74 CD CA 0E            CALL    L0E9B           ; routine CL-ADDR gets top address
4284   0E77 0E 08               LD      C,$08           ; there are eight screen lines to a text line.
4285   0E79             
4286   0E79             ;; CL-LINE-1
4287   0E79 C5          L0E4A:  PUSH    BC              ; save pixel line count
4288   0E7A E5                  PUSH    HL              ; and save the address
4289   0E7B 78                  LD      A,B             ; transfer the line to A (1-24).
4290   0E7C             
4291   0E7C             ;; CL-LINE-2
4292   0E7C E6 07       L0E4D:  AND     $07             ; mask 0-7 to consider thirds at a time
4293   0E7E 0F                  RRCA                    ; multiply
4294   0E7F 0F                  RRCA                    ; by 32  (same as five RLCA instructions)
4295   0E80 0F                  RRCA                    ; now 32 - 256(0)
4296   0E81 4F                  LD      C,A             ; store result in C
4297   0E82 78                  LD      A,B             ; save line in A (1-24)
4298   0E83 06 00               LD      B,$00           ; set high byte to 0, prepare for ldir.
4299   0E85 0D                  DEC     C               ; decrement count 31-255.
4300   0E86 54                  LD      D,H             ; copy HL
4301   0E87 5D                  LD      E,L             ; to DE.
4302   0E88 36 00               LD      (HL),$00        ; blank the first byte.
4303   0E8A 13                  INC     DE              ; make DE point to next byte.
4304   0E8B ED B0               LDIR                    ; ldir will clear lines.
4305   0E8D 11 01 07            LD      DE,$0701        ; now address next third adjusting
4306   0E90 19                  ADD     HL,DE           ; register E to address left hand side
4307   0E91 3D                  DEC     A               ; decrease the line count.
4308   0E92 E6 F8               AND     $F8             ; will be 16, 8 or 0  (AND $18 will do).
4309   0E94 47                  LD      B,A             ; transfer count to B.
4310   0E95 20 E5               JR      NZ,L0E4D        ; back to CL-LINE-2 if 16 or 8 to do
4311   0E97                                             ; the next third.
4312   0E97             
4313   0E97 E1                  POP     HL              ; restore start address.
4314   0E98 24                  INC     H               ; address next line down.
4315   0E99 C1                  POP     BC              ; fetch counts.
4316   0E9A 0D                  DEC     C               ; decrement pixel line count
4317   0E9B 20 DC               JR      NZ,L0E4A        ; back to CL-LINE-1 till all done.
4318   0E9D             
4319   0E9D CD B7 0E            CALL    L0E88           ; routine CL-ATTR gets attribute address
4320   0EA0                                             ; in DE and B * 32 in BC.
4321   0EA0             
4322   0EA0 62                  LD      H,D             ; transfer the address
4323   0EA1 6B                  LD      L,E             ; to HL.
4324   0EA2             
4325   0EA2 13                  INC     DE              ; make DE point to next location.
4326   0EA3             
4327   0EA3 3A 8D 5C            LD      A,($5C8D)       ; fetch ATTR_P - permanent attributes
4328   0EA6 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
4329   0EAA 28 03               JR      Z,L0E80         ; skip to CL-LINE-3 if not.
4330   0EAC             
4331   0EAC 3A 48 5C            LD      A,($5C48)       ; else lower screen uses BORDCR as attribute.
4332   0EAF             
4333   0EAF             ;; CL-LINE-3
4334   0EAF 77          L0E80:  LD      (HL),A          ; put attribute in first byte.
4335   0EB0 0B                  DEC     BC              ; decrement the counter.
4336   0EB1 ED B0               LDIR                    ; copy bytes to set all attributes.
4337   0EB3 C1                  POP     BC              ; restore the line $01-$24.
4338   0EB4 0E 21               LD      C,$21           ; make column $21. (No use is made of this)
4339   0EB6 C9                  RET                     ; return to the calling routine.
4340   0EB7             
4341   0EB7             ; ------------------
4342   0EB7             ; Attribute handling
4343   0EB7             ; ------------------
4344   0EB7             ; This subroutine is called from CL-LINE or CL-SCROLL with the HL register
4345   0EB7             ; pointing to the 'ninth' line and H needs to be decremented before or after
4346   0EB7             ; the division. Had it been done first then either present code or that used
4347   0EB7             ; at the start of PO-ATTR could have been used.
4348   0EB7             ; The Spectrum screen arrangement leads to the L register already holding 
4349   0EB7             ; the correct value for the attribute file and it is only necessary
4350   0EB7             ; to manipulate H to form the correct colour attribute address.
4351   0EB7             
4352   0EB7             ;; CL-ATTR
4353   0EB7 7C          L0E88:  LD      A,H             ; fetch H to A - $48, $50, or $58.
4354   0EB8 0F                  RRCA                    ; divide by
4355   0EB9 0F                  RRCA                    ; eight.
4356   0EBA 0F                  RRCA                    ; $09, $0A or $0B.
4357   0EBB 3D                  DEC     A               ; $08, $09 or $0A.
4358   0EBC F6 50               OR      $50             ; $58, $59 or $5A.
4359   0EBE 67                  LD      H,A             ; save high byte of attributes.
4360   0EBF             
4361   0EBF EB                  EX      DE,HL           ; transfer attribute address to DE
4362   0EC0 61                  LD      H,C             ; set H to zero - from last LDIR.
4363   0EC1 68                  LD      L,B             ; load L with the line from B.
4364   0EC2 29                  ADD     HL,HL           ; multiply
4365   0EC3 29                  ADD     HL,HL           ; by
4366   0EC4 29                  ADD     HL,HL           ; thirty two
4367   0EC5 29                  ADD     HL,HL           ; to give count of attribute
4368   0EC6 29                  ADD     HL,HL           ; cells to the end of display.
4369   0EC7             
4370   0EC7 44                  LD      B,H             ; transfer the result
4371   0EC8 4D                  LD      C,L             ; to register BC.
4372   0EC9             
4373   0EC9 C9                  RET                     ; return.
4374   0ECA             
4375   0ECA             ; -------------------------------
4376   0ECA             ; Handle display with line number
4377   0ECA             ; -------------------------------
4378   0ECA             ; This subroutine is called from four places to calculate the address
4379   0ECA             ; of the start of a screen character line which is supplied in B.
4380   0ECA             
4381   0ECA             ;; CL-ADDR
4382   0ECA 3E 18       L0E9B:  LD      A,$18           ; reverse the line number
4383   0ECC 90                  SUB     B               ; to range $00 - $17.
4384   0ECD 57                  LD      D,A             ; save line in D for later.
4385   0ECE 0F                  RRCA                    ; multiply
4386   0ECF 0F                  RRCA                    ; by
4387   0ED0 0F                  RRCA                    ; thirty-two.
4388   0ED1             
4389   0ED1 E6 E0               AND     $E0             ; mask off low bits to make
4390   0ED3 6F                  LD      L,A             ; L a multiple of 32.
4391   0ED4             
4392   0ED4 7A                  LD      A,D             ; bring back the line to A.
4393   0ED5             
4394   0ED5 E6 18               AND     $18             ; now $00, $08 or $10.
4395   0ED7             
4396   0ED7 F6 40               OR      $40             ; add the base address of screen.
4397   0ED9             
4398   0ED9 67                  LD      H,A             ; HL now has the correct address.
4399   0EDA C9                  RET                     ; return.
4400   0EDB             
4401   0EDB             ; -------------------
4402   0EDB             ; Handle COPY command
4403   0EDB             ; -------------------
4404   0EDB             ; This command copies the top 176 lines to the ZX Printer
4405   0EDB             ; It is popular to call this from machine code at point
4406   0EDB             ; L0EAF with B holding 192 (and interrupts disabled) for a full-screen
4407   0EDB             ; copy. This particularly applies to 16K Spectrums as time-critical
4408   0EDB             ; machine code routines cannot be written in the first 16K of RAM as
4409   0EDB             ; it is shared with the ULA which has precedence over the Z80 chip.
4410   0EDB             
4411   0EDB             ;; COPY
4412   0EDB F3          L0EAC:  DI                      ; disable interrupts as this is time-critical.
4413   0EDC             
4414   0EDC 06 B0               LD      B,$B0           ; top 176 lines.
4415   0EDE 21 00 40    L0EAF:  LD      HL,$4000        ; address start of the display file.
4416   0EE1             
4417   0EE1             ; now enter a loop to handle each pixel line.
4418   0EE1             
4419   0EE1             ;; COPY-1
4420   0EE1 E5          L0EB2:  PUSH    HL              ; save the screen address.
4421   0EE2 C5                  PUSH    BC              ; and the line counter.
4422   0EE3             
4423   0EE3 CD 23 0F            CALL    L0EF4           ; routine COPY-LINE outputs one line.
4424   0EE6             
4425   0EE6 C1                  POP     BC              ; restore the line counter.
4426   0EE7 E1                  POP     HL              ; and display address.
4427   0EE8 24                  INC     H               ; next line down screen within 'thirds'.
4428   0EE9 7C                  LD      A,H             ; high byte to A.
4429   0EEA E6 07               AND     $07             ; result will be zero if we have left third.
4430   0EEC 20 0A               JR      NZ,L0EC9        ; forward to COPY-2 if not to continue loop.
4431   0EEE             
4432   0EEE 7D                  LD      A,L             ; consider low byte first.
4433   0EEF C6 20               ADD     A,$20           ; increase by 32 - sets carry if back to zero.
4434   0EF1 6F                  LD      L,A             ; will be next group of 8.
4435   0EF2 3F                  CCF                     ; complement - carry set if more lines in
4436   0EF3                                             ; the previous third.
4437   0EF3 9F                  SBC     A,A             ; will be FF, if more, else 00.
4438   0EF4 E6 F8               AND     $F8             ; will be F8 (-8) or 00.
4439   0EF6 84                  ADD     A,H             ; that is subtract 8, if more to do in third.
4440   0EF7 67                  LD      H,A             ; and reset address.
4441   0EF8             
4442   0EF8             ;; COPY-2
4443   0EF8 10 E7       L0EC9:  DJNZ    L0EB2           ; back to COPY-1 for all lines.
4444   0EFA             
4445   0EFA 18 0D               JR      L0EDA           ; forward to COPY-END to switch off the printer
4446   0EFC                                             ; motor and enable interrupts.
4447   0EFC                                             ; Note. Nothing else is required.
4448   0EFC             
4449   0EFC             ; ------------------------------
4450   0EFC             ; Pass printer buffer to printer
4451   0EFC             ; ------------------------------
4452   0EFC             ; This routine is used to copy 8 text lines from the printer buffer
4453   0EFC             ; to the ZX Printer. These text lines are mapped linearly so HL does
4454   0EFC             ; not need to be adjusted at the end of each line.
4455   0EFC             
4456   0EFC             ;; COPY-BUFF
4457   0EFC F3          L0ECD:  DI                      ; disable interrupts
4458   0EFD 21 00 5B            LD      HL,$5B00        ; the base address of the Printer Buffer.
4459   0F00 06 08               LD      B,$08           ; set count to 8 lines of 32 bytes.
4460   0F02             
4461   0F02             ;; COPY-3
4462   0F02 C5          L0ED3:  PUSH    BC              ; save counter.
4463   0F03             
4464   0F03 CD 23 0F            CALL    L0EF4           ; routine COPY-LINE outputs 32 bytes
4465   0F06             
4466   0F06 C1                  POP     BC              ; restore counter.
4467   0F07 10 F9               DJNZ    L0ED3           ; loop back to COPY-3 for all 8 lines.
4468   0F09                                             ; then stop motor and clear buffer.
4469   0F09             
4470   0F09             ; Note. the COPY command rejoins here, essentially to execute the next
4471   0F09             ; three instructions.
4472   0F09             
4473   0F09             ;; COPY-END
4474   0F09 3E 04       L0EDA:  LD      A,$04           ; output value 4 to port
4475   0F0B D3 FB               OUT     ($FB),A         ; to stop the slowed printer motor.
4476   0F0D FB                  EI                      ; enable interrupts.
4477   0F0E             
4478   0F0E             ; --------------------
4479   0F0E             ; Clear Printer Buffer
4480   0F0E             ; --------------------
4481   0F0E             ; This routine clears an arbitrary 256 bytes of memory.
4482   0F0E             ; Note. The routine seems designed to clear a buffer that follows the
4483   0F0E             ; system variables.
4484   0F0E             ; The routine should check a flag or HL address and simply return if COPY
4485   0F0E             ; is in use.
4486   0F0E             ; As a consequence of this omission the buffer will needlessly
4487   0F0E             ; be cleared when COPY is used and the screen/printer position may be set to
4488   0F0E             ; the start of the buffer and the line number to 0 (B)
4489   0F0E             ; giving an 'Out of Screen' error.
4490   0F0E             ; There seems to have been an unsuccessful attempt to circumvent the use
4491   0F0E             ; of PR_CC_hi.
4492   0F0E             
4493   0F0E             ;; CLEAR-PRB
4494   0F0E 21 00 5B    L0EDF:  LD      HL,$5B00        ; the location of the buffer.
4495   0F11 FD 75 46            LD      (IY+$46),L      ; update PR_CC_lo - set to zero - superfluous.
4496   0F14 AF                  XOR     A               ; clear the accumulator.
4497   0F15 47                  LD      B,A             ; set count to 256 bytes.
4498   0F16             
4499   0F16             ;; PRB-BYTES
4500   0F16 77          L0EE7:  LD      (HL),A          ; set addressed location to zero.
4501   0F17 23                  INC     HL              ; address next byte - Note. not INC L.
4502   0F18 10 FC               DJNZ    L0EE7           ; back to PRB-BYTES. repeat for 256 bytes.
4503   0F1A             
4504   0F1A FD CB 30 8E         RES     1,(IY+$30)      ; set FLAGS2 - signal printer buffer is clear.
4505   0F1E 0E 21               LD      C,$21           ; set the column position .
4506   0F20 C3 08 0E            JP      L0DD9           ; exit via CL-SET and then PO-STORE.
4507   0F23             
4508   0F23             ; -----------------
4509   0F23             ; Copy line routine
4510   0F23             ; -----------------
4511   0F23             ; This routine is called from COPY and COPY-BUFF to output a line of
4512   0F23             ; 32 bytes to the ZX Printer.
4513   0F23             ; Output to port $FB -
4514   0F23             ; bit 7 set - activate stylus.
4515   0F23             ; bit 7 low - deactivate stylus.
4516   0F23             ; bit 2 set - stops printer.
4517   0F23             ; bit 2 reset - starts printer
4518   0F23             ; bit 1 set - slows printer.
4519   0F23             ; bit 1 reset - normal speed.
4520   0F23             
4521   0F23             ;; COPY-LINE
4522   0F23 78          L0EF4:  LD      A,B             ; fetch the counter 1-8 or 1-176
4523   0F24 FE 03               CP      $03             ; is it 01 or 02 ?.
4524   0F26 9F                  SBC     A,A             ; result is $FF if so else $00.
4525   0F27 E6 02               AND     $02             ; result is 02 now else 00.
4526   0F29                                             ; bit 1 set slows the printer.
4527   0F29 D3 FB               OUT     ($FB),A         ; slow the printer for the
4528   0F2B                                             ; last two lines.
4529   0F2B 57                  LD      D,A             ; save the mask to control the printer later.
4530   0F2C             
4531   0F2C             ;; COPY-L-1
4532   0F2C CD 83 1F    L0EFD:  CALL    L1F54           ; call BREAK-KEY to read keyboard immediately.
4533   0F2F 38 0A               JR      C,L0F0C         ; forward to COPY-L-2 if 'break' not pressed.
4534   0F31             
4535   0F31 3E 04               LD      A,$04           ; else stop the
4536   0F33 D3 FB               OUT     ($FB),A         ; printer motor.
4537   0F35 FB                  EI                      ; enable interrupts.
4538   0F36 CD 0E 0F            CALL    L0EDF           ; call routine CLEAR-PRB.
4539   0F39                                             ; Note. should not be cleared if COPY in use.
4540   0F39             
4541   0F39             ;; REPORT-Dc
4542   0F39 CF          L0F0A:  RST     08H             ; ERROR-1
4543   0F3A 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
4544   0F3B             
4545   0F3B             ;; COPY-L-2
4546   0F3B DB FB       L0F0C:  IN      A,($FB)         ; test now to see if
4547   0F3D 87                  ADD     A,A             ; a printer is attached.
4548   0F3E F8                  RET     M               ; return if not - but continue with parent
4549   0F3F                                             ; command.
4550   0F3F             
4551   0F3F 30 EB               JR      NC,L0EFD        ; back to COPY-L-1 if stylus of printer not
4552   0F41                                             ; in position.
4553   0F41             
4554   0F41 0E 20               LD      C,$20           ; set count to 32 bytes.
4555   0F43             
4556   0F43             ;; COPY-L-3
4557   0F43 5E          L0F14:  LD      E,(HL)          ; fetch a byte from line.
4558   0F44 23                  INC     HL              ; address next location. Note. not INC L.
4559   0F45 06 08               LD      B,$08           ; count the bits.
4560   0F47             
4561   0F47             ;; COPY-L-4
4562   0F47 CB 12       L0F18:  RL      D               ; prepare mask to receive bit.
4563   0F49 CB 13               RL      E               ; rotate leftmost print bit to carry
4564   0F4B CB 1A               RR      D               ; and back to bit 7 of D restoring bit 1
4565   0F4D             
4566   0F4D             ;; COPY-L-5
4567   0F4D DB FB       L0F1E:  IN      A,($FB)         ; read the port.
4568   0F4F 1F                  RRA                     ; bit 0 to carry.
4569   0F50 30 FB               JR      NC,L0F1E        ; back to COPY-L-5 if stylus not in position.
4570   0F52             
4571   0F52 7A                  LD      A,D             ; transfer command bits to A.
4572   0F53 D3 FB               OUT     ($FB),A         ; and output to port.
4573   0F55 10 F0               DJNZ    L0F18           ; loop back to COPY-L-4 for all 8 bits.
4574   0F57             
4575   0F57 0D                  DEC     C               ; decrease the byte count.
4576   0F58 20 E9               JR      NZ,L0F14        ; back to COPY-L-3 until 256 bits done.
4577   0F5A             
4578   0F5A C9                  RET                     ; return to calling routine COPY/COPY-BUFF.
4579   0F5B             
4580   0F5B             
4581   0F5B             ; ----------------------------------
4582   0F5B             ; Editor routine for BASIC and INPUT
4583   0F5B             ; ----------------------------------
4584   0F5B             ; The editor is called to prepare or edit a BASIC line.
4585   0F5B             ; It is also called from INPUT to input a numeric or string expression.
4586   0F5B             ; The behaviour and options are quite different in the various modes
4587   0F5B             ; and distinguished by bit 5 of FLAGX.
4588   0F5B             ;
4589   0F5B             ; This is a compact and highly versatile routine.
4590   0F5B             
4591   0F5B             ;; EDITOR
4592   0F5B 2A 3D 5C    L0F2C:  LD      HL,($5C3D)      ; fetch ERR_SP
4593   0F5E E5                  PUSH    HL              ; save on stack
4594   0F5F             
4595   0F5F             ;; ED-AGAIN
4596   0F5F 21 AE 10    L0F30:  LD      HL,L107F        ; address: ED-ERROR
4597   0F62 E5                  PUSH    HL              ; save address on stack and
4598   0F63 ED 73 3D 5C         LD      ($5C3D),SP      ; make ERR_SP point to it.
4599   0F67             
4600   0F67             ; Note. While in editing/input mode should an error occur then RST 08 will
4601   0F67             ; update X_PTR to the location reached by CH_ADD and jump to ED-ERROR
4602   0F67             ; where the error will be cancelled and the loop begin again from ED-AGAIN
4603   0F67             ; above. The position of the error will be apparent when the lower screen is
4604   0F67             ; reprinted. If no error then the re-iteration is to ED-LOOP below when
4605   0F67             ; input is arriving from the keyboard.
4606   0F67             
4607   0F67             ;; ED-LOOP
4608   0F67 CD 03 16    L0F38:  CALL    L15D4           ; routine WAIT-KEY gets key possibly
4609   0F6A                                             ; changing the mode.
4610   0F6A F5                  PUSH    AF              ; save key.
4611   0F6B 16 00               LD      D,$00           ; and give a short click based
4612   0F6D FD 5E FF            LD      E,(IY-$01)      ; on PIP value for duration.
4613   0F70 21 C8 00            LD      HL,$00C8        ; and pitch.
4614   0F73 CD E4 03            CALL    L03B5           ; routine BEEPER gives click - effective
4615   0F76                                             ; with rubber keyboard.
4616   0F76 F1                  POP     AF              ; get saved key value.
4617   0F77 21 67 0F            LD      HL,L0F38        ; address: ED-LOOP is loaded to HL.
4618   0F7A E5                  PUSH    HL              ; and pushed onto stack.
4619   0F7B             
4620   0F7B             ; At this point there is a looping return address on the stack, an error
4621   0F7B             ; handler and an input stream set up to supply characters.
4622   0F7B             ; The character that has been received can now be processed.
4623   0F7B             
4624   0F7B FE 18               CP      $18             ; range 24 to 255 ?
4625   0F7D 30 31               JR      NC,L0F81        ; forward to ADD-CHAR if so.
4626   0F7F             
4627   0F7F FE 07               CP      $07             ; lower than 7 ?
4628   0F81 38 2D               JR      C,L0F81         ; forward to ADD-CHAR also.
4629   0F83                                             ; Note. This is a 'bug' and chr$ 6, the comma
4630   0F83                                             ; control character, should have had an
4631   0F83                                             ; entry in the ED-KEYS table.
4632   0F83                                             ; Steven Vickers, 1984, Pitman.
4633   0F83             
4634   0F83 FE 10               CP      $10             ; less than 16 ?
4635   0F85 38 3A               JR      C,L0F92         ; forward to ED-KEYS if editing control
4636   0F87                                             ; range 7 to 15 dealt with by a table
4637   0F87             
4638   0F87 01 02 00            LD      BC,$0002        ; prepare for ink/paper etc.
4639   0F8A 57                  LD      D,A             ; save character in D
4640   0F8B FE 16               CP      $16             ; is it ink/paper/bright etc. ?
4641   0F8D 38 0C               JR      C,L0F6C         ; forward to ED-CONTR if so
4642   0F8F             
4643   0F8F                                             ; leaves 22d AT and 23d TAB
4644   0F8F                                             ; which can't be entered via KEY-INPUT.
4645   0F8F                                             ; so this code is never normally executed
4646   0F8F                                             ; when the keyboard is used for input.
4647   0F8F             
4648   0F8F 03                  INC     BC              ; if it was AT/TAB - 3 locations required
4649   0F90 FD CB 37 7E         BIT     7,(IY+$37)      ; test FLAGX  - Is this INPUT LINE ?
4650   0F94 CA 4D 10            JP      Z,L101E         ; jump to ED-IGNORE if not, else 
4651   0F97             
4652   0F97 CD 03 16            CALL    L15D4           ; routine WAIT-KEY - input address is KEY-NEXT
4653   0F9A                                             ; but is reset to KEY-INPUT
4654   0F9A 5F                  LD      E,A             ; save first in E
4655   0F9B             
4656   0F9B             ;; ED-CONTR
4657   0F9B CD 03 16    L0F6C:  CALL    L15D4           ; routine WAIT-KEY for control.
4658   0F9E                                             ; input address will be key-next.
4659   0F9E             
4660   0F9E D5                  PUSH    DE              ; saved code/parameters
4661   0F9F 2A 5B 5C            LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
4662   0FA2 FD CB 07 86         RES     0,(IY+$07)      ; set MODE to 'L'
4663   0FA6             
4664   0FA6 CD 84 16            CALL    L1655           ; routine MAKE-ROOM makes 2/3 spaces at cursor
4665   0FA9             
4666   0FA9 C1                  POP     BC              ; restore code/parameters
4667   0FAA 23                  INC     HL              ; address first location
4668   0FAB 70                  LD      (HL),B          ; place code (ink etc.)
4669   0FAC 23                  INC     HL              ; address next
4670   0FAD 71                  LD      (HL),C          ; place possible parameter. If only one
4671   0FAE                                             ; then DE points to this location also.
4672   0FAE 18 0A               JR      L0F8B           ; forward to ADD-CH-1
4673   0FB0             
4674   0FB0             ; ------------------------
4675   0FB0             ; Add code to current line
4676   0FB0             ; ------------------------
4677   0FB0             ; this is the branch used to add normal non-control characters
4678   0FB0             ; with ED-LOOP as the stacked return address.
4679   0FB0             ; it is also the OUTPUT service routine for system channel 'R'.
4680   0FB0             
4681   0FB0             ;; ADD-CHAR
4682   0FB0 FD CB 07 86 L0F81:  RES     0,(IY+$07)      ; set MODE to 'L'
4683   0FB4             
4684   0FB4 2A 5B 5C    X0F85:  LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
4685   0FB7             
4686   0FB7 CD 81 16            CALL    L1652           ; routine ONE-SPACE creates one space.
4687   0FBA             
4688   0FBA             ; either a continuation of above or from ED-CONTR with ED-LOOP on stack.
4689   0FBA             
4690   0FBA             ;; ADD-CH-1
4691   0FBA 12          L0F8B:  LD      (DE),A          ; load current character to last new location.
4692   0FBB 13                  INC     DE              ; address next
4693   0FBC ED 53 5B 5C         LD      ($5C5B),DE      ; and update K_CUR system variable.
4694   0FC0 C9                  RET                     ; return - either a simple return
4695   0FC1                                             ; from ADD-CHAR or to ED-LOOP on stack.
4696   0FC1             
4697   0FC1             ; ---
4698   0FC1             
4699   0FC1             ; a branch of the editing loop to deal with control characters
4700   0FC1             ; using a look-up table.
4701   0FC1             
4702   0FC1             ;; ED-KEYS
4703   0FC1 5F          L0F92:  LD      E,A             ; character to E.
4704   0FC2 16 00               LD      D,$00           ; prepare to add.
4705   0FC4 21 C8 0F            LD      HL,L0FA0 - 7    ; base address of editing keys table. $0F99
4706   0FC7 19                  ADD     HL,DE           ; add E
4707   0FC8 5E                  LD      E,(HL)          ; fetch offset to E
4708   0FC9 19                  ADD     HL,DE           ; add offset for address of handling routine.
4709   0FCA E5                  PUSH    HL              ; push the address on machine stack.
4710   0FCB 2A 5B 5C            LD      HL,($5C5B)      ; load address of cursor from K_CUR.
4711   0FCE C9                  RET                     ; Make an indirect jump forward to routine.
4712   0FCF             
4713   0FCF             ; ------------------
4714   0FCF             ; Editing keys table
4715   0FCF             ; ------------------
4716   0FCF             ; For each code in the range $07 to $0F this table contains a
4717   0FCF             ; single offset byte to the routine that services that code.
4718   0FCF             ; Note. for what was intended there should also have been an
4719   0FCF             ; entry for chr$ 6 with offset to ed-symbol.
4720   0FCF             
4721   0FCF             ;; ed-keys-t
4722   0FCF 09          L0FA0:  DEFB    L0FA9 - $  ; 07d offset $09 to Address: ED-EDIT
4723   0FD0 66                  DEFB    L1007 - $  ; 08d offset $66 to Address: ED-LEFT
4724   0FD1 6A                  DEFB    L100C - $  ; 09d offset $6A to Address: ED-RIGHT
4725   0FD2 50                  DEFB    L0FF3 - $  ; 10d offset $50 to Address: ED-DOWN
4726   0FD3 B5                  DEFB    L1059 - $  ; 11d offset $B5 to Address: ED-UP
4727   0FD4 70                  DEFB    L1015 - $  ; 12d offset $70 to Address: ED-DELETE
4728   0FD5 7E                  DEFB    L1024 - $  ; 13d offset $7E to Address: ED-ENTER
4729   0FD6 CF                  DEFB    L1076 - $  ; 14d offset $CF to Address: ED-SYMBOL
4730   0FD7 D4                  DEFB    L107C - $  ; 15d offset $D4 to Address: ED-GRAPH
4731   0FD8             
4732   0FD8             ; ---------------
4733   0FD8             ; Handle EDIT key
4734   0FD8             ; ---------------
4735   0FD8             ; The user has pressed SHIFT 1 to bring edit line down to bottom of screen.
4736   0FD8             ; Alternatively the user wishes to clear the input buffer and start again.
4737   0FD8             ; Alternatively ...
4738   0FD8             
4739   0FD8             ;; ED-EDIT
4740   0FD8 2A 49 5C    L0FA9:  LD      HL,($5C49)      ; fetch E_PPC the last line number entered.
4741   0FDB                                             ; Note. may not exist and may follow program.
4742   0FDB FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
4743   0FDF C2 C6 10            JP      NZ,L1097        ; jump forward to CLEAR-SP if not in editor.
4744   0FE2             
4745   0FE2 CD 9D 19            CALL    L196E           ; routine LINE-ADDR to find address of line
4746   0FE5                                             ; or following line if it doesn't exist.
4747   0FE5 CD C4 16            CALL    L1695           ; routine LINE-NO will get line number from
4748   0FE8                                             ; address or previous line if at end-marker.
4749   0FE8 7A                  LD      A,D             ; if there is no program then DE will
4750   0FE9 B3                  OR      E               ; contain zero so test for this.
4751   0FEA CA C6 10            JP      Z,L1097         ; jump to CLEAR-SP if so.
4752   0FED             
4753   0FED             ; Note. at this point we have a validated line number, not just an
4754   0FED             ; approximation and it would be best to update E_PPC with the true
4755   0FED             ; cursor line value which would enable the line cursor to be suppressed
4756   0FED             ; in all situations - see shortly.
4757   0FED             
4758   0FED E5                  PUSH    HL              ; save address of line.
4759   0FEE 23                  INC     HL              ; address low byte of length.
4760   0FEF 4E                  LD      C,(HL)          ; transfer to C
4761   0FF0 23                  INC     HL              ; next to high byte
4762   0FF1 46                  LD      B,(HL)          ; transfer to B.
4763   0FF2 21 0A 00            LD      HL,$000A        ; an overhead of ten bytes
4764   0FF5 09                  ADD     HL,BC           ; is added to length.
4765   0FF6 44                  LD      B,H             ; transfer adjusted value
4766   0FF7 4D                  LD      C,L             ; to BC register.
4767   0FF8 CD 34 1F            CALL    L1F05           ; routine TEST-ROOM checks free memory.
4768   0FFB CD C6 10            CALL    L1097           ; routine CLEAR-SP clears editing area.
4769   0FFE 2A 51 5C            LD      HL,($5C51)      ; address CURCHL
4770   1001 E3                  EX      (SP),HL         ; swap with line address on stack
4771   1002 E5                  PUSH    HL              ; save line address underneath
4772   1003             
4773   1003 3E FF               LD      A,$FF           ; select system channel 'R'
4774   1005 CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it
4775   1008             
4776   1008 E1                  POP     HL              ; drop line address
4777   1009 2B                  DEC     HL              ; make it point to first byte of line num.
4778   100A FD 35 0F            DEC     (IY+$0F)        ; decrease E_PPC_lo to suppress line cursor.
4779   100D                                             ; Note. ineffective when E_PPC is one
4780   100D                                             ; greater than last line of program perhaps
4781   100D                                             ; as a result of a delete.
4782   100D                                             ; credit. Paul Harrison 1982.
4783   100D             
4784   100D CD 84 18            CALL    L1855           ; routine OUT-LINE outputs the BASIC line
4785   1010                                             ; to the editing area.
4786   1010 FD 34 0F            INC     (IY+$0F)        ; restore E_PPC_lo to the previous value.
4787   1013 2A 59 5C            LD      HL,($5C59)      ; address E_LINE in editing area.
4788   1016 23                  INC     HL              ; advance
4789   1017 23                  INC     HL              ; past space
4790   1018 23                  INC     HL              ; and digit characters
4791   1019 23                  INC     HL              ; of line number.
4792   101A             
4793   101A 22 5B 5C            LD      ($5C5B),HL      ; update K_CUR to address start of BASIC.
4794   101D E1                  POP     HL              ; restore the address of CURCHL.
4795   101E CD 44 16            CALL    L1615           ; routine CHAN-FLAG sets flags for it.
4796   1021             
4797   1021 C9                  RET                     ; RETURN to ED-LOOP.
4798   1022             
4799   1022             ; -------------------
4800   1022             ; Cursor down editing
4801   1022             ; -------------------
4802   1022             ;   The BASIC lines are displayed at the top of the screen and the user
4803   1022             ;   wishes to move the cursor down one line in edit mode.
4804   1022             ;   With INPUT LINE, this key must be used instead of entering STOP.
4805   1022             
4806   1022             ;; ED-DOWN
4807   1022 FD CB 37 6E L0FF3:  BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
4808   1026 20 08               JR      NZ,L1001        ; skip to ED-STOP if so
4809   1028             
4810   1028 21 49 5C            LD      HL,$5C49        ; address E_PPC - 'current line'
4811   102B CD 3E 19            CALL    L190F           ; routine LN-FETCH fetches number of next
4812   102E                                             ; line or same if at end of program.
4813   102E 18 6D               JR      L106E           ; forward to ED-LIST to produce an
4814   1030                                             ; automatic listing.
4815   1030             
4816   1030             ; ---
4817   1030             
4818   1030             ;; ED-STOP
4819   1030 FD 36 00 10 L1001:  LD      (IY+$00),$10    ; set ERR_NR to 'STOP in INPUT' code
4820   1034 18 1D               JR      L1024           ; forward to ED-ENTER to produce error.
4821   1036             
4822   1036             ; -------------------
4823   1036             ; Cursor left editing
4824   1036             ; -------------------
4825   1036             ; This acts on the cursor in the lower section of the screen in both
4826   1036             ; editing and input mode.
4827   1036             
4828   1036             ;; ED-LEFT
4829   1036 CD 60 10    L1007:  CALL    L1031           ; routine ED-EDGE moves left if possible
4830   1039 18 05               JR      L1011           ; forward to ED-CUR to update K-CUR
4831   103B                                             ; and return to ED-LOOP.
4832   103B             
4833   103B             ; --------------------
4834   103B             ; Cursor right editing
4835   103B             ; --------------------
4836   103B             ; This acts on the cursor in the lower screen in both editing and input
4837   103B             ; mode and moves it to the right.
4838   103B             
4839   103B             ;; ED-RIGHT
4840   103B 7E          L100C:  LD      A,(HL)          ; fetch addressed character.
4841   103C FE 0D               CP      $0D             ; is it carriage return ?
4842   103E C8                  RET     Z               ; return if so to ED-LOOP
4843   103F             
4844   103F 23                  INC     HL              ; address next character
4845   1040             
4846   1040             ;; ED-CUR
4847   1040 22 5B 5C    L1011:  LD      ($5C5B),HL      ; update K_CUR system variable
4848   1043 C9                  RET                     ; return to ED-LOOP
4849   1044             
4850   1044             ; --------------
4851   1044             ; DELETE editing
4852   1044             ; --------------
4853   1044             ; This acts on the lower screen and deletes the character to left of
4854   1044             ; cursor. If control characters are present these are deleted first
4855   1044             ; leaving the naked parameter (0-7) which appears as a '?' except in the
4856   1044             ; case of chr$ 6 which is the comma control character. It is not mandatory
4857   1044             ; to delete these second characters.
4858   1044             
4859   1044             ;; ED-DELETE
4860   1044 CD 60 10    L1015:  CALL    L1031           ; routine ED-EDGE moves cursor to left.
4861   1047 01 01 00            LD      BC,$0001        ; of character to be deleted.
4862   104A C3 17 1A            JP      L19E8           ; to RECLAIM-2 reclaim the character.
4863   104D             
4864   104D             ; ------------------------------------------
4865   104D             ; Ignore next 2 codes from key-input routine
4866   104D             ; ------------------------------------------
4867   104D             ; Since AT and TAB cannot be entered this point is never reached
4868   104D             ; from the keyboard. If inputting from a tape device or network then
4869   104D             ; the control and two following characters are ignored and processing
4870   104D             ; continues as if a carriage return had been received.
4871   104D             ; Here, perhaps, another Spectrum has said print #15; AT 0,0; "This is yellow"
4872   104D             ; and this one is interpreting input #15; a$.
4873   104D             
4874   104D             ;; ED-IGNORE
4875   104D CD 03 16    L101E:  CALL    L15D4           ; routine WAIT-KEY to ignore keystroke.
4876   1050 CD 03 16            CALL    L15D4           ; routine WAIT-KEY to ignore next key.
4877   1053             
4878   1053             ; -------------
4879   1053             ; Enter/newline
4880   1053             ; -------------
4881   1053             ; The enter key has been pressed to have BASIC line or input accepted.
4882   1053             
4883   1053             ;; ED-ENTER
4884   1053 E1          L1024:  POP     HL              ; discard address ED-LOOP
4885   1054 E1                  POP     HL              ; drop address ED-ERROR
4886   1055             
4887   1055             ;; ED-END
4888   1055 E1          L1026:  POP     HL              ; the previous value of ERR_SP
4889   1056 22 3D 5C            LD      ($5C3D),HL      ; is restored to ERR_SP system variable
4890   1059 FD CB 00 7E         BIT     7,(IY+$00)      ; is ERR_NR $FF (= 'OK') ?
4891   105D C0                  RET     NZ              ; return if so
4892   105E             
4893   105E F9                  LD      SP,HL           ; else put error routine on stack
4894   105F C9                  RET                     ; and make an indirect jump to it.
4895   1060             
4896   1060             ; -----------------------------
4897   1060             ; Move cursor left when editing
4898   1060             ; -----------------------------
4899   1060             ; This routine moves the cursor left. The complication is that it must
4900   1060             ; not position the cursor between control codes and their parameters.
4901   1060             ; It is further complicated in that it deals with TAB and AT characters
4902   1060             ; which are never present from the keyboard.
4903   1060             ; The method is to advance from the beginning of the line each time,
4904   1060             ; jumping one, two, or three characters as necessary saving the original
4905   1060             ; position at each jump in DE. Once it arrives at the cursor then the next
4906   1060             ; legitimate leftmost position is in DE.
4907   1060             
4908   1060             ;; ED-EDGE
4909   1060 37          L1031:  SCF                     ; carry flag must be set to call the nested
4910   1061 CD C4 11            CALL    L1195           ; subroutine SET-DE.
4911   1064                                             ; if input   then DE=WORKSP
4912   1064                                             ; if editing then DE=E_LINE
4913   1064 ED 52               SBC     HL,DE           ; subtract address from start of line
4914   1066 19                  ADD     HL,DE           ; and add back.
4915   1067 23                  INC     HL              ; adjust for carry.
4916   1068 C1                  POP     BC              ; drop return address
4917   1069 D8                  RET     C               ; return to ED-LOOP if already at left
4918   106A                                             ; of line.
4919   106A             
4920   106A C5                  PUSH    BC              ; resave return address - ED-LOOP.
4921   106B 44                  LD      B,H             ; transfer HL - cursor address
4922   106C 4D                  LD      C,L             ; to BC register pair.
4923   106D                                             ; at this point DE addresses start of line.
4924   106D             
4925   106D             ;; ED-EDGE-1
4926   106D 62          L103E:  LD      H,D             ; transfer DE - leftmost pointer
4927   106E 6B                  LD      L,E             ; to HL
4928   106F 23                  INC     HL              ; address next leftmost character to
4929   1070                                             ; advance position each time.
4930   1070 1A                  LD      A,(DE)          ; pick up previous in A
4931   1071 E6 F0               AND     $F0             ; lose the low bits
4932   1073 FE 10               CP      $10             ; is it INK to TAB $10-$1F ?
4933   1075                                             ; that is, is it followed by a parameter ?
4934   1075 20 09               JR      NZ,L1051        ; to ED-EDGE-2 if not
4935   1077                                             ; HL has been incremented once
4936   1077             
4937   1077 23                  INC     HL              ; address next as at least one parameter.
4938   1078             
4939   1078             ; in fact since 'tab' and 'at' cannot be entered the next section seems
4940   1078             ; superfluous.
4941   1078             ; The test will always fail and the jump to ED-EDGE-2 will be taken.
4942   1078             
4943   1078 1A                  LD      A,(DE)          ; reload leftmost character
4944   1079 D6 17               SUB     $17             ; decimal 23 ('tab')
4945   107B CE 00               ADC     A,$00           ; will be 0 for 'tab' and 'at'.
4946   107D 20 01               JR      NZ,L1051        ; forward to ED-EDGE-2 if not
4947   107F                                             ; HL has been incremented twice
4948   107F             
4949   107F 23                  INC     HL              ; increment a third time for 'at'/'tab'
4950   1080             
4951   1080             ;; ED-EDGE-2
4952   1080 A7          L1051:  AND     A               ; prepare for true subtraction
4953   1081 ED 42               SBC     HL,BC           ; subtract cursor address from pointer
4954   1083 09                  ADD     HL,BC           ; and add back
4955   1084                                             ; Note when HL matches the cursor position BC,
4956   1084                                             ; there is no carry and the previous
4957   1084                                             ; position is in DE.
4958   1084 EB                  EX      DE,HL           ; transfer result to DE if looping again.
4959   1085                                             ; transfer DE to HL to be used as K-CUR
4960   1085                                             ; if exiting loop.
4961   1085 38 E6               JR      C,L103E         ; back to ED-EDGE-1 if cursor not matched.
4962   1087             
4963   1087 C9                  RET                     ; return.
4964   1088             
4965   1088             ; -----------------
4966   1088             ; Cursor up editing
4967   1088             ; -----------------
4968   1088             ; The main screen displays part of the BASIC program and the user wishes
4969   1088             ; to move up one line scrolling if necessary.
4970   1088             ; This has no alternative use in input mode.
4971   1088             
4972   1088             ;; ED-UP
4973   1088 FD CB 37 6E L1059:  BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
4974   108C C0                  RET     NZ              ; return if not in editor - to ED-LOOP.
4975   108D             
4976   108D 2A 49 5C            LD      HL,($5C49)      ; get current line from E_PPC
4977   1090 CD 9D 19            CALL    L196E           ; routine LINE-ADDR gets address
4978   1093 EB                  EX      DE,HL           ; and previous in DE
4979   1094 CD C4 16            CALL    L1695           ; routine LINE-NO gets prev line number
4980   1097 21 4A 5C            LD      HL,$5C4A        ; set HL to E_PPC_hi as next routine stores
4981   109A                                             ; top first.
4982   109A CD 4B 19            CALL    L191C           ; routine LN-STORE loads DE value to HL
4983   109D                                             ; high byte first - E_PPC_lo takes E
4984   109D             
4985   109D             ; this branch is also taken from ed-down.
4986   109D             
4987   109D             ;; ED-LIST
4988   109D CD C4 17    L106E:  CALL    L1795           ; routine AUTO-LIST lists to upper screen
4989   10A0                                             ; including adjusted current line.
4990   10A0 3E 00               LD      A,$00           ; select lower screen again
4991   10A2 C3 30 16            JP      L1601           ; exit via CHAN-OPEN to ED-LOOP
4992   10A5             
4993   10A5             ; --------------------------------
4994   10A5             ; Use of symbol and graphics codes
4995   10A5             ; --------------------------------
4996   10A5             ; These will not be encountered with the keyboard but would be handled
4997   10A5             ; otherwise as follows.
4998   10A5             ; As noted earlier, Vickers says there should have been an entry in
4999   10A5             ; the KEYS table for chr$ 6 which also pointed here.
5000   10A5             ; If, for simplicity, two Spectrums were both using #15 as a bi-directional
5001   10A5             ; channel connected to each other:-
5002   10A5             ; then when the other Spectrum has said PRINT #15; x, y
5003   10A5             ; input #15; i ; j  would treat the comma control as a newline and the
5004   10A5             ; control would skip to input j.
5005   10A5             ; You can get round the missing chr$ 6 handler by sending multiple print
5006   10A5             ; items separated by a newline '.
5007   10A5             
5008   10A5             ; chr$14 would have the same functionality.
5009   10A5             
5010   10A5             ; This is chr$ 14.
5011   10A5             ;; ED-SYMBOL
5012   10A5 FD CB 37 7E L1076:  BIT     7,(IY+$37)      ; test FLAGX - is this INPUT LINE ?
5013   10A9 28 A8               JR      Z,L1024         ; back to ED-ENTER if not to treat as if
5014   10AB                                             ; enter had been pressed.
5015   10AB                                             ; else continue and add code to buffer.
5016   10AB             
5017   10AB             ; Next is chr$ 15
5018   10AB             ; Note that ADD-CHAR precedes the table so we can't offset to it directly.
5019   10AB             
5020   10AB             ;; ED-GRAPH
5021   10AB C3 B0 0F    L107C:  JP      L0F81           ; jump back to ADD-CHAR
5022   10AE             
5023   10AE             ; --------------------
5024   10AE             ; Editor error routine
5025   10AE             ; --------------------
5026   10AE             ; If an error occurs while editing, or inputting, then ERR_SP
5027   10AE             ; points to the stack location holding address ED_ERROR.
5028   10AE             
5029   10AE             ;; ED-ERROR
5030   10AE FD CB 30 66 L107F:  BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
5031   10B2 28 A1               JR      Z,L1026         ; back to ED-END if not.
5032   10B4             
5033   10B4             ; but as long as we're editing lines or inputting from the keyboard, then
5034   10B4             ; we've run out of memory so give a short rasp.
5035   10B4             
5036   10B4 FD 36 00 FF         LD      (IY+$00),$FF    ; reset ERR_NR to 'OK'.
5037   10B8 16 00               LD      D,$00           ; prepare for beeper.
5038   10BA FD 5E FE            LD      E,(IY-$02)      ; use RASP value.
5039   10BD 21 90 1A            LD      HL,$1A90        ; set the pitch - or tone period.
5040   10C0 CD E4 03            CALL    L03B5           ; routine BEEPER emits a warning rasp.
5041   10C3 C3 5F 0F            JP      L0F30           ; to ED-AGAIN to re-stack address of
5042   10C6                                             ; this routine and make ERR_SP point to it.
5043   10C6             
5044   10C6             ; ---------------------
5045   10C6             ; Clear edit/work space
5046   10C6             ; ---------------------
5047   10C6             ; The editing area or workspace is cleared depending on context.
5048   10C6             ; This is called from ED-EDIT to clear workspace if edit key is
5049   10C6             ; used during input, to clear editing area if no program exists
5050   10C6             ; and to clear editing area prior to copying the edit line to it.
5051   10C6             ; It is also used by the error routine to clear the respective
5052   10C6             ; area depending on FLAGX.
5053   10C6             
5054   10C6             ;; CLEAR-SP
5055   10C6 E5          L1097:  PUSH    HL              ; preserve HL
5056   10C7 CD BF 11            CALL    L1190           ; routine SET-HL
5057   10CA                                             ; if in edit   HL = WORKSP-1, DE = E_LINE
5058   10CA                                             ; if in input  HL = STKBOT,   DE = WORKSP
5059   10CA 2B                  DEC     HL              ; adjust
5060   10CB CD 14 1A            CALL    L19E5           ; routine RECLAIM-1 reclaims space
5061   10CE 22 5B 5C            LD      ($5C5B),HL      ; set K_CUR to start of empty area
5062   10D1 FD 36 07 00         LD      (IY+$07),$00    ; set MODE to 'KLC'
5063   10D5 E1                  POP     HL              ; restore HL.
5064   10D6 C9                  RET                     ; return.
5065   10D7             
5066   10D7             ; ----------------------------
5067   10D7             ; THE 'KEYBOARD INPUT' ROUTINE
5068   10D7             ; ----------------------------
5069   10D7             ; This is the service routine for the input stream of the keyboard channel 'K'.
5070   10D7             
5071   10D7             ;; KEY-INPUT
5072   10D7 FD CB 02 5E L10A8:  BIT     3,(IY+$02)      ; test TV_FLAG  - has a key been pressed in
5073   10DB                                             ; editor ?
5074   10DB             
5075   10DB C4 4C 11            CALL    NZ,L111D        ; routine ED-COPY, if so, to reprint the lower
5076   10DE                                             ; screen at every keystroke/mode change.
5077   10DE             
5078   10DE A7                  AND     A               ; clear carry flag - required exit condition.
5079   10DF             
5080   10DF FD CB 01 6E         BIT     5,(IY+$01)      ; test FLAGS  - has a new key been pressed ?
5081   10E3 C8                  RET     Z               ; return if not.                        >>
5082   10E4             
5083   10E4 3A 08 5C            LD      A,($5C08)       ; system variable LASTK will hold last key -
5084   10E7                                             ; from the interrupt routine.
5085   10E7             
5086   10E7 FD CB 01 AE         RES     5,(IY+$01)      ; update FLAGS  - reset the new key flag.
5087   10EB F5                  PUSH    AF              ; save the input character.
5088   10EC             
5089   10EC FD CB 02 6E         BIT     5,(IY+$02)      ; test TV_FLAG  - clear lower screen ?
5090   10F0             
5091   10F0 C4 9D 0D            CALL    NZ,L0D6E        ; routine CLS-LOWER if so.
5092   10F3             
5093   10F3 F1                  POP     AF              ; restore the character code.
5094   10F4             
5095   10F4 FE 20               CP      $20             ; if space or higher then
5096   10F6 30 52               JR      NC,L111B        ; forward to KEY-DONE2 and return with carry
5097   10F8                                             ; set to signal key-found.
5098   10F8             
5099   10F8 FE 10               CP      $10             ; with 16d INK and higher skip
5100   10FA 30 2D               JR      NC,L10FA        ; forward to KEY-CONTR.
5101   10FC             
5102   10FC FE 06               CP      $06             ; for 6 - 15d
5103   10FE 30 0A               JR      NC,L10DB        ; skip forward to KEY-M-CL to handle Modes
5104   1100                                             ; and CapsLock.
5105   1100             
5106   1100             ; that only leaves 0-5, the flash bright inverse switches.
5107   1100             
5108   1100 47                  LD      B,A             ; save character in B
5109   1101 E6 01               AND     $01             ; isolate the embedded parameter (0/1).
5110   1103 4F                  LD      C,A             ; and store in C
5111   1104 78                  LD      A,B             ; re-fetch copy (0-5)
5112   1105 1F                  RRA                     ; halve it 0, 1 or 2.
5113   1106 C6 12               ADD     A,$12           ; add 18d gives 'flash', 'bright'
5114   1108                                             ; and 'inverse'.
5115   1108 18 2A               JR      L1105           ; forward to KEY-DATA with the 
5116   110A                                             ; parameter (0/1) in C.
5117   110A             
5118   110A             ; ---
5119   110A             
5120   110A             ; Now separate capslock 06 from modes 7-15.
5121   110A             
5122   110A             ;; KEY-M-CL
5123   110A 20 09       L10DB:  JR      NZ,L10E6        ; forward to KEY-MODE if not 06 (capslock)
5124   110C             
5125   110C 21 6A 5C            LD      HL,$5C6A        ; point to FLAGS2
5126   110F 3E 08               LD      A,$08           ; value 00001000
5127   1111 AE                  XOR     (HL)            ; toggle BIT 3 of FLAGS2 the capslock bit
5128   1112 77                  LD      (HL),A          ; and store result in FLAGS2 again.
5129   1113 18 0E               JR      L10F4           ; forward to KEY-FLAG to signal no-key.
5130   1115             
5131   1115             ; ---
5132   1115             
5133   1115             ;; KEY-MODE
5134   1115 FE 0E       L10E6:  CP      $0E             ; compare with chr 14d
5135   1117 D8                  RET     C               ; return with carry set "key found" for
5136   1118                                             ; codes 7 - 13d leaving 14d and 15d
5137   1118                                             ; which are converted to mode codes.
5138   1118             
5139   1118 D6 0D               SUB     $0D             ; subtract 13d leaving 1 and 2
5140   111A                                             ; 1 is 'E' mode, 2 is 'G' mode.
5141   111A 21 41 5C            LD      HL,$5C41        ; address the MODE system variable.
5142   111D BE                  CP      (HL)            ; compare with existing value before
5143   111E 77                  LD      (HL),A          ; inserting the new value.
5144   111F 20 02               JR      NZ,L10F4        ; forward to KEY-FLAG if it has changed.
5145   1121             
5146   1121 36 00               LD      (HL),$00        ; else make MODE zero - KLC mode
5147   1123                                             ; Note. while in Extended/Graphics mode,
5148   1123                                             ; the Extended Mode/Graphics key is pressed
5149   1123                                             ; again to get out.
5150   1123             
5151   1123             ;; KEY-FLAG
5152   1123 FD CB 02 DE L10F4:  SET     3,(IY+$02)      ; update TV_FLAG  - show key state has changed
5153   1127 BF                  CP      A               ; clear carry and reset zero flags -
5154   1128                                             ; no actual key returned.
5155   1128 C9                  RET                     ; make the return.
5156   1129             
5157   1129             ; ---
5158   1129             
5159   1129             ; now deal with colour controls - 16-23 ink, 24-31 paper
5160   1129             
5161   1129             ;; KEY-CONTR
5162   1129 47          L10FA:  LD      B,A             ; make a copy of character.
5163   112A E6 07               AND     $07             ; mask to leave bits 0-7
5164   112C 4F                  LD      C,A             ; and store in C.
5165   112D 3E 10               LD      A,$10           ; initialize to 16d - INK.
5166   112F CB 58               BIT     3,B             ; was it paper ?
5167   1131 20 01               JR      NZ,L1105        ; forward to KEY-DATA with INK 16d and
5168   1133                                             ; colour in C.
5169   1133             
5170   1133 3C                  INC     A               ; else change from INK to PAPER (17d) if so.
5171   1134             
5172   1134             ;; KEY-DATA
5173   1134 FD 71 D3    L1105:  LD      (IY-$2D),C      ; put the colour (0-7)/state(0/1) in KDATA
5174   1137 11 3C 11            LD      DE,L110D        ; address: KEY-NEXT will be next input stream
5175   113A 18 06               JR      L1113           ; forward to KEY-CHAN to change it ...
5176   113C             
5177   113C             ; ---
5178   113C             
5179   113C             ; ... so that INPUT_AD directs control to here at next call to WAIT-KEY
5180   113C             
5181   113C             ;; KEY-NEXT
5182   113C 3A 0D 5C    L110D:  LD      A,($5C0D)       ; pick up the parameter stored in KDATA.
5183   113F 11 D7 10            LD      DE,L10A8        ; address: KEY-INPUT will be next input stream
5184   1142                                             ; continue to restore default channel and
5185   1142                                             ; make a return with the control code.
5186   1142             
5187   1142             ;; KEY-CHAN
5188   1142 2A 4F 5C    L1113:  LD      HL,($5C4F)      ; address start of CHANNELS area using CHANS
5189   1145                                             ; system variable.
5190   1145                                             ; Note. One might have expected CURCHL to
5191   1145                                             ; have been used.
5192   1145 23                  INC     HL              ; step over the
5193   1146 23                  INC     HL              ; output address
5194   1147 73                  LD      (HL),E          ; and update the input
5195   1148 23                  INC     HL              ; routine address for
5196   1149 72                  LD      (HL),D          ; the next call to WAIT-KEY.
5197   114A             
5198   114A             ;; KEY-DONE2
5199   114A 37          L111B:  SCF                     ; set carry flag to show a key has been found
5200   114B C9                  RET                     ; and return.
5201   114C             
5202   114C             ; --------------------
5203   114C             ; Lower screen copying
5204   114C             ; --------------------
5205   114C             ; This subroutine is called whenever the line in the editing area or
5206   114C             ; input workspace is required to be printed to the lower screen.
5207   114C             ; It is by calling this routine after any change that the cursor, for
5208   114C             ; instance, appears to move to the left.
5209   114C             ; Remember the edit line will contain characters and tokens
5210   114C             ; e.g. "1000 LET a=1" is 8 characters.
5211   114C             
5212   114C             ;; ED-COPY
5213   114C CD 7C 0D    L111D:  CALL    L0D4D           ; routine TEMPS sets temporary attributes.
5214   114F FD CB 02 9E         RES     3,(IY+$02)      ; update TV_FLAG  - signal no change in mode
5215   1153 FD CB 02 AE         RES     5,(IY+$02)      ; update TV_FLAG  - signal don't clear lower
5216   1157                                             ; screen.
5217   1157 2A 8A 5C            LD      HL,($5C8A)      ; fetch SPOSNL
5218   115A E5                  PUSH    HL              ; and save on stack.
5219   115B             
5220   115B 2A 3D 5C            LD      HL,($5C3D)      ; fetch ERR_SP
5221   115E E5                  PUSH    HL              ; and save also
5222   115F 21 96 11            LD      HL,L1167        ; address: ED-FULL
5223   1162 E5                  PUSH    HL              ; is pushed as the error routine
5224   1163 ED 73 3D 5C         LD      ($5C3D),SP      ; and ERR_SP made to point to it.
5225   1167             
5226   1167 2A 82 5C            LD      HL,($5C82)      ; fetch ECHO_E
5227   116A E5                  PUSH    HL              ; and push also
5228   116B             
5229   116B 37                  SCF                     ; set carry flag to control SET-DE
5230   116C CD C4 11            CALL    L1195           ; call routine SET-DE
5231   116F                                             ; if in input DE = WORKSP
5232   116F                                             ; if in edit  DE = E_LINE
5233   116F EB                  EX      DE,HL           ; start address to HL
5234   1170             
5235   1170 CD AC 18            CALL    L187D           ; routine OUT-LINE2 outputs entire line up to
5236   1173                                             ; carriage return including initial
5237   1173                                             ; characterized line number when present.
5238   1173 EB                  EX      DE,HL           ; transfer new address to DE
5239   1174 CD 10 19            CALL    L18E1           ; routine OUT-CURS considers a
5240   1177                                             ; terminating cursor.
5241   1177             
5242   1177 2A 8A 5C            LD      HL,($5C8A)      ; fetch updated SPOSNL
5243   117A E3                  EX      (SP),HL         ; exchange with ECHO_E on stack
5244   117B EB                  EX      DE,HL           ; transfer ECHO_E to DE
5245   117C CD 7C 0D            CALL    L0D4D           ; routine TEMPS to re-set attributes
5246   117F                                             ; if altered.
5247   117F             
5248   117F             ; the lower screen was not cleared, at the outset, so if deleting then old
5249   117F             ; text from a previous print may follow this line and requires blanking.
5250   117F             
5251   117F             ;; ED-BLANK
5252   117F 3A 8B 5C    L1150:  LD      A,($5C8B)       ; fetch SPOSNL_hi is current line
5253   1182 92                  SUB     D               ; compare with old
5254   1183 38 26               JR      C,L117C         ; forward to ED-C-DONE if no blanking
5255   1185             
5256   1185 20 06               JR      NZ,L115E        ; forward to ED-SPACES if line has changed
5257   1187             
5258   1187 7B                  LD      A,E             ; old column to A
5259   1188 FD 96 50            SUB     (IY+$50)        ; subtract new in SPOSNL_lo
5260   118B 30 1E               JR      NC,L117C        ; forward to ED-C-DONE if no backfilling.
5261   118D             
5262   118D             ;; ED-SPACES
5263   118D 3E 20       L115E:  LD      A,$20           ; prepare a space.
5264   118F D5                  PUSH    DE              ; save old line/column.
5265   1190 CD 23 0A            CALL    L09F4           ; routine PRINT-OUT prints a space over
5266   1193                                             ; any text from previous print.
5267   1193                                             ; Note. Since the blanking only occurs when
5268   1193                                             ; using $09F4 to print to the lower screen,
5269   1193                                             ; there is no need to vector via a RST 10
5270   1193                                             ; and we can use this alternate set.
5271   1193 D1                  POP     DE              ; restore the old line column.
5272   1194 18 E9               JR      L1150           ; back to ED-BLANK until all old text blanked.
5273   1196             
5274   1196             ; -------------------------------
5275   1196             ; THE 'EDITOR-FULL' ERROR ROUTINE
5276   1196             ; -------------------------------
5277   1196             ;   This is the error routine addressed by ERR_SP.  This is not for the out of
5278   1196             ;   memory situation as we're just printing.  The pitch and duration are exactly
5279   1196             ;   the same as used by ED-ERROR from which this has been augmented.  The
5280   1196             ;   situation is that the lower screen is full and a rasp is given to suggest
5281   1196             ;   that this is perhaps not the best idea you've had that day.
5282   1196             
5283   1196             ;; ED-FULL
5284   1196 16 00       L1167:  LD      D,$00           ; prepare to moan.
5285   1198 FD 5E FE            LD      E,(IY-$02)      ; fetch RASP value.
5286   119B 21 90 1A            LD      HL,$1A90        ; set pitch or tone period.
5287   119E             
5288   119E CD E4 03            CALL    L03B5           ; routine BEEPER.
5289   11A1             
5290   11A1 FD 36 00 FF         LD      (IY+$00),$FF    ; clear ERR_NR.
5291   11A5 ED 5B 8A 5C         LD      DE,($5C8A)      ; fetch SPOSNL.
5292   11A9 18 02               JR      L117E           ; forward to ED-C-END
5293   11AB             
5294   11AB             ; -------
5295   11AB             
5296   11AB             ; the exit point from line printing continues here.
5297   11AB             
5298   11AB             ;; ED-C-DONE
5299   11AB D1          L117C:  POP     DE              ; fetch new line/column.
5300   11AC E1                  POP     HL              ; fetch the error address.
5301   11AD             
5302   11AD             ; the error path rejoins here.
5303   11AD             
5304   11AD             ;; ED-C-END
5305   11AD E1          L117E:  POP     HL              ; restore the old value of ERR_SP.
5306   11AE 22 3D 5C            LD      ($5C3D),HL      ; update the system variable ERR_SP
5307   11B1             
5308   11B1 C1                  POP     BC              ; old value of SPOSN_L
5309   11B2 D5                  PUSH    DE              ; save new value
5310   11B3             
5311   11B3 CD 08 0E            CALL    L0DD9           ; routine CL-SET and PO-STORE
5312   11B6                                             ; update ECHO_E and SPOSN_L from BC
5313   11B6             
5314   11B6 E1                  POP     HL              ; restore new value
5315   11B7 22 82 5C            LD      ($5C82),HL      ; and overwrite ECHO_E
5316   11BA             
5317   11BA FD 36 26 00         LD      (IY+$26),$00    ; make error pointer X_PTR_hi out of bounds
5318   11BE             
5319   11BE C9                  RET                     ; return
5320   11BF             
5321   11BF             ; -----------------------------------------------
5322   11BF             ; Point to first and last locations of work space
5323   11BF             ; -----------------------------------------------
5324   11BF             ;   These two nested routines ensure that the appropriate pointers are
5325   11BF             ;   selected for the editing area or workspace. The routines that call
5326   11BF             ;   these routines are designed to work on either area.
5327   11BF             
5328   11BF             ; this routine is called once
5329   11BF             
5330   11BF             ;; SET-HL
5331   11BF 2A 61 5C    L1190:  LD      HL,($5C61)      ; fetch WORKSP to HL.
5332   11C2 2B                  DEC     HL              ; point to last location of editing area.
5333   11C3 A7                  AND     A               ; clear carry to limit exit points to first
5334   11C4                                             ; or last.
5335   11C4             
5336   11C4             ; this routine is called with carry set and exits at a conditional return.
5337   11C4             
5338   11C4             ;; SET-DE
5339   11C4 ED 5B 59 5C L1195:  LD      DE,($5C59)      ; fetch E_LINE to DE
5340   11C8 FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
5341   11CC C8                  RET     Z               ; return now if in editing mode
5342   11CD             
5343   11CD ED 5B 61 5C         LD      DE,($5C61)      ; fetch WORKSP to DE
5344   11D1 D8                  RET     C               ; return if carry set ( entry = set-de)
5345   11D2             
5346   11D2 2A 63 5C            LD      HL,($5C63)      ; fetch STKBOT to HL as well
5347   11D5 C9                  RET                     ; and return  (entry = set-hl (in input))
5348   11D6             
5349   11D6             ; -----------------------------------
5350   11D6             ; THE 'REMOVE FLOATING POINT' ROUTINE
5351   11D6             ; -----------------------------------
5352   11D6             ;   When a BASIC LINE or the INPUT BUFFER is parsed any numbers will have
5353   11D6             ;   an invisible chr 14d inserted after them and the 5-byte integer or
5354   11D6             ;   floating point form inserted after that.  Similar invisible value holders
5355   11D6             ;   are also created after the numeric and string variables in a DEF FN list.
5356   11D6             ;   This routine removes these 'compiled' numbers from the edit line or
5357   11D6             ;   input workspace.
5358   11D6             
5359   11D6             ;; REMOVE-FP
5360   11D6 7E          L11A7:  LD      A,(HL)          ; fetch character
5361   11D7 FE 0E               CP      $0E             ; is it the CHR$ 14 number marker ?
5362   11D9 01 06 00            LD      BC,$0006        ; prepare to strip six bytes
5363   11DC             
5364   11DC CC 17 1A            CALL    Z,L19E8         ; routine RECLAIM-2 reclaims bytes if CHR$ 14.
5365   11DF             
5366   11DF 7E                  LD      A,(HL)          ; reload next (or same) character
5367   11E0 23                  INC     HL              ; and advance address
5368   11E1 FE 0D               CP      $0D             ; end of line or input buffer ?
5369   11E3 20 F1               JR      NZ,L11A7        ; back to REMOVE-FP until entire line done.
5370   11E5             
5371   11E5 C9                  RET                     ; return.
5372   11E6             
5373   11E6             
5374   11E6             ; *********************************
5375   11E6             ; ** Part 6. EXECUTIVE ROUTINES  **
5376   11E6             ; *********************************
5377   11E6             
5378   11E6             
5379   11E6             ; The memory.
5380   11E6             ;
5381   11E6             ; +---------+-----------+------------+--------------+-------------+--
5382   11E6             ; | BASIC   |  Display  | Attributes | ZX Printer   |    System   | 
5383   11E6             ; |  ROM    |   File    |    File    |   Buffer     |  Variables  | 
5384   11E6             ; +---------+-----------+------------+--------------+-------------+--
5385   11E6             ; ^         ^           ^            ^              ^             ^
5386   11E6             ; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS 
5387   11E6             ;
5388   11E6             ;
5389   11E6             ;  --+----------+---+---------+-----------+---+------------+--+---+--
5390   11E6             ;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|
5391   11E6             ;    |   Info   |   | Program |   Area    |   | or Command |  |   |
5392   11E6             ;  --+----------+---+---------+-----------+---+------------+--+---+--
5393   11E6             ;    ^              ^         ^               ^                   ^
5394   11E6             ;  CHANS           PROG      VARS           E_LINE              WORKSP
5395   11E6             ;
5396   11E6             ;
5397   11E6             ;                             ---5-->         <---2---  <--3---
5398   11E6             ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
5399   11E6             ;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |
5400   11E6             ;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |
5401   11E6             ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
5402   11E6             ;    ^                       ^       ^       ^                   ^   ^      ^
5403   11E6             ;  WORKSP                  STKBOT  STKEND   sp               RAMTOP UDG  P_RAMT
5404   11E6             ;                                                                         
5405   11E6             
5406   11E6             ; -----------------
5407   11E6             ; THE 'NEW' COMMAND
5408   11E6             ; -----------------
5409   11E6             ;   The NEW command is about to set all RAM below RAMTOP to zero and then
5410   11E6             ;   re-initialize the system.  All RAM above RAMTOP should, and will be,
5411   11E6             ;   preserved.
5412   11E6             ;   There is nowhere to store values in RAM or on the stack which becomes
5413   11E6             ;   inoperable. Similarly PUSH and CALL instructions cannot be used to store
5414   11E6             ;   values or section common code. The alternate register set is the only place
5415   11E6             ;   available to store 3 persistent 16-bit system variables.
5416   11E6             
5417   11E6             ;; NEW
5418   11E6 F3          L11B7:  DI                      ; Disable Interrupts - machine stack will be
5419   11E7                                             ; cleared.
5420   11E7 3E FF               LD      A,$FF           ; Flag coming from NEW.
5421   11E9 ED 5B B2 5C         LD      DE,($5CB2)      ; Fetch RAMTOP as top value.
5422   11ED D9                  EXX                     ; Switch in alternate set.
5423   11EE ED 4B B4 5C         LD      BC,($5CB4)      ; Fetch P-RAMT differs on 16K/48K machines.
5424   11F2 ED 5B 38 5C         LD      DE,($5C38)      ; Fetch RASP/PIP.
5425   11F6 2A 7B 5C            LD      HL,($5C7B)      ; Fetch UDG    differs on 16K/48K machines.
5426   11F9 D9                  EXX                     ; Switch back to main set and continue into...
5427   11FA             
5428   11FA             ; ----------------------
5429   11FA             ; THE 'START-NEW' BRANCH     
5430   11FA             ; ----------------------
5431   11FA             ;   This branch is taken from above and from RST 00h.
5432   11FA             ;   The common code tests RAM and sets it to zero re-initializing all the 
5433   11FA             ;   non-zero system variables and channel information.  The A register flags 
5434   11FA             ;   if coming from START or NEW.
5435   11FA             
5436   11FA             ;; START-NEW
5437   11FA 47          L11CB:  LD      B,A             ; Save the flag to control later branching.
5438   11FB             
5439   11FB 3E 07               LD      A,$07           ; Select a white border
5440   11FD D3 FE               OUT     ($FE),A         ; and set it now by writing to a port.
5441   11FF             
5442   11FF 3E 3F               LD      A,$3F           ; Load the accumulator with last page in ROM.
5443   1201 ED 47               LD      I,A             ; Set the I register - this remains constant
5444   1203                                             ; and can't be in the range $40 - $7F as 'snow'
5445   1203                                             ; appears on the screen.
5446   1203             
5447   1203 00                  NOP                     ; These seem unnecessary.
5448   1204 00                  NOP                     ;
5449   1205 00                  NOP                     ;
5450   1206 00                  NOP                     ;
5451   1207 00                  NOP                     ;
5452   1208 00                  NOP                     ;
5453   1209             
5454   1209             ; -----------------------
5455   1209             ; THE 'RAM CHECK' SECTION
5456   1209             ; -----------------------
5457   1209             ;   Typically, a Spectrum will have 16K or 48K of RAM and this code will test
5458   1209             ;   it all till it finds an unpopulated location or, less likely, a faulty 
5459   1209             ;   location.  Usually it stops when it reaches the top $FFFF, or in the case 
5460   1209             ;   of NEW the supplied top value.  The entire screen turns black with 
5461   1209             ;   sometimes red stripes on black paper just visible.
5462   1209             
5463   1209             ;; ram-check
5464   1209 62          L11DA:  LD      H,D             ; Transfer the top value to the HL register
5465   120A 6B                  LD      L,E             ; pair.
5466   120B             
5467   120B             ;; RAM-FILL
5468   120B 36 02       L11DC:  LD      (HL),$02        ; Load memory with $02 - red ink on black paper.
5469   120D 2B                  DEC     HL              ; Decrement memory address.
5470   120E BC                  CP      H               ; Have we reached ROM - $3F ?
5471   120F 20 FA               JR      NZ,L11DC        ; Back to RAM-FILL if not.
5472   1211             
5473   1211             ;; RAM-READ
5474   1211 A7          L11E2:  AND     A               ; Clear carry - prepare to subtract.
5475   1212 ED 52               SBC     HL,DE           ; subtract and add back setting
5476   1214 19                  ADD     HL,DE           ; carry when back at start.
5477   1215 23                  INC     HL              ; and increment for next iteration.
5478   1216 30 06               JR      NC,L11EF        ; forward to RAM-DONE if we've got back to
5479   1218                                             ; starting point with no errors.
5480   1218             
5481   1218 35                  DEC     (HL)            ; decrement to 1.
5482   1219 28 03               JR      Z,L11EF         ; forward to RAM-DONE if faulty.
5483   121B             
5484   121B 35                  DEC     (HL)            ; decrement to zero.
5485   121C 28 F3               JR      Z,L11E2         ; back to RAM-READ if zero flag was set.
5486   121E             
5487   121E             ;; RAM-DONE
5488   121E 2B          L11EF:  DEC     HL              ; step back to last valid location.
5489   121F D9                  EXX                     ; regardless of state, set up possibly
5490   1220                                             ; stored system variables in case from NEW.
5491   1220 ED 43 B4 5C         LD      ($5CB4),BC      ; insert P-RAMT.
5492   1224 ED 53 38 5C         LD      ($5C38),DE      ; insert RASP/PIP.
5493   1228 22 7B 5C            LD      ($5C7B),HL      ; insert UDG.
5494   122B D9                  EXX                     ; switch in main set.
5495   122C 04                  INC     B               ; now test if we arrived here from NEW.
5496   122D 28 19               JR      Z,L1219         ; forward to RAM-SET if we did.
5497   122F             
5498   122F             ;   This section applies to START only.
5499   122F             
5500   122F 22 B4 5C            LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM
5501   1232                                             ; address.
5502   1232 11 AF 3E            LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.
5503   1235 01 A8 00            LD      BC,$00A8        ; there are 21 user defined graphics.
5504   1238 EB                  EX      DE,HL           ; switch pointers and make the UDGs a
5505   1239 ED B8               LDDR                    ; copy of the standard characters A - U.
5506   123B EB                  EX      DE,HL           ; switch the pointer to HL.
5507   123C 23                  INC     HL              ; update to start of 'A' in RAM.
5508   123D 22 7B 5C            LD      ($5C7B),HL      ; make UDG system variable address the first
5509   1240                                             ; bitmap.
5510   1240 2B                  DEC     HL              ; point at RAMTOP again.
5511   1241             
5512   1241 01 40 00            LD      BC,$0040        ; set the values of
5513   1244 ED 43 38 5C         LD      ($5C38),BC      ; the PIP and RASP system variables.
5514   1248             
5515   1248             ;   The NEW command path rejoins here.
5516   1248             
5517   1248             ;; RAM-SET
5518   1248 22 B2 5C    L1219:  LD      ($5CB2),HL      ; set system variable RAMTOP to HL.
5519   124B             
5520   124B             ;   New
5521   124B             ;   Note. this entry point is a disabled Warm Restart that was almost certainly
5522   124B             ;   once pointed to by the System Variable NMIADD.  It would be essential that
5523   124B             ;   any NMI Handler would perform the tasks from here to the EI instruction 
5524   124B             ;   below.
5525   124B             
5526   124B             ;; NMI_VECT
5527   124B             L121C:
5528   124B 21 00 3C            LD      HL,$3C00        ; a strange place to set the pointer to the 
5529   124E 22 36 5C            LD      ($5C36),HL      ; character set, CHARS - as no printing yet.
5530   1251             
5531   1251 2A B2 5C            LD      HL,($5CB2)      ; fetch RAMTOP to HL again as we've lost it.
5532   1254             
5533   1254 36 3E               LD      (HL),$3E        ; top of user ram holds GOSUB end marker
5534   1256                                             ; an impossible line number - see RETURN.
5535   1256                                             ; no significance in the number $3E. It has
5536   1256                                             ; been traditional since the ZX80.
5537   1256             
5538   1256 2B                  DEC     HL              ; followed by empty byte (not important).
5539   1257 F9                  LD      SP,HL           ; set up the machine stack pointer.
5540   1258 2B                  DEC     HL              ;
5541   1259 2B                  DEC     HL              ;
5542   125A 22 3D 5C            LD      ($5C3D),HL      ; ERR_SP is where the error pointer is
5543   125D                                             ; at moment empty - will take address MAIN-4
5544   125D                                             ; at the call preceding that address,
5545   125D                                             ; although interrupts and calls will make use
5546   125D                                             ; of this location in meantime.
5547   125D             
5548   125D ED 56               IM      1               ; select interrupt mode 1.
5549   125F             
5550   125F FD 21 3A 5C         LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard
5551   1263                                             ; system variables but shadow ROM system
5552   1263                                             ; variables will be mostly out of range.
5553   1263             
5554   1263 FB                  EI                      ; enable interrupts now that we have a stack.
5555   1264             
5556   1264             ;   If, as suggested above, the NMI service routine pointed to this section of
5557   1264             ;   code then a decision would have to be made at this point to jump forward, 
5558   1264             ;   in a Warm Restart scenario, to produce a report code, leaving any program 
5559   1264             ;   intact.
5560   1264             
5561   1264 21 B6 5C            LD      HL,$5CB6        ; The address of the channels - initially
5562   1267                                             ; following system variables.
5563   1267 22 4F 5C            LD      ($5C4F),HL      ; Set the CHANS system variable.
5564   126A             
5565   126A 11 DE 15            LD      DE,L15AF        ; Address: init-chan in ROM.
5566   126D 01 15 00            LD      BC,$0015        ; There are 21 bytes of initial data in ROM.
5567   1270 EB                  EX      DE,HL           ; swap the pointers.
5568   1271 ED B0               LDIR                    ; Copy the bytes to RAM.
5569   1273             
5570   1273 EB                  EX      DE,HL           ; Swap pointers. HL points to program area.
5571   1274 2B                  DEC     HL              ; Decrement address.
5572   1275 22 57 5C            LD      ($5C57),HL      ; Set DATADD to location before program area.
5573   1278 23                  INC     HL              ; Increment again.
5574   1279             
5575   1279 22 53 5C            LD      ($5C53),HL      ; Set PROG the location where BASIC starts.
5576   127C 22 4B 5C            LD      ($5C4B),HL      ; Set VARS to same location with a
5577   127F 36 80               LD      (HL),$80        ; variables end-marker.
5578   1281 23                  INC     HL              ; Advance address.
5579   1282 22 59 5C            LD      ($5C59),HL      ; Set E_LINE, where the edit line
5580   1285                                             ; will be created.
5581   1285                                             ; Note. it is not strictly necessary to
5582   1285                                             ; execute the next fifteen bytes of code
5583   1285                                             ; as this will be done by the call to SET-MIN.
5584   1285                                             ; --
5585   1285 36 0D               LD      (HL),$0D        ; initially just has a carriage return
5586   1287 23                  INC     HL              ; followed by
5587   1288 36 80               LD      (HL),$80        ; an end-marker.
5588   128A 23                  INC     HL              ; address the next location.
5589   128B 22 61 5C            LD      ($5C61),HL      ; set WORKSP - empty workspace.
5590   128E 22 63 5C            LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.
5591   1291 22 65 5C            LD      ($5C65),HL      ; set STKEND to the end of the empty stack.
5592   1294                                             ; --
5593   1294 3E 38               LD      A,$38           ; the colour system is set to white paper,
5594   1296                                             ; black ink, no flash or bright.
5595   1296 32 8D 5C            LD      ($5C8D),A       ; set ATTR_P permanent colour attributes.
5596   1299 32 8F 5C            LD      ($5C8F),A       ; set ATTR_T temporary colour attributes.
5597   129C 32 48 5C            LD      ($5C48),A       ; set BORDCR the border colour/lower screen
5598   129F                                             ; attributes.
5599   129F             
5600   129F 21 23 05            LD      HL,$0523        ; The keyboard repeat and delay values are 
5601   12A2 22 09 5C            LD      ($5C09),HL      ; loaded to REPDEL and REPPER.
5602   12A5             
5603   12A5 FD 35 C6            DEC     (IY-$3A)        ; set KSTATE-0 to $FF - keyboard map available.
5604   12A8 FD 35 CA            DEC     (IY-$36)        ; set KSTATE-4 to $FF - keyboard map available.
5605   12AB             
5606   12AB 21 F5 15            LD      HL,L15C6        ; set source to ROM Address: init-strm
5607   12AE 11 10 5C            LD      DE,$5C10        ; set destination to system variable STRMS-FD
5608   12B1 01 0E 00            LD      BC,$000E        ; copy the 14 bytes of initial 7 streams data
5609   12B4 ED B0               LDIR                    ; from ROM to RAM.
5610   12B6             
5611   12B6 FD CB 01 CE         SET     1,(IY+$01)      ; update FLAGS  - signal printer in use.
5612   12BA CD 0E 0F            CALL    L0EDF           ; call routine CLEAR-PRB to initialize system
5613   12BD                                             ; variables associated with printer.
5614   12BD                                             ; The buffer is clear.
5615   12BD             
5616   12BD FD 36 31 02         LD      (IY+$31),$02    ; set DF_SZ the lower screen display size to
5617   12C1                                             ; two lines
5618   12C1 CD 9A 0D            CALL    L0D6B           ; call routine CLS to set up system
5619   12C4                                             ; variables associated with screen and clear
5620   12C4                                             ; the screen and set attributes.
5621   12C4 AF                  XOR     A               ; clear accumulator so that we can address
5622   12C5 11 67 15            LD      DE,L1539 - 1    ; the message table directly.
5623   12C8 CD 39 0C            CALL    L0C0A           ; routine PO-MSG puts
5624   12CB                                             ; '(c) 1982 Sinclair Research Ltd'
5625   12CB                                             ; at bottom of display.
5626   12CB FD CB 02 EE         SET     5,(IY+$02)      ; update TV_FLAG  - signal lower screen will
5627   12CF                                             ; require clearing.
5628   12CF             
5629   12CF 18 07               JR      L12A9           ; forward to MAIN-1
5630   12D1             
5631   12D1             ; -------------------------
5632   12D1             ; THE 'MAIN EXECUTION LOOP'
5633   12D1             ; -------------------------
5634   12D1             ;
5635   12D1             ;
5636   12D1             
5637   12D1             ;; MAIN-EXEC
5638   12D1 FD 36 31 02 L12A2:  LD      (IY+$31),$02    ; set DF_SZ lower screen display file size to 
5639   12D5                                             ; two lines.
5640   12D5 CD C4 17            CALL    L1795           ; routine AUTO-LIST
5641   12D8             
5642   12D8             ;; MAIN-1
5643   12D8 CD DF 16    L12A9:  CALL    L16B0           ; routine SET-MIN clears work areas.
5644   12DB             
5645   12DB             ;; MAIN-2
5646   12DB 3E 00       L12AC:  LD      A,$00           ; select channel 'K' the keyboard
5647   12DD             
5648   12DD CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it
5649   12E0             
5650   12E0 CD 5B 0F            CALL    L0F2C           ; routine EDITOR is called.
5651   12E3                                             ; Note the above routine is where the Spectrum
5652   12E3                                             ; waits for user-interaction. Perhaps the
5653   12E3                                             ; most common input at this stage
5654   12E3                                             ; is LOAD "".
5655   12E3             
5656   12E3 CD 46 1B            CALL    L1B17           ; routine LINE-SCAN scans the input.
5657   12E6             
5658   12E6 FD CB 00 7E         BIT     7,(IY+$00)      ; test ERR_NR - will be $FF if syntax is OK.
5659   12EA 20 12               JR      NZ,L12CF        ; forward, if correct, to MAIN-3.
5660   12EC             
5661   12EC             ; 
5662   12EC             
5663   12EC FD CB 30 66         BIT     4,(IY+$30)      ; test FLAGS2 - K channel in use ?
5664   12F0 28 40               JR      Z,L1303         ; forward to MAIN-4 if not.
5665   12F2             
5666   12F2             ;
5667   12F2             
5668   12F2 2A 59 5C            LD      HL,($5C59)      ; an editing error so address E_LINE.
5669   12F5 CD D6 11            CALL    L11A7           ; routine REMOVE-FP removes the hidden
5670   12F8                                             ; floating-point forms.
5671   12F8 FD 36 00 FF         LD      (IY+$00),$FF    ; system variable ERR_NR is reset to 'OK'.
5672   12FC 18 DD               JR      L12AC           ; back to MAIN-2 to allow user to correct.
5673   12FE             
5674   12FE             ; ---
5675   12FE             
5676   12FE             ; the branch was here if syntax has passed test.
5677   12FE             
5678   12FE             ;; MAIN-3
5679   12FE 2A 59 5C    L12CF:  LD      HL,($5C59)      ; fetch the edit line address from E_LINE.
5680   1301             
5681   1301 22 5D 5C            LD      ($5C5D),HL      ; system variable CH_ADD is set to first
5682   1304                                             ; character of edit line.
5683   1304                                             ; Note. the above two instructions are a little
5684   1304                                             ; inadequate. 
5685   1304                                             ; They are repeated with a subtle difference 
5686   1304                                             ; at the start of the next subroutine and are 
5687   1304                                             ; therefore not required above.
5688   1304             
5689   1304 CD 2A 1A            CALL    L19FB           ; routine E-LINE-NO will fetch any line
5690   1307                                             ; number to BC if this is a program line.
5691   1307             
5692   1307 78                  LD      A,B             ; test if the number of
5693   1308 B1                  OR      C               ; the line is non-zero.
5694   1309 C2 8C 15            JP      NZ,L155D        ; jump forward to MAIN-ADD if so to add the 
5695   130C                                             ; line to the BASIC program.
5696   130C             
5697   130C             ; Has the user just pressed the ENTER key ?
5698   130C             
5699   130C DF                  RST     18H             ; GET-CHAR gets character addressed by CH_ADD.
5700   130D FE 0D               CP      $0D             ; is it a carriage return ?
5701   130F 28 C0               JR      Z,L12A2         ; back to MAIN-EXEC if so for an automatic
5702   1311                                             ; listing.
5703   1311             
5704   1311             ; this must be a direct command.
5705   1311             
5706   1311 FD CB 30 46         BIT     0,(IY+$30)      ; test FLAGS2 - clear the main screen ?
5707   1315             
5708   1315 C4 DE 0D            CALL    NZ,L0DAF        ; routine CL-ALL, if so, e.g. after listing.
5709   1318             
5710   1318 CD 9D 0D            CALL    L0D6E           ; routine CLS-LOWER anyway.
5711   131B             
5712   131B 3E 19               LD      A,$19           ; compute scroll count as 25 minus
5713   131D FD 96 4F            SUB     (IY+$4F)        ; value of S_POSN_hi.
5714   1320 32 8C 5C            LD      ($5C8C),A       ; update SCR_CT system variable.
5715   1323 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS - signal running program.
5716   1327 FD 36 00 FF         LD      (IY+$00),$FF    ; set ERR_NR to 'OK'.
5717   132B FD 36 0A 01         LD      (IY+$0A),$01    ; set NSPPC to one for first statement.
5718   132F CD B9 1B            CALL    L1B8A           ; call routine LINE-RUN to run the line.
5719   1332                                             ; sysvar ERR_SP therefore addresses MAIN-4
5720   1332             
5721   1332             ; Examples of direct commands are RUN, CLS, LOAD "", PRINT USR 40000,
5722   1332             ; LPRINT "A"; etc..
5723   1332             ; If a user written machine-code program disables interrupts then it
5724   1332             ; must enable them to pass the next step. We also jumped to here if the
5725   1332             ; keyboard was not being used.
5726   1332             
5727   1332             ;; MAIN-4
5728   1332 76          L1303:  HALT                    ; wait for interrupt the only routine that can
5729   1333                                             ; set bit 5 of FLAGS.
5730   1333             
5731   1333 FD CB 01 AE         RES     5,(IY+$01)      ; update bit 5 of FLAGS - signal no new key.
5732   1337             
5733   1337 FD CB 30 4E         BIT     1,(IY+$30)      ; test FLAGS2 - is printer buffer clear ?
5734   133B C4 FC 0E            CALL    NZ,L0ECD        ; call routine COPY-BUFF if not.
5735   133E                                             ; Note. the programmer has neglected
5736   133E                                             ; to set bit 1 of FLAGS first.
5737   133E             
5738   133E 3A 3A 5C            LD      A,($5C3A)       ; fetch ERR_NR
5739   1341 3C                  INC     A               ; increment to give true code.
5740   1342             
5741   1342             ; Now deal with a runtime error as opposed to an editing error.
5742   1342             ; However if the error code is now zero then the OK message will be printed.
5743   1342             
5744   1342             ;; MAIN-G
5745   1342 F5          L1313:  PUSH    AF              ; save the error number.
5746   1343             
5747   1343 21 00 00            LD      HL,$0000        ; prepare to clear some system variables.
5748   1346 FD 74 37            LD      (IY+$37),H      ; clear all the bits of FLAGX.
5749   1349 FD 74 26            LD      (IY+$26),H      ; blank X_PTR_hi to suppress error marker.
5750   134C 22 0B 5C            LD      ($5C0B),HL      ; blank DEFADD to signal that no defined
5751   134F                                             ; function is currently being evaluated.
5752   134F             
5753   134F 21 01 00            LD      HL,$0001        ; explicit - inc hl would do.
5754   1352 22 16 5C            LD      ($5C16),HL      ; ensure STRMS-00 is keyboard.
5755   1355             
5756   1355 CD DF 16            CALL    L16B0           ; routine SET-MIN clears workspace etc.
5757   1358 FD CB 37 AE         RES     5,(IY+$37)      ; update FLAGX - signal in EDIT not INPUT mode.
5758   135C                                             ; Note. all the bits were reset earlier.
5759   135C             
5760   135C CD 9D 0D            CALL    L0D6E           ; call routine CLS-LOWER.
5761   135F             
5762   135F FD CB 02 EE         SET     5,(IY+$02)      ; update TV_FLAG - signal lower screen
5763   1363                                             ; requires clearing.
5764   1363             
5765   1363 F1                  POP     AF              ; bring back the true error number
5766   1364 47                  LD      B,A             ; and make a copy in B.
5767   1365 FE 0A               CP      $0A             ; is it a print-ready digit ?
5768   1367 38 02               JR      C,L133C         ; forward to MAIN-5 if so.
5769   1369             
5770   1369 C6 07               ADD     A,$07           ; add ASCII offset to letters.
5771   136B             
5772   136B             ;; MAIN-5
5773   136B CD 1E 16    L133C:  CALL    L15EF           ; call routine OUT-CODE to print the code.
5774   136E             
5775   136E 3E 20               LD      A,$20           ; followed by a space.
5776   1370 D7                  RST     10H             ; PRINT-A
5777   1371             
5778   1371 78                  LD      A,B             ; fetch stored report code.
5779   1372 11 C0 13            LD      DE,L1391        ; address: rpt-mesgs.
5780   1375             
5781   1375 CD 39 0C            CALL    L0C0A           ; call routine PO-MSG to print the message.
5782   1378             
5783   1378 AF          X1349:  XOR     A               ; clear accumulator to directly
5784   1379 11 65 15            LD      DE,L1537 - 1    ; address the comma and space message.  
5785   137C             
5786   137C CD 39 0C            CALL    L0C0A           ; routine PO-MSG prints ', ' although it would
5787   137F                                             ; be more succinct to use RST $10.
5788   137F             
5789   137F ED 4B 45 5C         LD      BC,($5C45)      ; fetch PPC the current line number.
5790   1383 CD 4A 1A            CALL    L1A1B           ; routine OUT-NUM-1 will print that
5791   1386             
5792   1386 3E 3A               LD      A,$3A           ; then a ':' character.
5793   1388 D7                  RST     10H             ; PRINT-A
5794   1389             
5795   1389 FD 4E 0D            LD      C,(IY+$0D)      ; then SUBPPC for statement
5796   138C 06 00               LD      B,$00           ; limited to 127
5797   138E CD 4A 1A            CALL    L1A1B           ; routine OUT-NUM-1 prints BC.
5798   1391             
5799   1391 CD C6 10            CALL    L1097           ; routine CLEAR-SP clears editing area which 
5800   1394                                             ; probably contained 'RUN'.
5801   1394             
5802   1394 3A 3A 5C            LD      A,($5C3A)       ; fetch ERR_NR again
5803   1397 3C                  INC     A               ; test for no error originally $FF.
5804   1398 28 1B               JR      Z,L1386         ; forward to MAIN-9 if no error.
5805   139A             
5806   139A FE 09               CP      $09             ; is code Report 9 STOP ?
5807   139C 28 04               JR      Z,L1373         ; forward to MAIN-6 if so
5808   139E             
5809   139E FE 15               CP      $15             ; is code Report L Break ?
5810   13A0 20 03               JR      NZ,L1376        ; forward to MAIN-7 if not
5811   13A2             
5812   13A2             ; Stop or Break was encountered so consider CONTINUE.
5813   13A2             
5814   13A2             ;; MAIN-6
5815   13A2 FD 34 0D    L1373:  INC     (IY+$0D)        ; increment SUBPPC to next statement.
5816   13A5             
5817   13A5             ;; MAIN-7
5818   13A5 01 03 00    L1376:  LD      BC,$0003        ; prepare to copy 3 system variables to
5819   13A8 11 70 5C            LD      DE,$5C70        ; address OSPPC - statement for CONTINUE.
5820   13AB                                             ; also updating OLDPPC line number below.
5821   13AB             
5822   13AB 21 44 5C            LD      HL,$5C44        ; set source top to NSPPC next statement.
5823   13AE CB 7E               BIT     7,(HL)          ; did BREAK occur before the jump ?
5824   13B0                                             ; e.g. between GO TO and next statement.
5825   13B0 28 01               JR      Z,L1384         ; skip forward to MAIN-8, if not, as set-up
5826   13B2                                             ; is correct.
5827   13B2             
5828   13B2 09                  ADD     HL,BC           ; set source to SUBPPC number of current
5829   13B3                                             ; statement/line which will be repeated.
5830   13B3             
5831   13B3             ;; MAIN-8
5832   13B3 ED B8       L1384:  LDDR                    ; copy PPC to OLDPPC and SUBPPC to OSPCC
5833   13B5                                             ; or NSPPC to OLDPPC and NEWPPC to OSPCC
5834   13B5             
5835   13B5             ;; MAIN-9
5836   13B5 FD 36 0A FF L1386:  LD      (IY+$0A),$FF    ; update NSPPC - signal 'no jump'.
5837   13B9 FD CB 01 9E         RES     3,(IY+$01)      ; update FLAGS - signal use 'K' mode for
5838   13BD                                             ; the first character in the editor and
5839   13BD             
5840   13BD C3 DB 12            JP      L12AC           ; jump back to MAIN-2.
5841   13C0             
5842   13C0             
5843   13C0             ; ----------------------
5844   13C0             ; Canned report messages
5845   13C0             ; ----------------------
5846   13C0             ; The Error reports with the last byte inverted. The first entry
5847   13C0             ; is a dummy entry. The last, which begins with $7F, the Spectrum
5848   13C0             ; character for copyright symbol, is placed here for convenience
5849   13C0             ; as is the preceding comma and space.
5850   13C0             ; The report line must accommodate a 4-digit line number and a 3-digit
5851   13C0             ; statement number which limits the length of the message text to twenty 
5852   13C0             ; characters.
5853   13C0             ; e.g.  "B Integer out of range, 1000:127"
5854   13C0             
5855   13C0             ;; rpt-mesgs
5856   13C0 80          L1391:  DEFB    $80
5857   13C1 4F CB               DEFB    'O','K'+$80                             ; 0
5858   13C3 4E 45 58 54         DEFM    "NEXT without FO"
5858   13C7 20 77 69 74 
5858   13CB 68 6F 75 74 
5858   13CF 20 46 4F 
5859   13D2 D2                  DEFB    'R'+$80                                 ; 1
5860   13D3 56 61 72 69         DEFM    "Variable not foun"
5860   13D7 61 62 6C 65 
5860   13DB 20 6E 6F 74 
5860   13DF 20 66 6F 75 
5860   13E3 6E 
5861   13E4 E4                  DEFB    'd'+$80                                 ; 2
5862   13E5 53 75 62 73         DEFM    "Subscript wron"
5862   13E9 63 72 69 70 
5862   13ED 74 20 77 72 
5862   13F1 6F 6E 
5863   13F3 E7                  DEFB    'g'+$80                                 ; 3
5864   13F4 4F 75 74 20         DEFM    "Out of memor"
5864   13F8 6F 66 20 6D 
5864   13FC 65 6D 6F 72 
5865   1400 F9                  DEFB    'y'+$80                                 ; 4
5866   1401 4F 75 74 20         DEFM    "Out of scree"
5866   1405 6F 66 20 73 
5866   1409 63 72 65 65 
5867   140D EE                  DEFB    'n'+$80                                 ; 5
5868   140E 4E 75 6D 62         DEFM    "Number too bi"
5868   1412 65 72 20 74 
5868   1416 6F 6F 20 62 
5868   141A 69 
5869   141B E7                  DEFB    'g'+$80                                 ; 6
5870   141C 52 45 54 55         DEFM    "RETURN without GOSU"
5870   1420 52 4E 20 77 
5870   1424 69 74 68 6F 
5870   1428 75 74 20 47 
5870   142C 4F 53 55 
5871   142F C2                  DEFB    'B'+$80                                 ; 7
5872   1430 45 6E 64 20         DEFM    "End of fil"
5872   1434 6F 66 20 66 
5872   1438 69 6C 
5873   143A E5                  DEFB    'e'+$80                                 ; 8
5874   143B 53 54 4F 50         DEFM    "STOP statemen"
5874   143F 20 73 74 61 
5874   1443 74 65 6D 65 
5874   1447 6E 
5875   1448 F4                  DEFB    't'+$80                                 ; 9
5876   1449 49 6E 76 61         DEFM    "Invalid argumen"
5876   144D 6C 69 64 20 
5876   1451 61 72 67 75 
5876   1455 6D 65 6E 
5877   1458 F4                  DEFB    't'+$80                                 ; A
5878   1459 49 6E 74 65         DEFM    "Integer out of rang"
5878   145D 67 65 72 20 
5878   1461 6F 75 74 20 
5878   1465 6F 66 20 72 
5878   1469 61 6E 67 
5879   146C E5                  DEFB    'e'+$80                                 ; B
5880   146D 4E 6F 6E 73         DEFM    "Nonsense in BASI"
5880   1471 65 6E 73 65 
5880   1475 20 69 6E 20 
5880   1479 42 41 53 49 
5881   147D C3                  DEFB    'C'+$80                                 ; C
5882   147E 42 52 45 41         DEFM    "BREAK - CONT repeat"
5882   1482 4B 20 2D 20 
5882   1486 43 4F 4E 54 
5882   148A 20 72 65 70 
5882   148E 65 61 74 
5883   1491 F3                  DEFB    's'+$80                                 ; D
5884   1492 4F 75 74 20         DEFM    "Out of DAT"
5884   1496 6F 66 20 44 
5884   149A 41 54 
5885   149C C1                  DEFB    'A'+$80                                 ; E
5886   149D 49 6E 76 61         DEFM    "Invalid file nam"
5886   14A1 6C 69 64 20 
5886   14A5 66 69 6C 65 
5886   14A9 20 6E 61 6D 
5887   14AD E5                  DEFB    'e'+$80                                 ; F
5888   14AE 4E 6F 20 72         DEFM    "No room for lin"
5888   14B2 6F 6F 6D 20 
5888   14B6 66 6F 72 20 
5888   14BA 6C 69 6E 
5889   14BD E5                  DEFB    'e'+$80                                 ; G
5890   14BE 53 54 4F 50         DEFM    "STOP in INPU"
5890   14C2 20 69 6E 20 
5890   14C6 49 4E 50 55 
5891   14CA D4                  DEFB    'T'+$80                                 ; H
5892   14CB 46 4F 52 20         DEFM    "FOR without NEX"
5892   14CF 77 69 74 68 
5892   14D3 6F 75 74 20 
5892   14D7 4E 45 58 
5893   14DA D4                  DEFB    'T'+$80                                 ; I
5894   14DB 49 6E 76 61         DEFM    "Invalid I/O devic"
5894   14DF 6C 69 64 20 
5894   14E3 49 2F 4F 20 
5894   14E7 64 65 76 69 
5894   14EB 63 
5895   14EC E5                  DEFB    'e'+$80                                 ; J
5896   14ED 49 6E 76 61         DEFM    "Invalid colou"
5896   14F1 6C 69 64 20 
5896   14F5 63 6F 6C 6F 
5896   14F9 75 
5897   14FA F2                  DEFB    'r'+$80                                 ; K
5898   14FB 42 52 45 41         DEFM    "BREAK into progra"
5898   14FF 4B 20 69 6E 
5898   1503 74 6F 20 70 
5898   1507 72 6F 67 72 
5898   150B 61 
5899   150C ED                  DEFB    'm'+$80                                 ; L
5900   150D 52 41 4D 54         DEFM    "RAMTOP no goo"
5900   1511 4F 50 20 6E 
5900   1515 6F 20 67 6F 
5900   1519 6F 
5901   151A E4                  DEFB    'd'+$80                                 ; M
5902   151B 53 74 61 74         DEFM    "Statement los"
5902   151F 65 6D 65 6E 
5902   1523 74 20 6C 6F 
5902   1527 73 
5903   1528 F4                  DEFB    't'+$80                                 ; N
5904   1529 49 6E 76 61         DEFM    "Invalid strea"
5904   152D 6C 69 64 20 
5904   1531 73 74 72 65 
5904   1535 61 
5905   1536 ED                  DEFB    'm'+$80                                 ; O
5906   1537 46 4E 20 77         DEFM    "FN without DE"
5906   153B 69 74 68 6F 
5906   153F 75 74 20 44 
5906   1543 45 
5907   1544 C6                  DEFB    'F'+$80                                 ; P
5908   1545 50 61 72 61         DEFM    "Parameter erro"
5908   1549 6D 65 74 65 
5908   154D 72 20 65 72 
5908   1551 72 6F 
5909   1553 F2                  DEFB    'r'+$80                                 ; Q
5910   1554 54 61 70 65         DEFM    "Tape loading erro"
5910   1558 20 6C 6F 61 
5910   155C 64 69 6E 67 
5910   1560 20 65 72 72 
5910   1564 6F 
5911   1565 F2                  DEFB    'r'+$80                                 ; R
5912   1566             ;; comma-sp   
5913   1566 2C A0       L1537:  DEFB    ',',' '+$80                             ; used in report line.
5914   1568             ;; copyright
5915   1568 7F          L1539:  DEFB    $7F                                     ; copyright
5916   1569 20 31 39 38         DEFM    " 1982 Sinclair Research Lt"
5916   156D 32 20 53 69 
5916   1571 6E 63 6C 61 
5916   1575 69 72 20 52 
5916   1579 65 73 65 61 
5916   157D 72 63 68 20 
5916   1581 4C 74 
5917   1583 E4                  DEFB    'd'+$80
5918   1584             
5919   1584             
5920   1584             ; -------------
5921   1584             ; REPORT-G
5922   1584             ; -------------
5923   1584             ; Note ERR_SP points here during line entry which allows the
5924   1584             ; normal 'Out of Memory' report to be augmented to the more
5925   1584             ; precise 'No Room for line' report.
5926   1584             
5927   1584             ;; REPORT-G
5928   1584             ; No Room for line
5929   1584 3E 10       L1555:  LD      A,$10           ; i.e. 'G' -$30 -$07
5930   1586 01 00 00            LD      BC,$0000        ; this seems unnecessary.
5931   1589 C3 42 13            JP      L1313           ; jump back to MAIN-G
5932   158C             
5933   158C             ; -----------------------------
5934   158C             ; Handle addition of BASIC line
5935   158C             ; -----------------------------
5936   158C             ; Note this is not a subroutine but a branch of the main execution loop.
5937   158C             ; System variable ERR_SP still points to editing error handler.
5938   158C             ; A new line is added to the BASIC program at the appropriate place.
5939   158C             ; An existing line with same number is deleted first.
5940   158C             ; Entering an existing line number deletes that line.
5941   158C             ; Entering a non-existent line allows the subsequent line to be edited next.
5942   158C             
5943   158C             ;; MAIN-ADD
5944   158C ED 43 49 5C L155D:  LD      ($5C49),BC      ; set E_PPC to extracted line number.
5945   1590 2A 5D 5C            LD      HL,($5C5D)      ; fetch CH_ADD - points to location after the
5946   1593                                             ; initial digits (set in E_LINE_NO).
5947   1593 EB                  EX      DE,HL           ; save start of BASIC in DE.
5948   1594             
5949   1594 21 84 15            LD      HL,L1555        ; Address: REPORT-G
5950   1597 E5                  PUSH    HL              ; is pushed on stack and addressed by ERR_SP.
5951   1598                                             ; the only error that can occur is
5952   1598                                             ; 'Out of memory'.
5953   1598             
5954   1598 2A 61 5C            LD      HL,($5C61)      ; fetch WORKSP - end of line.
5955   159B 37                  SCF                     ; prepare for true subtraction.
5956   159C ED 52               SBC     HL,DE           ; find length of BASIC and
5957   159E E5                  PUSH    HL              ; save it on stack.
5958   159F 60                  LD      H,B             ; transfer line number
5959   15A0 69                  LD      L,C             ; to HL register.
5960   15A1 CD 9D 19            CALL    L196E           ; routine LINE-ADDR will see if
5961   15A4                                             ; a line with the same number exists.
5962   15A4 20 06               JR      NZ,L157D        ; forward if no existing line to MAIN-ADD1.
5963   15A6             
5964   15A6 CD E7 19            CALL    L19B8           ; routine NEXT-ONE finds the existing line.
5965   15A9 CD 17 1A            CALL    L19E8           ; routine RECLAIM-2 reclaims it.
5966   15AC             
5967   15AC             ;; MAIN-ADD1
5968   15AC C1          L157D:  POP     BC              ; retrieve the length of the new line.
5969   15AD 79                  LD      A,C             ; and test if carriage return only
5970   15AE 3D                  DEC     A               ; i.e. one byte long.
5971   15AF B0                  OR      B               ; result would be zero.
5972   15B0 28 28               JR      Z,L15AB         ; forward to MAIN-ADD2 is so.
5973   15B2             
5974   15B2 C5                  PUSH    BC              ; save the length again.
5975   15B3 03                  INC     BC              ; adjust for inclusion
5976   15B4 03                  INC     BC              ; of line number (two bytes)
5977   15B5 03                  INC     BC              ; and line length
5978   15B6 03                  INC     BC              ; (two bytes).
5979   15B7 2B                  DEC     HL              ; HL points to location before the destination
5980   15B8             
5981   15B8 ED 5B 53 5C         LD      DE,($5C53)      ; fetch the address of PROG
5982   15BC D5                  PUSH    DE              ; and save it on the stack
5983   15BD CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates BC spaces in
5984   15C0                                             ; program area and updates pointers.
5985   15C0 E1                  POP     HL              ; restore old program pointer.
5986   15C1 22 53 5C            LD      ($5C53),HL      ; and put back in PROG as it may have been
5987   15C4                                             ; altered by the POINTERS routine.
5988   15C4             
5989   15C4 C1                  POP     BC              ; retrieve BASIC length
5990   15C5 C5                  PUSH    BC              ; and save again.
5991   15C6             
5992   15C6 13                  INC     DE              ; points to end of new area.
5993   15C7 2A 61 5C            LD      HL,($5C61)      ; set HL to WORKSP - location after edit line.
5994   15CA 2B                  DEC     HL              ; decrement to address end marker.
5995   15CB 2B                  DEC     HL              ; decrement to address carriage return.
5996   15CC ED B8               LDDR                    ; copy the BASIC line back to initial command.
5997   15CE             
5998   15CE 2A 49 5C            LD      HL,($5C49)      ; fetch E_PPC - line number.
5999   15D1 EB                  EX      DE,HL           ; swap it to DE, HL points to last of
6000   15D2                                             ; four locations.
6001   15D2 C1                  POP     BC              ; retrieve length of line.
6002   15D3 70                  LD      (HL),B          ; high byte last.
6003   15D4 2B                  DEC     HL              ;
6004   15D5 71                  LD      (HL),C          ; then low byte of length.
6005   15D6 2B                  DEC     HL              ;
6006   15D7 73                  LD      (HL),E          ; then low byte of line number.
6007   15D8 2B                  DEC     HL              ;
6008   15D9 72                  LD      (HL),D          ; then high byte range $0 - $27 (1-9999).
6009   15DA             
6010   15DA             ;; MAIN-ADD2
6011   15DA F1          L15AB:  POP     AF              ; drop the address of Report G
6012   15DB C3 D1 12            JP      L12A2           ; and back to MAIN-EXEC producing a listing
6013   15DE                                             ; and to reset ERR_SP in EDITOR.
6014   15DE             
6015   15DE             
6016   15DE             ; ---------------------------------
6017   15DE             ; THE 'INITIAL CHANNEL' INFORMATION
6018   15DE             ; ---------------------------------
6019   15DE             ;   This initial channel information is copied from ROM to RAM, during 
6020   15DE             ;   initialization.  It's new location is after the system variables and is 
6021   15DE             ;   addressed by the system variable CHANS which means that it can slide up and
6022   15DE             ;   down in memory.  The table is never searched, by this ROM, and the last 
6023   15DE             ;   character, which could be anything other than a comma, provides a 
6024   15DE             ;   convenient resting place for DATADD.
6025   15DE             
6026   15DE             ;; init-chan
6027   15DE 23 0A       L15AF:  DEFW    L09F4           ; PRINT-OUT
6028   15E0 D7 10               DEFW    L10A8           ; KEY-INPUT
6029   15E2 4B                  DEFB    $4B             ; 'K'
6030   15E3 23 0A               DEFW    L09F4           ; PRINT-OUT
6031   15E5 F3 15               DEFW    L15C4           ; REPORT-J
6032   15E7 53                  DEFB    $53             ; 'S'
6033   15E8 B0 0F               DEFW    L0F81           ; ADD-CHAR
6034   15EA F3 15               DEFW    L15C4           ; REPORT-J
6035   15EC 52                  DEFB    $52             ; 'R'
6036   15ED 23 0A               DEFW    L09F4           ; PRINT-OUT
6037   15EF F3 15               DEFW    L15C4           ; REPORT-J
6038   15F1 50                  DEFB    $50             ; 'P'
6039   15F2             
6040   15F2 80                  DEFB    $80             ; End Marker
6041   15F3             
6042   15F3             ;; REPORT-J
6043   15F3 CF          L15C4:  RST     08H             ; ERROR-1
6044   15F4 12                  DEFB    $12             ; Error Report: Invalid I/O device
6045   15F5             
6046   15F5             
6047   15F5             ; -------------------------
6048   15F5             ; THE 'INITIAL STREAM' DATA
6049   15F5             ; -------------------------
6050   15F5             ;   This is the initial stream data for the seven streams $FD - $03 that is
6051   15F5             ;   copied from ROM to the STRMS system variables area during initialization.
6052   15F5             ;   There are reserved locations there for another 12 streams.  Each location 
6053   15F5             ;   contains an offset to the second byte of a channel.  The first byte of a 
6054   15F5             ;   channel can't be used as that would result in an offset of zero for some 
6055   15F5             ;   and zero is used to denote that a stream is closed.
6056   15F5             
6057   15F5             ;; init-strm
6058   15F5 01 00       L15C6:  DEFB    $01, $00        ; stream $FD offset to channel 'K'
6059   15F7 06 00               DEFB    $06, $00        ; stream $FE offset to channel 'S'
6060   15F9 0B 00               DEFB    $0B, $00        ; stream $FF offset to channel 'R'
6061   15FB             
6062   15FB 01 00               DEFB    $01, $00        ; stream $00 offset to channel 'K'
6063   15FD 01 00               DEFB    $01, $00        ; stream $01 offset to channel 'K'
6064   15FF 06 00               DEFB    $06, $00        ; stream $02 offset to channel 'S'
6065   1601 10 00               DEFB    $10, $00        ; stream $03 offset to channel 'P'
6066   1603             
6067   1603             ; ------------------------------
6068   1603             ; THE 'INPUT CONTROL' SUBROUTINE
6069   1603             ; ------------------------------
6070   1603             ;
6071   1603             
6072   1603             ;; WAIT-KEY
6073   1603 FD CB 02 6E L15D4:  BIT     5,(IY+$02)      ; test TV_FLAG - clear lower screen ?
6074   1607 20 04               JR      NZ,L15DE        ; forward to WAIT-KEY1 if so.
6075   1609             
6076   1609 FD CB 02 DE         SET     3,(IY+$02)      ; update TV_FLAG - signal reprint the edit
6077   160D                                             ; line to the lower screen.
6078   160D             
6079   160D             ;; WAIT-KEY1
6080   160D CD 15 16    L15DE:  CALL    L15E6           ; routine INPUT-AD is called.
6081   1610             
6082   1610 D8                  RET     C               ; return with acceptable keys.
6083   1611             
6084   1611 28 FA               JR      Z,L15DE         ; back to WAIT-KEY1 if no key is pressed
6085   1613                                             ; or it has been handled within INPUT-AD.
6086   1613             
6087   1613             ;   Note. When inputting from the keyboard all characters are returned with
6088   1613             ;   above conditions so this path is never taken.
6089   1613             
6090   1613             ;; REPORT-8
6091   1613 CF          L15E4:  RST     08H             ; ERROR-1
6092   1614 07                  DEFB    $07             ; Error Report: End of file
6093   1615             
6094   1615             ; ---------------------------
6095   1615             ; THE 'INPUT ADDRESS' ROUTINE
6096   1615             ; ---------------------------
6097   1615             ;   This routine fetches the address of the input stream from the current 
6098   1615             ;   channel area using the system variable CURCHL.
6099   1615             
6100   1615             ;; INPUT-AD
6101   1615 D9          L15E6:  EXX                     ; switch in alternate set.
6102   1616 E5                  PUSH    HL              ; save HL register
6103   1617 2A 51 5C            LD      HL,($5C51)      ; fetch address of CURCHL - current channel.
6104   161A 23                  INC     HL              ; step over output routine
6105   161B 23                  INC     HL              ; to point to low byte of input routine.
6106   161C 18 08               JR      L15F7           ; forward to CALL-SUB.
6107   161E             
6108   161E             ; -------------------------
6109   161E             ; THE 'CODE OUTPUT' ROUTINE
6110   161E             ; -------------------------
6111   161E             ;   This routine is called on five occasions to print the ASCII equivalent of 
6112   161E             ;   a value 0-9.
6113   161E             
6114   161E             ;; OUT-CODE
6115   161E 1E 30       L15EF:  LD      E,$30           ; add 48 decimal to give the ASCII character 
6116   1620 83                  ADD     A,E             ; '0' to '9' and continue into the main output
6117   1621                                             ; routine.
6118   1621             
6119   1621             ; -------------------------
6120   1621             ; THE 'MAIN OUTPUT' ROUTINE
6121   1621             ; -------------------------
6122   1621             ;   PRINT-A-2 is a continuation of the RST 10 restart that prints any character.
6123   1621             ;   The routine prints to the current channel and the printing of control codes
6124   1621             ;   may alter that channel to divert subsequent RST 10 instructions to temporary
6125   1621             ;   routines. The normal channel is $09F4.
6126   1621             
6127   1621             ;; PRINT-A-2
6128   1621 D9          L15F2:  EXX                     ; switch in alternate set
6129   1622 E5                  PUSH    HL              ; save HL register
6130   1623 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL the current channel.
6131   1626             
6132   1626             ; input-ad rejoins here also.
6133   1626             
6134   1626             ;; CALL-SUB
6135   1626 5E          L15F7:  LD      E,(HL)          ; put the low byte in E.
6136   1627 23                  INC     HL              ; advance address.
6137   1628 56                  LD      D,(HL)          ; put the high byte to D.
6138   1629 EB                  EX      DE,HL           ; transfer the stream to HL.
6139   162A CD 5B 16            CALL    L162C           ; use routine CALL-JUMP.
6140   162D                                             ; in effect CALL (HL).
6141   162D             
6142   162D E1                  POP     HL              ; restore saved HL register.
6143   162E D9                  EXX                     ; switch back to the main set and
6144   162F C9                  RET                     ; return.
6145   1630             
6146   1630             ; --------------------------
6147   1630             ; THE 'OPEN CHANNEL' ROUTINE
6148   1630             ; --------------------------
6149   1630             ;   This subroutine is used by the ROM to open a channel 'K', 'S', 'R' or 'P'.
6150   1630             ;   This is either for its own use or in response to a user's request, for
6151   1630             ;   example, when '#' is encountered with output - PRINT, LIST etc.
6152   1630             ;   or with input - INPUT, INKEY$ etc.
6153   1630             ;   It is entered with a system stream $FD - $FF, or a user stream $00 - $0F
6154   1630             ;   in the accumulator.
6155   1630             
6156   1630             ;; CHAN-OPEN
6157   1630 87          L1601:  ADD     A,A             ; double the stream ($FF will become $FE etc.)
6158   1631 C6 16               ADD     A,$16           ; add the offset to stream 0 from $5C00
6159   1633 6F                  LD      L,A             ; result to L
6160   1634 26 5C               LD      H,$5C           ; now form the address in STRMS area.
6161   1636 5E                  LD      E,(HL)          ; fetch low byte of CHANS offset
6162   1637 23                  INC     HL              ; address next
6163   1638 56                  LD      D,(HL)          ; fetch high byte of offset
6164   1639 7A                  LD      A,D             ; test that the stream is open.
6165   163A B3                  OR      E               ; zero if closed.
6166   163B 20 02               JR      NZ,L1610        ; forward to CHAN-OP-1 if open.
6167   163D             
6168   163D             ;; REPORT-Oa
6169   163D CF          L160E:  RST     08H             ; ERROR-1
6170   163E 17                  DEFB    $17             ; Error Report: Invalid stream
6171   163F             
6172   163F             ; continue here if stream was open. Note that the offset is from CHANS
6173   163F             ; to the second byte of the channel.
6174   163F             
6175   163F             ;; CHAN-OP-1
6176   163F 1B          L1610:  DEC     DE              ; reduce offset so it points to the channel.
6177   1640 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS the location of the base of
6178   1643                                             ; the channel information area
6179   1643 19                  ADD     HL,DE           ; and add the offset to address the channel.
6180   1644                                             ; and continue to set flags.
6181   1644             
6182   1644             ; -----------------
6183   1644             ; Set channel flags
6184   1644             ; -----------------
6185   1644             ; This subroutine is used from ED-EDIT, str$ and read-in to reset the
6186   1644             ; current channel when it has been temporarily altered.
6187   1644             
6188   1644             ;; CHAN-FLAG
6189   1644 22 51 5C    L1615:  LD      ($5C51),HL      ; set CURCHL system variable to the
6190   1647                                             ; address in HL
6191   1647 FD CB 30 A6         RES     4,(IY+$30)      ; update FLAGS2  - signal K channel not in use.
6192   164B                                             ; Note. provide a default for channel 'R'.
6193   164B 23                  INC     HL              ; advance past
6194   164C 23                  INC     HL              ; output routine.
6195   164D 23                  INC     HL              ; advance past
6196   164E 23                  INC     HL              ; input routine.
6197   164F 4E                  LD      C,(HL)          ; pick up the letter.
6198   1650 21 5C 16            LD      HL,L162D        ; address: chn-cd-lu
6199   1653 CD 0B 17            CALL    L16DC           ; routine INDEXER finds offset to a
6200   1656                                             ; flag-setting routine.
6201   1656             
6202   1656 D0                  RET     NC              ; but if the letter wasn't found in the
6203   1657                                             ; table just return now. - channel 'R'.
6204   1657             
6205   1657 16 00               LD      D,$00           ; prepare to add
6206   1659 5E                  LD      E,(HL)          ; offset to E
6207   165A 19                  ADD     HL,DE           ; add offset to location of offset to form
6208   165B                                             ; address of routine
6209   165B             
6210   165B             ;; CALL-JUMP
6211   165B E9          L162C:  JP      (HL)            ; jump to the routine
6212   165C             
6213   165C             ; Footnote. calling any location that holds JP (HL) is the equivalent to
6214   165C             ; a pseudo Z80 instruction CALL (HL). The ROM uses the instruction above.
6215   165C             
6216   165C             ; --------------------------
6217   165C             ; Channel code look-up table
6218   165C             ; --------------------------
6219   165C             ; This table is used by the routine above to find one of the three
6220   165C             ; flag setting routines below it.
6221   165C             ; A zero end-marker is required as channel 'R' is not present.
6222   165C             
6223   165C             ;; chn-cd-lu
6224   165C 4B 06       L162D:  DEFB    'K', L1634-$-1  ; offset $06 to CHAN-K
6225   165E 53 12               DEFB    'S', L1642-$-1  ; offset $12 to CHAN-S
6226   1660 50 1B               DEFB    'P', L164D-$-1  ; offset $1B to CHAN-P
6227   1662             
6228   1662 00                  DEFB    $00             ; end marker.
6229   1663             
6230   1663             ; --------------
6231   1663             ; Channel K flag
6232   1663             ; --------------
6233   1663             ; routine to set flags for lower screen/keyboard channel.
6234   1663             
6235   1663             ;; CHAN-K
6236   1663 FD CB 02 C6 L1634:  SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
6237   1667 FD CB 01 AE         RES     5,(IY+$01)      ; update FLAGS    - signal no new key
6238   166B FD CB 30 E6         SET     4,(IY+$30)      ; update FLAGS2   - signal K channel in use
6239   166F 18 04               JR      L1646           ; forward to CHAN-S-1 for indirect exit
6240   1671             
6241   1671             ; --------------
6242   1671             ; Channel S flag
6243   1671             ; --------------
6244   1671             ; routine to set flags for upper screen channel.
6245   1671             
6246   1671             ;; CHAN-S
6247   1671 FD CB 02 86 L1642:  RES     0,(IY+$02)      ; TV_FLAG  - signal main screen in use
6248   1675             
6249   1675             ;; CHAN-S-1
6250   1675 FD CB 01 8E L1646:  RES     1,(IY+$01)      ; update FLAGS  - signal printer not in use
6251   1679 C3 7C 0D            JP      L0D4D           ; jump back to TEMPS and exit via that
6252   167C                                             ; routine after setting temporary attributes.
6253   167C             ; --------------
6254   167C             ; Channel P flag
6255   167C             ; --------------
6256   167C             ; This routine sets a flag so that subsequent print related commands
6257   167C             ; print to printer or update the relevant system variables.
6258   167C             ; This status remains in force until reset by the routine above.
6259   167C             
6260   167C             ;; CHAN-P
6261   167C FD CB 01 CE L164D:  SET     1,(IY+$01)      ; update FLAGS  - signal printer in use
6262   1680 C9                  RET                     ; return
6263   1681             
6264   1681             ; --------------------------
6265   1681             ; THE 'ONE SPACE' SUBROUTINE
6266   1681             ; --------------------------
6267   1681             ; This routine is called once only to create a single space
6268   1681             ; in workspace by ADD-CHAR. 
6269   1681             
6270   1681             ;; ONE-SPACE
6271   1681 01 01 00    L1652:  LD      BC,$0001        ; create space for a single character.
6272   1684             
6273   1684             ; ---------
6274   1684             ; Make Room
6275   1684             ; ---------
6276   1684             ; This entry point is used to create BC spaces in various areas such as
6277   1684             ; program area, variables area, workspace etc..
6278   1684             ; The entire free RAM is available to each BASIC statement.
6279   1684             ; On entry, HL addresses where the first location is to be created.
6280   1684             ; Afterwards, HL will point to the location before this.
6281   1684             
6282   1684             ;; MAKE-ROOM
6283   1684 E5          L1655:  PUSH    HL              ; save the address pointer.
6284   1685 CD 34 1F            CALL    L1F05           ; routine TEST-ROOM checks if room
6285   1688                                             ; exists and generates an error if not.
6286   1688 E1                  POP     HL              ; restore the address pointer.
6287   1689 CD 93 16            CALL    L1664           ; routine POINTERS updates the
6288   168C                                             ; dynamic memory location pointers.
6289   168C                                             ; DE now holds the old value of STKEND.
6290   168C 2A 65 5C            LD      HL,($5C65)      ; fetch new STKEND the top destination.
6291   168F             
6292   168F EB                  EX      DE,HL           ; HL now addresses the top of the area to
6293   1690                                             ; be moved up - old STKEND.
6294   1690 ED B8               LDDR                    ; the program, variables, etc are moved up.
6295   1692 C9                  RET                     ; return with new area ready to be populated.
6296   1693                                             ; HL points to location before new area,
6297   1693                                             ; and DE to last of new locations.
6298   1693             
6299   1693             ; -----------------------------------------------
6300   1693             ; Adjust pointers before making or reclaiming room
6301   1693             ; -----------------------------------------------
6302   1693             ; This routine is called by MAKE-ROOM to adjust upwards and by RECLAIM to
6303   1693             ; adjust downwards the pointers within dynamic memory.
6304   1693             ; The fourteen pointers to dynamic memory, starting with VARS and ending 
6305   1693             ; with STKEND, are updated adding BC if they are higher than the position
6306   1693             ; in HL.  
6307   1693             ; The system variables are in no particular order except that STKEND, the first
6308   1693             ; free location after dynamic memory must be the last encountered.
6309   1693             
6310   1693             ;; POINTERS
6311   1693 F5          L1664:  PUSH    AF              ; preserve accumulator.
6312   1694 E5                  PUSH    HL              ; put pos pointer on stack.
6313   1695 21 4B 5C            LD      HL,$5C4B        ; address VARS the first of the
6314   1698 3E 0E               LD      A,$0E           ; fourteen variables to consider.
6315   169A             
6316   169A             ;; PTR-NEXT
6317   169A 5E          L166B:  LD      E,(HL)          ; fetch the low byte of the system variable.
6318   169B 23                  INC     HL              ; advance address.
6319   169C 56                  LD      D,(HL)          ; fetch high byte of the system variable.
6320   169D E3                  EX      (SP),HL         ; swap pointer on stack with the variable
6321   169E                                             ; pointer.
6322   169E A7                  AND     A               ; prepare to subtract.
6323   169F ED 52               SBC     HL,DE           ; subtract variable address
6324   16A1 19                  ADD     HL,DE           ; and add back
6325   16A2 E3                  EX      (SP),HL         ; swap pos with system variable pointer
6326   16A3 30 09               JR      NC,L167F        ; forward to PTR-DONE if var before pos
6327   16A5             
6328   16A5 D5                  PUSH    DE              ; save system variable address.
6329   16A6 EB                  EX      DE,HL           ; transfer to HL
6330   16A7 09                  ADD     HL,BC           ; add the offset
6331   16A8 EB                  EX      DE,HL           ; back to DE
6332   16A9 72                  LD      (HL),D          ; load high byte
6333   16AA 2B                  DEC     HL              ; move back
6334   16AB 73                  LD      (HL),E          ; load low byte
6335   16AC 23                  INC     HL              ; advance to high byte
6336   16AD D1                  POP     DE              ; restore old system variable address.
6337   16AE             
6338   16AE             ;; PTR-DONE
6339   16AE 23          L167F:  INC     HL              ; address next system variable.
6340   16AF 3D                  DEC     A               ; decrease counter.
6341   16B0 20 E8               JR      NZ,L166B        ; back to PTR-NEXT if more.
6342   16B2 EB                  EX      DE,HL           ; transfer old value of STKEND to HL.
6343   16B3                                             ; Note. this has always been updated.
6344   16B3 D1                  POP     DE              ; pop the address of the position.
6345   16B4             
6346   16B4 F1                  POP     AF              ; pop preserved accumulator.
6347   16B5 A7                  AND     A               ; clear carry flag preparing to subtract.
6348   16B6             
6349   16B6 ED 52               SBC     HL,DE           ; subtract position from old stkend 
6350   16B8 44                  LD      B,H             ; to give number of data bytes
6351   16B9 4D                  LD      C,L             ; to be moved.
6352   16BA 03                  INC     BC              ; increment as we also copy byte at old STKEND.
6353   16BB 19                  ADD     HL,DE           ; recompute old stkend.
6354   16BC EB                  EX      DE,HL           ; transfer to DE.
6355   16BD C9                  RET                     ; return.
6356   16BE             
6357   16BE             
6358   16BE             
6359   16BE             ; -------------------
6360   16BE             ; Collect line number
6361   16BE             ; -------------------
6362   16BE             ; This routine extracts a line number, at an address that has previously
6363   16BE             ; been found using LINE-ADDR, and it is entered at LINE-NO. If it encounters
6364   16BE             ; the program 'end-marker' then the previous line is used and if that
6365   16BE             ; should also be unacceptable then zero is used as it must be a direct
6366   16BE             ; command. The program end-marker is the variables end-marker $80, or
6367   16BE             ; if variables exist, then the first character of any variable name.
6368   16BE             
6369   16BE             ;; LINE-ZERO
6370   16BE 00 00       L168F:  DEFB    $00, $00        ; dummy line number used for direct commands
6371   16C0             
6372   16C0             
6373   16C0             ;; LINE-NO-A
6374   16C0 EB          L1691:  EX      DE,HL           ; fetch the previous line to HL and set
6375   16C1 11 BE 16            LD      DE,L168F        ; DE to LINE-ZERO should HL also fail.
6376   16C4             
6377   16C4             ; -> The Entry Point.
6378   16C4             
6379   16C4             ;; LINE-NO
6380   16C4 7E          L1695:  LD      A,(HL)          ; fetch the high byte - max $2F
6381   16C5 E6 C0               AND     $C0             ; mask off the invalid bits.
6382   16C7 20 F7               JR      NZ,L1691        ; to LINE-NO-A if an end-marker.
6383   16C9             
6384   16C9 56                  LD      D,(HL)          ; reload the high byte.
6385   16CA 23                  INC     HL              ; advance address.
6386   16CB 5E                  LD      E,(HL)          ; pick up the low byte.
6387   16CC C9                  RET                     ; return from here.
6388   16CD             
6389   16CD             ; -------------------
6390   16CD             ; Handle reserve room
6391   16CD             ; -------------------
6392   16CD             ; This is a continuation of the restart BC-SPACES
6393   16CD             
6394   16CD             ;; RESERVE
6395   16CD 2A 63 5C    L169E:  LD      HL,($5C63)      ; STKBOT first location of calculator stack
6396   16D0 2B                  DEC     HL              ; make one less than new location
6397   16D1 CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates the room.
6398   16D4 23                  INC     HL              ; address the first new location
6399   16D5 23                  INC     HL              ; advance to second
6400   16D6 C1                  POP     BC              ; restore old WORKSP
6401   16D7 ED 43 61 5C         LD      ($5C61),BC      ; system variable WORKSP was perhaps
6402   16DB                                             ; changed by POINTERS routine.
6403   16DB C1                  POP     BC              ; restore count for return value.
6404   16DC EB                  EX      DE,HL           ; switch. DE = location after first new space
6405   16DD 23                  INC     HL              ; HL now location after new space
6406   16DE C9                  RET                     ; return.
6407   16DF             
6408   16DF             ; ---------------------------
6409   16DF             ; Clear various editing areas
6410   16DF             ; ---------------------------
6411   16DF             ; This routine sets the editing area, workspace and calculator stack
6412   16DF             ; to their minimum configurations as at initialization and indeed this
6413   16DF             ; routine could have been relied on to perform that task.
6414   16DF             ; This routine uses HL only and returns with that register holding
6415   16DF             ; WORKSP/STKBOT/STKEND though no use is made of this. The routines also
6416   16DF             ; reset MEM to its usual place in the systems variable area should it
6417   16DF             ; have been relocated to a FOR-NEXT variable. The main entry point
6418   16DF             ; SET-MIN is called at the start of the MAIN-EXEC loop and prior to
6419   16DF             ; displaying an error.
6420   16DF             
6421   16DF             ;; SET-MIN
6422   16DF 2A 59 5C    L16B0:  LD      HL,($5C59)      ; fetch E_LINE
6423   16E2 36 0D               LD      (HL),$0D        ; insert carriage return
6424   16E4 22 5B 5C            LD      ($5C5B),HL      ; make K_CUR keyboard cursor point there.
6425   16E7 23                  INC     HL              ; next location
6426   16E8 36 80               LD      (HL),$80        ; holds end-marker $80
6427   16EA 23                  INC     HL              ; next location becomes
6428   16EB 22 61 5C            LD      ($5C61),HL      ; start of WORKSP
6429   16EE             
6430   16EE             ; This entry point is used prior to input and prior to the execution,
6431   16EE             ; or parsing, of each statement.
6432   16EE             
6433   16EE             ;; SET-WORK
6434   16EE 2A 61 5C    L16BF:  LD      HL,($5C61)      ; fetch WORKSP value
6435   16F1 22 63 5C            LD      ($5C63),HL      ; and place in STKBOT
6436   16F4             
6437   16F4             ; This entry point is used to move the stack back to its normal place
6438   16F4             ; after temporary relocation during line entry and also from ERROR-3
6439   16F4             
6440   16F4             ;; SET-STK
6441   16F4 2A 63 5C    L16C5:  LD      HL,($5C63)      ; fetch STKBOT value 
6442   16F7 22 65 5C            LD      ($5C65),HL      ; and place in STKEND.
6443   16FA             
6444   16FA E5                  PUSH    HL              ; perhaps an obsolete entry point.
6445   16FB 21 92 5C            LD      HL,$5C92        ; normal location of MEM-0
6446   16FE 22 68 5C            LD      ($5C68),HL      ; is restored to system variable MEM.
6447   1701 E1                  POP     HL              ; saved value not required.
6448   1702 C9                  RET                     ; return.
6449   1703             
6450   1703             ; ------------------
6451   1703             ; Reclaim edit-line?
6452   1703             ; ------------------
6453   1703             ; This seems to be legacy code from the ZX80/ZX81 as it is 
6454   1703             ; not used in this ROM.
6455   1703             ; That task, in fact, is performed here by the dual-area routine CLEAR-SP.
6456   1703             ; This routine is designed to deal with something that is known to be in the
6457   1703             ; edit buffer and not workspace.
6458   1703             ; On entry, HL must point to the end of the something to be deleted.
6459   1703             
6460   1703             ;; REC-EDIT
6461   1703 ED 5B 59 5C L16D4:  LD      DE,($5C59)      ; fetch start of edit line from E_LINE.
6462   1707 C3 14 1A            JP      L19E5           ; jump forward to RECLAIM-1.
6463   170A             
6464   170A             ; --------------------------
6465   170A             ; The Table INDEXING routine
6466   170A             ; --------------------------
6467   170A             ; This routine is used to search two-byte hash tables for a character
6468   170A             ; held in C, returning the address of the following offset byte.
6469   170A             ; if it is known that the character is in the table e.g. for priorities,
6470   170A             ; then the table requires no zero end-marker. If this is not known at the
6471   170A             ; outset then a zero end-marker is required and carry is set to signal
6472   170A             ; success.
6473   170A             
6474   170A             ;; INDEXER-1
6475   170A 23          L16DB:  INC     HL              ; address the next pair of values.
6476   170B             
6477   170B             ; -> The Entry Point.
6478   170B             
6479   170B             ;; INDEXER
6480   170B 7E          L16DC:  LD      A,(HL)          ; fetch the first byte of pair
6481   170C A7                  AND     A               ; is it the end-marker ?
6482   170D C8                  RET     Z               ; return with carry reset if so.
6483   170E             
6484   170E B9                  CP      C               ; is it the required character ?
6485   170F 23                  INC     HL              ; address next location.
6486   1710 20 F8               JR      NZ,L16DB        ; back to INDEXER-1 if no match.
6487   1712             
6488   1712 37                  SCF                     ; else set the carry flag.
6489   1713 C9                  RET                     ; return with carry set
6490   1714             
6491   1714             ; --------------------------------
6492   1714             ; The Channel and Streams Routines
6493   1714             ; --------------------------------
6494   1714             ; A channel is an input/output route to a hardware device
6495   1714             ; and is identified to the system by a single letter e.g. 'K' for
6496   1714             ; the keyboard. A channel can have an input and output route
6497   1714             ; associated with it in which case it is bi-directional like
6498   1714             ; the keyboard. Others like the upper screen 'S' are output
6499   1714             ; only and the input routine usually points to a report message.
6500   1714             ; Channels 'K' and 'S' are system channels and it would be inappropriate
6501   1714             ; to close the associated streams so a mechanism is provided to
6502   1714             ; re-attach them. When the re-attachment is no longer required, then
6503   1714             ; closing these streams resets them as at initialization.
6504   1714             ; Early adverts said that the network and RS232 were in this ROM. 
6505   1714             ; Channels 'N' and 'B' are user channels and have been removed successfully 
6506   1714             ; if, as seems possible, they existed.
6507   1714             ; Ironically the tape streamer is not accessed through streams and
6508   1714             ; channels.
6509   1714             ; Early demonstrations of the Spectrum showed a single microdrive being
6510   1714             ; controlled by the main ROM.
6511   1714             
6512   1714             ; ---------------------
6513   1714             ; THE 'CLOSE #' COMMAND
6514   1714             ; ---------------------
6515   1714             ;   This command allows streams to be closed after use.
6516   1714             ;   Any temporary memory areas used by the stream would be reclaimed and
6517   1714             ;   finally flags set or reset if necessary.
6518   1714             
6519   1714             ;; CLOSE
6520   1714 CD 4D 17    L16E5:  CALL    L171E           ; routine STR-DATA fetches parameter
6521   1717                                             ; from calculator stack and gets the
6522   1717                                             ; existing STRMS data pointer address in HL
6523   1717                                             ; and stream offset from CHANS in BC.
6524   1717             
6525   1717                                             ; Note. this offset could be zero if the
6526   1717                                             ; stream is already closed. A check for this
6527   1717                                             ; should occur now and an error should be
6528   1717                                             ; generated, for example,
6529   1717                                             ; Report S 'Stream status closed'.
6530   1717             
6531   1717 CD 30 17            CALL    L1701           ; routine CLOSE-2 would perform any actions
6532   171A                                             ; peculiar to that stream without disturbing
6533   171A                                             ; data pointer to STRMS entry in HL.
6534   171A             
6535   171A 01 00 00            LD      BC,$0000        ; the stream is to be blanked.
6536   171D 11 E2 A3            LD      DE,$A3E2        ; the number of bytes from stream 4, $5C1E,
6537   1720                                             ; to $10000
6538   1720 EB                  EX      DE,HL           ; transfer offset to HL, STRMS data pointer
6539   1721                                             ; to DE.
6540   1721 19                  ADD     HL,DE           ; add the offset to the data pointer.  
6541   1722 38 07               JR      C,L16FC         ; forward to CLOSE-1 if a non-system stream.
6542   1724                                             ; i.e. higher than 3. 
6543   1724             
6544   1724             ; proceed with a negative result.
6545   1724             
6546   1724 01 03 16            LD      BC,L15C6 + 14   ; prepare the address of the byte after
6547   1727                                             ; the initial stream data in ROM. ($15D4)
6548   1727 09                  ADD     HL,BC           ; index into the data table with negative value.
6549   1728 4E                  LD      C,(HL)          ; low byte to C
6550   1729 23                  INC     HL              ; address next.
6551   172A 46                  LD      B,(HL)          ; high byte to B.
6552   172B             
6553   172B             ;   and for streams 0 - 3 just enter the initial data back into the STRMS entry
6554   172B             ;   streams 0 - 2 can't be closed as they are shared by the operating system.
6555   172B             ;   -> for streams 4 - 15 then blank the entry.
6556   172B             
6557   172B             ;; CLOSE-1
6558   172B EB          L16FC:  EX      DE,HL           ; address of stream to HL.
6559   172C 71                  LD      (HL),C          ; place zero (or low byte).
6560   172D 23                  INC     HL              ; next address.
6561   172E 70                  LD      (HL),B          ; place zero (or high byte).
6562   172F C9                  RET                     ; return.
6563   1730             
6564   1730             ; ------------------------
6565   1730             ; THE 'CLOSE-2' SUBROUTINE
6566   1730             ; ------------------------
6567   1730             ;   There is not much point in coming here.
6568   1730             ;   The purpose was once to find the offset to a special closing routine,
6569   1730             ;   in this ROM and within 256 bytes of the close stream look up table that
6570   1730             ;   would reclaim any buffers associated with a stream. At least one has been
6571   1730             ;   removed.
6572   1730             ;   Any attempt to CLOSE streams $00 to $04, without first opening the stream,
6573   1730             ;   will lead to either a system restart or the production of a strange report.
6574   1730             ;   credit: Martin Wren-Hilton 1982.
6575   1730             
6576   1730             ;; CLOSE-2
6577   1730 E5          L1701:  PUSH    HL              ; * save address of stream data pointer
6578   1731                                             ; in STRMS on the machine stack.
6579   1731 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS address to HL
6580   1734 09                  ADD     HL,BC           ; add the offset to address the second
6581   1735                                             ; byte of the output routine hopefully.
6582   1735 23                  INC     HL              ; step past
6583   1736 23                  INC     HL              ; the input routine.
6584   1737             
6585   1737             ;    Note. When the Sinclair Interface1 is fitted then an instruction fetch 
6586   1737             ;    on the next address pages this ROM out and the shadow ROM in.
6587   1737             
6588   1737             ;; ROM_TRAP
6589   1737 23          L1708:  INC     HL              ; to address channel's letter
6590   1738 4E                  LD      C,(HL)          ; pick it up in C.
6591   1739                                             ; Note. but if stream is already closed we
6592   1739                                             ; get the value $10 (the byte preceding 'K').
6593   1739             
6594   1739 EB                  EX      DE,HL           ; save the pointer to the letter in DE.
6595   173A             
6596   173A             ;   Note. The string pointer is saved but not used!!
6597   173A             
6598   173A 21 45 17            LD      HL,L1716        ; address: cl-str-lu in ROM.
6599   173D CD 0B 17            CALL    L16DC           ; routine INDEXER uses the code to get 
6600   1740                                             ; the 8-bit offset from the current point to
6601   1740                                             ; the address of the closing routine in ROM.
6602   1740                                             ; Note. it won't find $10 there!
6603   1740             
6604   1740 4E                  LD      C,(HL)          ; transfer the offset to C.
6605   1741 06 00               LD      B,$00           ; prepare to add.
6606   1743 09                  ADD     HL,BC           ; add offset to point to the address of the
6607   1744                                             ; routine that closes the stream.
6608   1744                                             ; (and presumably removes any buffers that
6609   1744                                             ; are associated with it.)
6610   1744 E9                  JP      (HL)            ; jump to that routine.
6611   1745             
6612   1745             ; --------------------------------
6613   1745             ; THE 'CLOSE STREAM LOOK-UP' TABLE
6614   1745             ; --------------------------------
6615   1745             ;   This table contains an entry for a letter found in the CHANS area.
6616   1745             ;   followed by an 8-bit displacement, from that byte's address in the
6617   1745             ;   table to the routine that performs any ancillary actions associated
6618   1745             ;   with closing the stream of that channel.
6619   1745             ;   The table doesn't require a zero end-marker as the letter has been
6620   1745             ;   picked up from a channel that has an open stream.
6621   1745             
6622   1745             ;; cl-str-lu
6623   1745 4B 05       L1716:  DEFB    'K', L171C-$-1  ; offset 5 to CLOSE-STR
6624   1747 53 03               DEFB    'S', L171C-$-1  ; offset 3 to CLOSE-STR
6625   1749 50 01               DEFB    'P', L171C-$-1  ; offset 1 to CLOSE-STR
6626   174B             
6627   174B             
6628   174B             ; ------------------------------
6629   174B             ; THE 'CLOSE STREAM' SUBROUTINES
6630   174B             ; ------------------------------
6631   174B             ; The close stream routines in fact have no ancillary actions to perform
6632   174B             ; which is not surprising with regard to 'K' and 'S'.
6633   174B             
6634   174B             ;; CLOSE-STR                    
6635   174B E1          L171C:  POP     HL              ; * now just restore the stream data pointer
6636   174C C9                  RET                     ; in STRMS and return.
6637   174D             
6638   174D             ; -----------
6639   174D             ; Stream data
6640   174D             ; -----------
6641   174D             ; This routine finds the data entry in the STRMS area for the specified
6642   174D             ; stream which is passed on the calculator stack. It returns with HL
6643   174D             ; pointing to this system variable and BC holding a displacement from
6644   174D             ; the CHANS area to the second byte of the stream's channel. If BC holds
6645   174D             ; zero, then that signifies that the stream is closed.
6646   174D             
6647   174D             ;; STR-DATA
6648   174D CD C3 1E    L171E:  CALL    L1E94           ; routine FIND-INT1 fetches parameter to A
6649   1750 FE 10               CP      $10             ; is it less than 16d ?
6650   1752 38 02               JR      C,L1727         ; skip forward to STR-DATA1 if so.
6651   1754             
6652   1754             ;; REPORT-Ob
6653   1754 CF          L1725:  RST     08H             ; ERROR-1
6654   1755 17                  DEFB    $17             ; Error Report: Invalid stream
6655   1756             
6656   1756             ;; STR-DATA1
6657   1756 C6 03       L1727:  ADD     A,$03           ; add the offset for 3 system streams.
6658   1758                                             ; range 00 - 15d becomes 3 - 18d.
6659   1758 07                  RLCA                    ; double as there are two bytes per 
6660   1759                                             ; stream - now 06 - 36d
6661   1759 21 10 5C            LD      HL,$5C10        ; address STRMS - the start of the streams
6662   175C                                             ; data area in system variables.
6663   175C 4F                  LD      C,A             ; transfer the low byte to A.
6664   175D 06 00               LD      B,$00           ; prepare to add offset.
6665   175F 09                  ADD     HL,BC           ; add to address the data entry in STRMS.
6666   1760             
6667   1760             ; the data entry itself contains an offset from CHANS to the address of the
6668   1760             ; stream
6669   1760             
6670   1760 4E                  LD      C,(HL)          ; low byte of displacement to C.
6671   1761 23                  INC     HL              ; address next.
6672   1762 46                  LD      B,(HL)          ; high byte of displacement to B.
6673   1763 2B                  DEC     HL              ; step back to leave HL pointing to STRMS
6674   1764                                             ; data entry.
6675   1764 C9                  RET                     ; return with CHANS displacement in BC
6676   1765                                             ; and address of stream data entry in HL.
6677   1765             
6678   1765             ; --------------------
6679   1765             ; Handle OPEN# command
6680   1765             ; --------------------
6681   1765             ; Command syntax example: OPEN #5,"s"
6682   1765             ; On entry the channel code entry is on the calculator stack with the next
6683   1765             ; value containing the stream identifier. They have to swapped.
6684   1765             
6685   1765             ;; OPEN
6686   1765 EF          L1736:  RST     28H             ;; FP-CALC    ;s,c.
6687   1766 01                  DEFB    $01             ;;exchange    ;c,s.
6688   1767 38                  DEFB    $38             ;;end-calc
6689   1768             
6690   1768 CD 4D 17            CALL    L171E           ; routine STR-DATA fetches the stream off
6691   176B                                             ; the stack and returns with the CHANS
6692   176B                                             ; displacement in BC and HL addressing 
6693   176B                                             ; the STRMS data entry.
6694   176B 78                  LD      A,B             ; test for zero which
6695   176C B1                  OR      C               ; indicates the stream is closed.
6696   176D 28 16               JR      Z,L1756         ; skip forward to OPEN-1 if so.
6697   176F             
6698   176F             ; if it is a system channel then it can re-attached.
6699   176F             
6700   176F EB                  EX      DE,HL           ; save STRMS address in DE.
6701   1770 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS.
6702   1773 09                  ADD     HL,BC           ; add the offset to address the second 
6703   1774                                             ; byte of the channel.
6704   1774 23                  INC     HL              ; skip over the
6705   1775 23                  INC     HL              ; input routine.
6706   1776 23                  INC     HL              ; and address the letter.
6707   1777 7E                  LD      A,(HL)          ; pick up the letter.
6708   1778 EB                  EX      DE,HL           ; save letter pointer and bring back
6709   1779                                             ; the STRMS pointer.
6710   1779             
6711   1779 FE 4B               CP      $4B             ; is it 'K' ?
6712   177B 28 08               JR      Z,L1756         ; forward to OPEN-1 if so
6713   177D             
6714   177D FE 53               CP      $53             ; is it 'S' ?
6715   177F 28 04               JR      Z,L1756         ; forward to OPEN-1 if so
6716   1781             
6717   1781 FE 50               CP      $50             ; is it 'P' ?
6718   1783 20 CF               JR      NZ,L1725        ; back to REPORT-Ob if not.
6719   1785                                             ; to report 'Invalid stream'.
6720   1785             
6721   1785             ; continue if one of the upper-case letters was found.
6722   1785             ; and rejoin here from above if stream was closed.
6723   1785             
6724   1785             ;; OPEN-1
6725   1785 CD 8C 17    L1756:  CALL    L175D           ; routine OPEN-2 opens the stream.
6726   1788             
6727   1788             ; it now remains to update the STRMS variable.
6728   1788             
6729   1788 73                  LD      (HL),E          ; insert or overwrite the low byte.
6730   1789 23                  INC     HL              ; address high byte in STRMS.
6731   178A 72                  LD      (HL),D          ; insert or overwrite the high byte.
6732   178B C9                  RET                     ; return.
6733   178C             
6734   178C             ; -----------------
6735   178C             ; OPEN-2 Subroutine
6736   178C             ; -----------------
6737   178C             ; There is some point in coming here as, as well as once creating buffers,
6738   178C             ; this routine also sets flags.
6739   178C             
6740   178C             ;; OPEN-2
6741   178C E5          L175D:  PUSH    HL              ; * save the STRMS data entry pointer.
6742   178D CD 20 2C            CALL    L2BF1           ; routine STK-FETCH now fetches the
6743   1790                                             ; parameters of the channel string.
6744   1790                                             ; start in DE, length in BC.
6745   1790             
6746   1790 78                  LD      A,B             ; test that it is not
6747   1791 B1                  OR      C               ; the null string.
6748   1792 20 02               JR      NZ,L1767        ; skip forward to OPEN-3 with 1 character
6749   1794                                             ; or more!
6750   1794             
6751   1794             ;; REPORT-Fb
6752   1794 CF          L1765:  RST     08H             ; ERROR-1
6753   1795 0E                  DEFB    $0E             ; Error Report: Invalid file name
6754   1796             
6755   1796             ;; OPEN-3
6756   1796 C5          L1767:  PUSH    BC              ; save the length of the string.
6757   1797 1A                  LD      A,(DE)          ; pick up the first character.
6758   1798                                             ; Note. There can be more than one character.
6759   1798 E6 DF               AND     $DF             ; make it upper-case.
6760   179A 4F                  LD      C,A             ; place it in C.
6761   179B 21 A9 17            LD      HL,L177A        ; address: op-str-lu is loaded.
6762   179E CD 0B 17            CALL    L16DC           ; routine INDEXER will search for letter.
6763   17A1 30 F1               JR      NC,L1765        ; back to REPORT-F if not found
6764   17A3                                             ; 'Invalid filename'
6765   17A3             
6766   17A3 4E                  LD      C,(HL)          ; fetch the displacement to opening routine.
6767   17A4 06 00               LD      B,$00           ; prepare to add.
6768   17A6 09                  ADD     HL,BC           ; now form address of opening routine.
6769   17A7 C1                  POP     BC              ; restore the length of string.
6770   17A8 E9                  JP      (HL)            ; now jump forward to the relevant routine.
6771   17A9             
6772   17A9             ; -------------------------
6773   17A9             ; OPEN stream look-up table
6774   17A9             ; -------------------------
6775   17A9             ; The open stream look-up table consists of matched pairs.
6776   17A9             ; The channel letter is followed by an 8-bit displacement to the
6777   17A9             ; associated stream-opening routine in this ROM.
6778   17A9             ; The table requires a zero end-marker as the letter has been
6779   17A9             ; provided by the user and not the operating system.
6780   17A9             
6781   17A9             ;; op-str-lu
6782   17A9 4B 06       L177A:  DEFB    'K', L1781-$-1  ; $06 offset to OPEN-K
6783   17AB 53 08               DEFB    'S', L1785-$-1  ; $08 offset to OPEN-S
6784   17AD 50 0A               DEFB    'P', L1789-$-1  ; $0A offset to OPEN-P
6785   17AF             
6786   17AF 00                  DEFB    $00             ; end-marker.
6787   17B0             
6788   17B0             ; ----------------------------
6789   17B0             ; The Stream Opening Routines.
6790   17B0             ; ----------------------------
6791   17B0             ; These routines would have opened any buffers associated with the stream
6792   17B0             ; before jumping forward to OPEN-END with the displacement value in E
6793   17B0             ; and perhaps a modified value in BC. The strange pathing does seem to
6794   17B0             ; provide for flexibility in this respect.
6795   17B0             ;
6796   17B0             ; There is no need to open the printer buffer as it is there already
6797   17B0             ; even if you are still saving up for a ZX Printer or have moved onto
6798   17B0             ; something bigger. In any case it would have to be created after
6799   17B0             ; the system variables but apart from that it is a simple task
6800   17B0             ; and all but one of the ROM routines can handle a buffer in that position.
6801   17B0             ; (PR-ALL-6 would require an extra 3 bytes of code).
6802   17B0             ; However it wouldn't be wise to have two streams attached to the ZX Printer
6803   17B0             ; as you can now, so one assumes that if PR_CC_hi was non-zero then
6804   17B0             ; the OPEN-P routine would have refused to attach a stream if another
6805   17B0             ; stream was attached.
6806   17B0             
6807   17B0             ; Something of significance is being passed to these ghost routines in the
6808   17B0             ; second character. Strings 'RB', 'RT' perhaps or a drive/station number.
6809   17B0             ; The routine would have to deal with that and exit to OPEN_END with BC
6810   17B0             ; containing $0001 or more likely there would be an exit within the routine.
6811   17B0             ; Anyway doesn't matter, these routines are long gone.
6812   17B0             
6813   17B0             ; -----------------
6814   17B0             ; OPEN-K Subroutine
6815   17B0             ; -----------------
6816   17B0             ; Open Keyboard stream.
6817   17B0             
6818   17B0             ;; OPEN-K
6819   17B0 1E 01       L1781:  LD      E,$01           ; 01 is offset to second byte of channel 'K'.
6820   17B2 18 06               JR      L178B           ; forward to OPEN-END
6821   17B4             
6822   17B4             ; -----------------
6823   17B4             ; OPEN-S Subroutine
6824   17B4             ; -----------------
6825   17B4             ; Open Screen stream.
6826   17B4             
6827   17B4             ;; OPEN-S
6828   17B4 1E 06       L1785:  LD      E,$06           ; 06 is offset to 2nd byte of channel 'S'
6829   17B6 18 02               JR      L178B           ; to OPEN-END
6830   17B8             
6831   17B8             ; -----------------
6832   17B8             ; OPEN-P Subroutine
6833   17B8             ; -----------------
6834   17B8             ; Open Printer stream.
6835   17B8             
6836   17B8             ;; OPEN-P
6837   17B8 1E 10       L1789:  LD      E,$10           ; 16d is offset to 2nd byte of channel 'P'
6838   17BA             
6839   17BA             ;; OPEN-END
6840   17BA 0B          L178B:  DEC     BC              ; the stored length of 'K','S','P' or
6841   17BB                                             ; whatever is now tested. ??
6842   17BB 78                  LD      A,B             ; test now if initial or residual length
6843   17BC B1                  OR      C               ; is one character.
6844   17BD 20 D5               JR      NZ,L1765        ; to REPORT-Fb 'Invalid file name' if not.
6845   17BF             
6846   17BF 57                  LD      D,A             ; load D with zero to form the displacement
6847   17C0                                             ; in the DE register.
6848   17C0 E1                  POP     HL              ; * restore the saved STRMS pointer.
6849   17C1 C9                  RET                     ; return to update STRMS entry thereby 
6850   17C2                                             ; signaling stream is open.
6851   17C2             
6852   17C2             ; ----------------------------------------
6853   17C2             ; Handle CAT, ERASE, FORMAT, MOVE commands
6854   17C2             ; ----------------------------------------
6855   17C2             ; These just generate an error report as the ROM is 'incomplete'.
6856   17C2             ;
6857   17C2             ; Luckily this provides a mechanism for extending these in a shadow ROM
6858   17C2             ; but without the powerful mechanisms set up in this ROM.
6859   17C2             ; An instruction fetch on $0008 may page in a peripheral ROM,
6860   17C2             ; e.g. the Sinclair Interface 1 ROM, to handle these commands.
6861   17C2             ; However that wasn't the plan.
6862   17C2             ; Development of this ROM continued for another three months until the cost
6863   17C2             ; of replacing it and the manual became unfeasible.
6864   17C2             ; The ultimate power of channels and streams died at birth.
6865   17C2             
6866   17C2             ;; CAT-ETC
6867   17C2 18 90       L1793:  JR      L1725           ; to REPORT-Ob
6868   17C4             
6869   17C4             ; -----------------
6870   17C4             ; Perform AUTO-LIST
6871   17C4             ; -----------------
6872   17C4             ; This produces an automatic listing in the upper screen.
6873   17C4             
6874   17C4             ;; AUTO-LIST
6875   17C4 ED 73 3F 5C L1795:  LD      ($5C3F),SP      ; save stack pointer in LIST_SP
6876   17C8 FD 36 02 10         LD      (IY+$02),$10    ; update TV_FLAG set bit 3
6877   17CC CD DE 0D            CALL    L0DAF           ; routine CL-ALL.
6878   17CF FD CB 02 C6         SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
6879   17D3             
6880   17D3 FD 46 31            LD      B,(IY+$31)      ; fetch DF_SZ to B.
6881   17D6 CD 73 0E            CALL    L0E44           ; routine CL-LINE clears lower display
6882   17D9                                             ; preserving B.
6883   17D9 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG  - signal main screen in use
6884   17DD FD CB 30 C6         SET     0,(IY+$30)      ; update FLAGS2 - signal will be necessary to
6885   17E1                                             ; clear main screen.
6886   17E1 2A 49 5C            LD      HL,($5C49)      ; fetch E_PPC current edit line to HL.
6887   17E4 ED 5B 6C 5C         LD      DE,($5C6C)      ; fetch S_TOP to DE, the current top line
6888   17E8                                             ; (initially zero)
6889   17E8 A7                  AND     A               ; prepare for true subtraction.
6890   17E9 ED 52               SBC     HL,DE           ; subtract and
6891   17EB 19                  ADD     HL,DE           ; add back.
6892   17EC 38 22               JR      C,L17E1         ; to AUTO-L-2 if S_TOP higher than E_PPC
6893   17EE                                             ; to set S_TOP to E_PPC
6894   17EE             
6895   17EE D5                  PUSH    DE              ; save the top line number.
6896   17EF CD 9D 19            CALL    L196E           ; routine LINE-ADDR gets address of E_PPC.
6897   17F2 11 C0 02            LD      DE,$02C0        ; prepare known number of characters in
6898   17F5                                             ; the default upper screen.
6899   17F5 EB                  EX      DE,HL           ; offset to HL, program address to DE.
6900   17F6 ED 52               SBC     HL,DE           ; subtract high value from low to obtain
6901   17F8                                             ; negated result used in addition.
6902   17F8 E3                  EX      (SP),HL         ; swap result with top line number on stack.
6903   17F9 CD 9D 19            CALL    L196E           ; routine LINE-ADDR  gets address of that
6904   17FC                                             ; top line in HL and next line in DE.
6905   17FC C1                  POP     BC              ; restore the result to balance stack.
6906   17FD             
6907   17FD             ;; AUTO-L-1
6908   17FD C5          L17CE:  PUSH    BC              ; save the result.
6909   17FE CD E7 19            CALL    L19B8           ; routine NEXT-ONE gets address in HL of
6910   1801                                             ; line after auto-line (in DE).
6911   1801 C1                  POP     BC              ; restore result.
6912   1802 09                  ADD     HL,BC           ; compute back.
6913   1803 38 0E               JR      C,L17E4         ; to AUTO-L-3 if line 'should' appear
6914   1805             
6915   1805 EB                  EX      DE,HL           ; address of next line to HL.
6916   1806 56                  LD      D,(HL)          ; get line
6917   1807 23                  INC     HL              ; number
6918   1808 5E                  LD      E,(HL)          ; in DE.
6919   1809 2B                  DEC     HL              ; adjust back to start.
6920   180A ED 53 6C 5C         LD      ($5C6C),DE      ; update S_TOP.
6921   180E 18 ED               JR      L17CE           ; to AUTO-L-1 until estimate reached.
6922   1810             
6923   1810             ; ---
6924   1810             
6925   1810             ; the jump was to here if S_TOP was greater than E_PPC
6926   1810             
6927   1810             ;; AUTO-L-2
6928   1810 22 6C 5C    L17E1:  LD      ($5C6C),HL      ; make S_TOP the same as E_PPC.
6929   1813             
6930   1813             ; continue here with valid starting point from above or good estimate
6931   1813             ; from computation
6932   1813             
6933   1813             ;; AUTO-L-3
6934   1813 2A 6C 5C    L17E4:  LD      HL,($5C6C)      ; fetch S_TOP line number to HL.
6935   1816 CD 9D 19            CALL    L196E           ; routine LINE-ADDR gets address in HL.
6936   1819                                             ; address of next in DE.
6937   1819 28 01               JR      Z,L17ED         ; to AUTO-L-4 if line exists.
6938   181B             
6939   181B EB                  EX      DE,HL           ; else use address of next line.
6940   181C             
6941   181C             ;; AUTO-L-4
6942   181C CD 62 18    L17ED:  CALL    L1833           ; routine LIST-ALL                >>>
6943   181F             
6944   181F             ; The return will be to here if no scrolling occurred
6945   181F             
6946   181F FD CB 02 A6         RES     4,(IY+$02)      ; update TV_FLAG  - signal no auto listing.
6947   1823 C9                  RET                     ; return.
6948   1824             
6949   1824             ; ------------
6950   1824             ; Handle LLIST
6951   1824             ; ------------
6952   1824             ; A short form of LIST #3. The listing goes to stream 3 - default printer.
6953   1824             
6954   1824             ;; LLIST
6955   1824 3E 03       L17F5:  LD      A,$03           ; the usual stream for ZX Printer
6956   1826 18 02               JR      L17FB           ; forward to LIST-1
6957   1828             
6958   1828             ; -----------
6959   1828             ; Handle LIST
6960   1828             ; -----------
6961   1828             ; List to any stream.
6962   1828             ; Note. While a starting line can be specified it is
6963   1828             ; not possible to specify an end line.
6964   1828             ; Just listing a line makes it the current edit line.
6965   1828             
6966   1828             ;; LIST
6967   1828 3E 02       L17F9:  LD      A,$02           ; default is stream 2 - the upper screen.
6968   182A             
6969   182A             ;; LIST-1
6970   182A FD 36 02 00 L17FB:  LD      (IY+$02),$00    ; the TV_FLAG is initialized with bit 0 reset
6971   182E                                             ; indicating upper screen in use.
6972   182E CD 5F 25            CALL    L2530           ; routine SYNTAX-Z - checking syntax ?
6973   1831 C4 30 16            CALL    NZ,L1601        ; routine CHAN-OPEN if in run-time.
6974   1834             
6975   1834 DF                  RST     18H             ; GET-CHAR
6976   1835 CD 9F 20            CALL    L2070           ; routine STR-ALTER will alter if '#'.
6977   1838 38 14               JR      C,L181F         ; forward to LIST-4 not a '#' .
6978   183A             
6979   183A             
6980   183A DF                  RST     18H             ; GET-CHAR
6981   183B FE 3B               CP      $3B             ; is it ';' ?
6982   183D 28 04               JR      Z,L1814         ; skip to LIST-2 if so.
6983   183F             
6984   183F FE 2C               CP      $2C             ; is it ',' ?
6985   1841 20 06               JR      NZ,L181A        ; forward to LIST-3 if neither separator.
6986   1843             
6987   1843             ; we have, say,  LIST #15, and a number must follow the separator.
6988   1843             
6989   1843             ;; LIST-2
6990   1843 E7          L1814:  RST     20H             ; NEXT-CHAR
6991   1844 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM
6992   1847 18 08               JR      L1822           ; forward to LIST-5
6993   1849             
6994   1849             ; ---
6995   1849             
6996   1849             ; the branch was here with just LIST #3 etc.
6997   1849             
6998   1849             ;; LIST-3
6999   1849 CD 15 1D    L181A:  CALL    L1CE6           ; routine USE-ZERO
7000   184C 18 03               JR      L1822           ; forward to LIST-5
7001   184E             
7002   184E             ; ---
7003   184E             
7004   184E             ; the branch was here with LIST
7005   184E             
7006   184E             ;; LIST-4
7007   184E CD 0D 1D    L181F:  CALL    L1CDE           ; routine FETCH-NUM checks if a number 
7008   1851                                             ; follows else uses zero.
7009   1851             
7010   1851             ;; LIST-5
7011   1851 CD 1D 1C    L1822:  CALL    L1BEE           ; routine CHECK-END quits if syntax OK >>>
7012   1854             
7013   1854 CD C8 1E            CALL    L1E99           ; routine FIND-INT2 fetches the number
7014   1857                                             ; from the calculator stack in run-time.
7015   1857 78                  LD      A,B             ; fetch high byte of line number and
7016   1858 E6 3F               AND     $3F             ; make less than $40 so that NEXT-ONE
7017   185A                                             ; (from LINE-ADDR) doesn't lose context.
7018   185A                                             ; Note. this is not satisfactory and the typo
7019   185A                                             ; LIST 20000 will list an entirely different
7020   185A                                             ; section than LIST 2000. Such typos are not
7021   185A                                             ; available for checking if they are direct
7022   185A                                             ; commands.
7023   185A             
7024   185A 67                  LD      H,A             ; transfer the modified
7025   185B 69                  LD      L,C             ; line number to HL.
7026   185C 22 49 5C            LD      ($5C49),HL      ; update E_PPC to new line number.
7027   185F CD 9D 19            CALL    L196E           ; routine LINE-ADDR gets the address of the
7028   1862                                             ; line.
7029   1862             
7030   1862             ; This routine is called from AUTO-LIST
7031   1862             
7032   1862             ;; LIST-ALL
7033   1862 1E 01       L1833:  LD      E,$01           ; signal current line not yet printed
7034   1864             
7035   1864             ;; LIST-ALL-2
7036   1864 CD 84 18    L1835:  CALL    L1855           ; routine OUT-LINE outputs a BASIC line
7037   1867                                             ; using PRINT-OUT and makes an early return
7038   1867                                             ; when no more lines to print. >>>
7039   1867             
7040   1867 D7                  RST     10H             ; PRINT-A prints the carriage return (in A)
7041   1868             
7042   1868 FD CB 02 66         BIT     4,(IY+$02)      ; test TV_FLAG  - automatic listing ?
7043   186C 28 F6               JR      Z,L1835         ; back to LIST-ALL-2 if not
7044   186E                                             ; (loop exit is via OUT-LINE)
7045   186E             
7046   186E             ; continue here if an automatic listing required.
7047   186E             
7048   186E 3A 6B 5C            LD      A,($5C6B)       ; fetch DF_SZ lower display file size.
7049   1871 FD 96 4F            SUB     (IY+$4F)        ; subtract S_POSN_hi ithe current line number.
7050   1874 20 EE               JR      NZ,L1835        ; back to LIST-ALL-2 if upper screen not full.
7051   1876             
7052   1876 AB                  XOR     E               ; A contains zero, E contains one if the
7053   1877                                             ; current edit line has not been printed
7054   1877                                             ; or zero if it has (from OUT-LINE).
7055   1877 C8                  RET     Z               ; return if the screen is full and the line
7056   1878                                             ; has been printed.
7057   1878             
7058   1878             ; continue with automatic listings if the screen is full and the current
7059   1878             ; edit line is missing. OUT-LINE will scroll automatically.
7060   1878             
7061   1878 E5                  PUSH    HL              ; save the pointer address.
7062   1879 D5                  PUSH    DE              ; save the E flag.
7063   187A 21 6C 5C            LD      HL,$5C6C        ; fetch S_TOP the rough estimate.
7064   187D CD 3E 19            CALL    L190F           ; routine LN-FETCH updates S_TOP with
7065   1880                                             ; the number of the next line.
7066   1880 D1                  POP     DE              ; restore the E flag.
7067   1881 E1                  POP     HL              ; restore the address of the next line.
7068   1882 18 E0               JR      L1835           ; back to LIST-ALL-2.
7069   1884             
7070   1884             ; ------------------------
7071   1884             ; Print a whole BASIC line
7072   1884             ; ------------------------
7073   1884             ; This routine prints a whole BASIC line and it is called
7074   1884             ; from LIST-ALL to output the line to current channel
7075   1884             ; and from ED-EDIT to 'sprint' the line to the edit buffer.
7076   1884             
7077   1884             ;; OUT-LINE
7078   1884 ED 4B 49 5C L1855:  LD      BC,($5C49)      ; fetch E_PPC the current line which may be
7079   1888                                             ; unchecked and not exist.
7080   1888 CD AF 19            CALL    L1980           ; routine CP-LINES finds match or line after.
7081   188B 16 3E               LD      D,$3E           ; prepare cursor '>' in D.
7082   188D 28 05               JR      Z,L1865         ; to OUT-LINE1 if matched or line after.
7083   188F             
7084   188F 11 00 00            LD      DE,$0000        ; put zero in D, to suppress line cursor.
7085   1892 CB 13               RL      E               ; pick up carry in E if line before current
7086   1894                                             ; leave E zero if same or after.
7087   1894             
7088   1894             ;; OUT-LINE1
7089   1894 FD 73 2D    L1865:  LD      (IY+$2D),E      ; save flag in BREG which is spare.
7090   1897 7E                  LD      A,(HL)          ; get high byte of line number.
7091   1898 FE 40               CP      $40             ; is it too high ($2F is maximum possible) ?
7092   189A C1                  POP     BC              ; drop the return address and
7093   189B D0                  RET     NC              ; make an early return if so >>>
7094   189C             
7095   189C C5                  PUSH    BC              ; save return address
7096   189D CD 57 1A            CALL    L1A28           ; routine OUT-NUM-2 to print addressed number
7097   18A0                                             ; with leading space.
7098   18A0 23                  INC     HL              ; skip low number byte.
7099   18A1 23                  INC     HL              ; and the two
7100   18A2 23                  INC     HL              ; length bytes.
7101   18A3 FD CB 01 86         RES     0,(IY+$01)      ; update FLAGS - signal leading space required.
7102   18A7 7A                  LD      A,D             ; fetch the cursor.
7103   18A8 A7                  AND     A               ; test for zero.
7104   18A9 28 05               JR      Z,L1881         ; to OUT-LINE3 if zero.
7105   18AB             
7106   18AB             
7107   18AB D7                  RST     10H             ; PRINT-A prints '>' the current line cursor.
7108   18AC             
7109   18AC             ; this entry point is called from ED-COPY
7110   18AC             
7111   18AC             ;; OUT-LINE2
7112   18AC FD CB 01 C6 L187D:  SET     0,(IY+$01)      ; update FLAGS - suppress leading space.
7113   18B0             
7114   18B0             ;; OUT-LINE3
7115   18B0 D5          L1881:  PUSH    DE              ; save flag E for a return value.
7116   18B1 EB                  EX      DE,HL           ; save HL address in DE.
7117   18B2 FD CB 30 96         RES     2,(IY+$30)      ; update FLAGS2 - signal NOT in QUOTES.
7118   18B6             
7119   18B6 21 3B 5C            LD      HL,$5C3B        ; point to FLAGS.
7120   18B9 CB 96               RES     2,(HL)          ; signal 'K' mode. (starts before keyword)
7121   18BB FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX - input mode ?
7122   18BF 28 02               JR      Z,L1894         ; forward to OUT-LINE4 if not.
7123   18C1             
7124   18C1 CB D6               SET     2,(HL)          ; signal 'L' mode. (used for input)
7125   18C3             
7126   18C3             ;; OUT-LINE4
7127   18C3 2A 5F 5C    L1894:  LD      HL,($5C5F)      ; fetch X_PTR - possibly the error pointer
7128   18C6                                             ; address.
7129   18C6 A7                  AND     A               ; clear the carry flag.
7130   18C7 ED 52               SBC     HL,DE           ; test if an error address has been reached.
7131   18C9 20 05               JR      NZ,L18A1        ; forward to OUT-LINE5 if not.
7132   18CB             
7133   18CB 3E 3F               LD      A,$3F           ; load A with '?' the error marker.
7134   18CD CD F0 18            CALL    L18C1           ; routine OUT-FLASH to print flashing marker.
7135   18D0             
7136   18D0             ;; OUT-LINE5
7137   18D0 CD 10 19    L18A1:  CALL    L18E1           ; routine OUT-CURS will print the cursor if
7138   18D3                                             ; this is the right position.
7139   18D3 EB                  EX      DE,HL           ; restore address pointer to HL.
7140   18D4 7E                  LD      A,(HL)          ; fetch the addressed character.
7141   18D5 CD E5 18            CALL    L18B6           ; routine NUMBER skips a hidden floating 
7142   18D8                                             ; point number if present.
7143   18D8 23                  INC     HL              ; now increment the pointer.
7144   18D9 FE 0D               CP      $0D             ; is character end-of-line ?
7145   18DB 28 06               JR      Z,L18B4         ; to OUT-LINE6, if so, as line is finished.
7146   18DD             
7147   18DD EB                  EX      DE,HL           ; save the pointer in DE.
7148   18DE CD 66 19            CALL    L1937           ; routine OUT-CHAR to output character/token.
7149   18E1             
7150   18E1 18 E0               JR      L1894           ; back to OUT-LINE4 until entire line is done.
7151   18E3             
7152   18E3             ; ---
7153   18E3             
7154   18E3             ;; OUT-LINE6
7155   18E3 D1          L18B4:  POP     DE              ; bring back the flag E, zero if current
7156   18E4                                             ; line printed else 1 if still to print.
7157   18E4 C9                  RET                     ; return with A holding $0D
7158   18E5             
7159   18E5             ; -------------------------
7160   18E5             ; Check for a number marker
7161   18E5             ; -------------------------
7162   18E5             ; this subroutine is called from two processes. while outputting BASIC lines
7163   18E5             ; and while searching statements within a BASIC line.
7164   18E5             ; during both, this routine will pass over an invisible number indicator
7165   18E5             ; and the five bytes floating-point number that follows it.
7166   18E5             ; Note that this causes floating point numbers to be stripped from
7167   18E5             ; the BASIC line when it is fetched to the edit buffer by OUT_LINE.
7168   18E5             ; the number marker also appears after the arguments of a DEF FN statement
7169   18E5             ; and may mask old 5-byte string parameters.
7170   18E5             
7171   18E5             ;; NUMBER
7172   18E5 FE 0E       L18B6:  CP      $0E             ; character fourteen ?
7173   18E7 C0                  RET     NZ              ; return if not.
7174   18E8             
7175   18E8 23                  INC     HL              ; skip the character
7176   18E9 23                  INC     HL              ; and five bytes
7177   18EA 23                  INC     HL              ; following.
7178   18EB 23                  INC     HL              ;
7179   18EC 23                  INC     HL              ;
7180   18ED 23                  INC     HL              ;
7181   18EE 7E                  LD      A,(HL)          ; fetch the following character
7182   18EF C9                  RET                     ; for return value.
7183   18F0             
7184   18F0             ; --------------------------
7185   18F0             ; Print a flashing character
7186   18F0             ; --------------------------
7187   18F0             ; This subroutine is called from OUT-LINE to print a flashing error
7188   18F0             ; marker '?' or from the next routine to print a flashing cursor e.g. 'L'.
7189   18F0             ; However, this only gets called from OUT-LINE when printing the edit line
7190   18F0             ; or the input buffer to the lower screen so a direct call to $09F4 can
7191   18F0             ; be used, even though out-line outputs to other streams.
7192   18F0             ; In fact the alternate set is used for the whole routine.
7193   18F0             
7194   18F0             ;; OUT-FLASH
7195   18F0 D9          L18C1:  EXX                     ; switch in alternate set
7196   18F1             
7197   18F1 2A 8F 5C            LD      HL,($5C8F)      ; fetch L = ATTR_T, H = MASK-T
7198   18F4 E5                  PUSH    HL              ; save masks.
7199   18F5 CB BC               RES     7,H             ; reset flash mask bit so active. 
7200   18F7 CB FD               SET     7,L             ; make attribute FLASH.
7201   18F9 22 8F 5C            LD      ($5C8F),HL      ; resave ATTR_T and MASK-T
7202   18FC             
7203   18FC 21 91 5C            LD      HL,$5C91        ; address P_FLAG
7204   18FF 56                  LD      D,(HL)          ; fetch to D
7205   1900 D5                  PUSH    DE              ; and save.
7206   1901 36 00               LD      (HL),$00        ; clear inverse, over, ink/paper 9
7207   1903             
7208   1903 CD 23 0A            CALL    L09F4           ; routine PRINT-OUT outputs character
7209   1906                                             ; without the need to vector via RST 10.
7210   1906             
7211   1906 E1                  POP     HL              ; pop P_FLAG to H.
7212   1907 FD 74 57            LD      (IY+$57),H      ; and restore system variable P_FLAG.
7213   190A E1                  POP     HL              ; restore temporary masks
7214   190B 22 8F 5C            LD      ($5C8F),HL      ; and restore system variables ATTR_T/MASK_T
7215   190E             
7216   190E D9                  EXX                     ; switch back to main set
7217   190F C9                  RET                     ; return
7218   1910             
7219   1910             ; ----------------
7220   1910             ; Print the cursor
7221   1910             ; ----------------
7222   1910             ; This routine is called before any character is output while outputting
7223   1910             ; a BASIC line or the input buffer. This includes listing to a printer
7224   1910             ; or screen, copying a BASIC line to the edit buffer and printing the
7225   1910             ; input buffer or edit buffer to the lower screen. It is only in the
7226   1910             ; latter two cases that it has any relevance and in the last case it
7227   1910             ; performs another very important function also.
7228   1910             
7229   1910             ;; OUT-CURS
7230   1910 2A 5B 5C    L18E1:  LD      HL,($5C5B)      ; fetch K_CUR the current cursor address
7231   1913 A7                  AND     A               ; prepare for true subtraction.
7232   1914 ED 52               SBC     HL,DE           ; test against pointer address in DE and
7233   1916 C0                  RET     NZ              ; return if not at exact position.
7234   1917             
7235   1917             ; the value of MODE, maintained by KEY-INPUT, is tested and if non-zero
7236   1917             ; then this value 'E' or 'G' will take precedence.
7237   1917             
7238   1917 3A 41 5C            LD      A,($5C41)       ; fetch MODE  0='KLC', 1='E', 2='G'.
7239   191A CB 07               RLC     A               ; double the value and set flags.
7240   191C 28 04               JR      Z,L18F3         ; to OUT-C-1 if still zero ('KLC').
7241   191E             
7242   191E C6 43               ADD     A,$43           ; add 'C' - will become 'E' if originally 1
7243   1920                                             ; or 'G' if originally 2.
7244   1920 18 16               JR      L1909           ; forward to OUT-C-2 to print.
7245   1922             
7246   1922             ; ---
7247   1922             
7248   1922             ; If mode was zero then, while printing a BASIC line, bit 2 of flags has been
7249   1922             ; set if 'THEN' or ':' was encountered as a main character and reset otherwise.
7250   1922             ; This is now used to determine if the 'K' cursor is to be printed but this
7251   1922             ; transient state is also now transferred permanently to bit 3 of FLAGS
7252   1922             ; to let the interrupt routine know how to decode the next key.
7253   1922             
7254   1922             ;; OUT-C-1
7255   1922 21 3B 5C    L18F3:  LD      HL,$5C3B        ; Address FLAGS
7256   1925 CB 9E               RES     3,(HL)          ; signal 'K' mode initially.
7257   1927 3E 4B               LD      A,$4B           ; prepare letter 'K'.
7258   1929 CB 56               BIT     2,(HL)          ; test FLAGS - was the
7259   192B                                             ; previous main character ':' or 'THEN' ?
7260   192B 28 0B               JR      Z,L1909         ; forward to OUT-C-2 if so to print.
7261   192D             
7262   192D CB DE               SET     3,(HL)          ; signal 'L' mode to interrupt routine.
7263   192F                                             ; Note. transient bit has been made permanent.
7264   192F 3C                  INC     A               ; augment from 'K' to 'L'.
7265   1930             
7266   1930 FD CB 30 5E         BIT     3,(IY+$30)      ; test FLAGS2 - consider caps lock ?
7267   1934                                             ; which is maintained by KEY-INPUT.
7268   1934 28 02               JR      Z,L1909         ; forward to OUT-C-2 if not set to print.
7269   1936             
7270   1936 3E 43               LD      A,$43           ; alter 'L' to 'C'.
7271   1938             
7272   1938             ;; OUT-C-2
7273   1938 D5          L1909:  PUSH    DE              ; save address pointer but OK as OUT-FLASH
7274   1939                                             ; uses alternate set without RST 10.
7275   1939             
7276   1939 CD F0 18            CALL    L18C1           ; routine OUT-FLASH to print.
7277   193C             
7278   193C D1                  POP     DE              ; restore and
7279   193D C9                  RET                     ; return.
7280   193E             
7281   193E             ; ----------------------------
7282   193E             ; Get line number of next line
7283   193E             ; ----------------------------
7284   193E             ; These two subroutines are called while editing.
7285   193E             ; This entry point is from ED-DOWN with HL addressing E_PPC
7286   193E             ; to fetch the next line number.
7287   193E             ; Also from AUTO-LIST with HL addressing S_TOP just to update S_TOP
7288   193E             ; with the value of the next line number. It gets fetched but is discarded.
7289   193E             ; These routines never get called while the editor is being used for input.
7290   193E             
7291   193E             ;; LN-FETCH
7292   193E 5E          L190F:  LD      E,(HL)          ; fetch low byte
7293   193F 23                  INC     HL              ; address next
7294   1940 56                  LD      D,(HL)          ; fetch high byte.
7295   1941 E5                  PUSH    HL              ; save system variable hi pointer.
7296   1942 EB                  EX      DE,HL           ; line number to HL,
7297   1943 23                  INC     HL              ; increment as a starting point.
7298   1944 CD 9D 19            CALL    L196E           ; routine LINE-ADDR gets address in HL.
7299   1947 CD C4 16            CALL    L1695           ; routine LINE-NO gets line number in DE.
7300   194A E1                  POP     HL              ; restore system variable hi pointer.
7301   194B             
7302   194B             ; This entry point is from the ED-UP with HL addressing E_PPC_hi
7303   194B             
7304   194B             ;; LN-STORE
7305   194B FD CB 37 6E L191C:  BIT     5,(IY+$37)      ; test FLAGX - input mode ?
7306   194F C0                  RET     NZ              ; return if so.
7307   1950                                             ; Note. above already checked by ED-UP/ED-DOWN.
7308   1950             
7309   1950 72                  LD      (HL),D          ; save high byte of line number.
7310   1951 2B                  DEC     HL              ; address lower
7311   1952 73                  LD      (HL),E          ; save low byte of line number.
7312   1953 C9                  RET                     ; return.
7313   1954             
7314   1954             ; -----------------------------------------
7315   1954             ; Outputting numbers at start of BASIC line
7316   1954             ; -----------------------------------------
7317   1954             ; This routine entered at OUT-SP-NO is used to compute then output the first
7318   1954             ; three digits of a 4-digit BASIC line printing a space if necessary.
7319   1954             ; The line number, or residual part, is held in HL and the BC register
7320   1954             ; holds a subtraction value -1000, -100 or -10.
7321   1954             ; Note. for example line number 200 -
7322   1954             ; space(out_char), 2(out_code), 0(out_char) final number always out-code.
7323   1954             
7324   1954             ;; OUT-SP-2
7325   1954 7B          L1925:  LD      A,E             ; will be space if OUT-CODE not yet called.
7326   1955                                             ; or $FF if spaces are suppressed.
7327   1955                                             ; else $30 ('0').
7328   1955                                             ; (from the first instruction at OUT-CODE)
7329   1955                                             ; this guy is just too clever.
7330   1955 A7                  AND     A               ; test bit 7 of A.
7331   1956 F8                  RET     M               ; return if $FF, as leading spaces not
7332   1957                                             ; required. This is set when printing line
7333   1957                                             ; number and statement in MAIN-5.
7334   1957             
7335   1957 18 0D               JR      L1937           ; forward to exit via OUT-CHAR.
7336   1959             
7337   1959             ; ---
7338   1959             
7339   1959             ; -> the single entry point.
7340   1959             
7341   1959             ;; OUT-SP-NO
7342   1959 AF          L192A:  XOR     A               ; initialize digit to 0
7343   195A             
7344   195A             ;; OUT-SP-1
7345   195A 09          L192B:  ADD     HL,BC           ; add negative number to HL.
7346   195B 3C                  INC     A               ; increment digit
7347   195C 38 FC               JR      C,L192B         ; back to OUT-SP-1 until no carry from
7348   195E                                             ; the addition.
7349   195E             
7350   195E ED 42               SBC     HL,BC           ; cancel the last addition
7351   1960 3D                  DEC     A               ; and decrement the digit.
7352   1961 28 F1               JR      Z,L1925         ; back to OUT-SP-2 if it is zero.
7353   1963             
7354   1963 C3 1E 16            JP      L15EF           ; jump back to exit via OUT-CODE.    ->
7355   1966             
7356   1966             
7357   1966             ; -------------------------------------
7358   1966             ; Outputting characters in a BASIC line
7359   1966             ; -------------------------------------
7360   1966             ; This subroutine ...
7361   1966             	
7362   1966             ;; OUT-CHAR
7363   1966 CD 4A 2D    L1937:  CALL    L2D1B           ; routine NUMERIC tests if it is a digit ?
7364   1969 30 30               JR      NC,L196C        ; to OUT-CH-3 to print digit without
7365   196B                                             ; changing mode. Will be 'K' mode if digits
7366   196B                                             ; are at beginning of edit line.
7367   196B             
7368   196B FE 21               CP      $21             ; less than quote character ?
7369   196D 38 2C               JR      C,L196C         ; to OUT-CH-3 to output controls and space.
7370   196F             
7371   196F FD CB 01 96         RES     2,(IY+$01)      ; initialize FLAGS to 'K' mode and leave
7372   1973                                             ; unchanged if this character would precede
7373   1973                                             ; a keyword.
7374   1973             
7375   1973 FE CB               CP      $CB             ; is character 'THEN' token ?
7376   1975 28 24               JR      Z,L196C         ; to OUT-CH-3 to output if so.
7377   1977             
7378   1977 FE 3A               CP      $3A             ; is it ':' ?
7379   1979 20 0E               JR      NZ,L195A        ; to OUT-CH-1 if not statement separator
7380   197B                                             ; to change mode back to 'L'.
7381   197B             
7382   197B FD CB 37 6E         BIT     5,(IY+$37)      ; FLAGX  - Input Mode ??
7383   197F 20 16               JR      NZ,L1968        ; to OUT-CH-2 if in input as no statements.
7384   1981                                             ; Note. this check should seemingly be at
7385   1981                                             ; the start. Commands seem inappropriate in
7386   1981                                             ; INPUT mode and are rejected by the syntax
7387   1981                                             ; checker anyway.
7388   1981                                             ; unless INPUT LINE is being used.
7389   1981             
7390   1981 FD CB 30 56         BIT     2,(IY+$30)      ; test FLAGS2 - is the ':' within quotes ?
7391   1985 28 14               JR      Z,L196C         ; to OUT-CH-3 if ':' is outside quoted text.
7392   1987             
7393   1987 18 0E               JR      L1968           ; to OUT-CH-2 as ':' is within quotes
7394   1989             
7395   1989             ; ---
7396   1989             
7397   1989             ;; OUT-CH-1
7398   1989 FE 22       L195A:  CP      $22             ; is it quote character '"'  ?
7399   198B 20 0A               JR      NZ,L1968        ; to OUT-CH-2 with others to set 'L' mode.
7400   198D             
7401   198D F5                  PUSH    AF              ; save character.
7402   198E 3A 6A 5C            LD      A,($5C6A)       ; fetch FLAGS2.
7403   1991 EE 04               XOR     $04             ; toggle the quotes flag.
7404   1993 32 6A 5C            LD      ($5C6A),A       ; update FLAGS2
7405   1996 F1                  POP     AF              ; and restore character.
7406   1997             
7407   1997             ;; OUT-CH-2
7408   1997 FD CB 01 D6 L1968:  SET     2,(IY+$01)      ; update FLAGS - signal L mode if the cursor
7409   199B                                             ; is next.
7410   199B             
7411   199B             ;; OUT-CH-3
7412   199B D7          L196C:  RST     10H             ; PRINT-A vectors the character to
7413   199C                                             ; channel 'S', 'K', 'R' or 'P'.
7414   199C C9                  RET                     ; return.
7415   199D             
7416   199D             ; -------------------------------------------
7417   199D             ; Get starting address of line, or line after
7418   199D             ; -------------------------------------------
7419   199D             ; This routine is used often to get the address, in HL, of a BASIC line
7420   199D             ; number supplied in HL, or failing that the address of the following line
7421   199D             ; and the address of the previous line in DE.
7422   199D             
7423   199D             ;; LINE-ADDR
7424   199D E5          L196E:  PUSH    HL              ; save line number in HL register
7425   199E 2A 53 5C            LD      HL,($5C53)      ; fetch start of program from PROG
7426   19A1 54                  LD      D,H             ; transfer address to
7427   19A2 5D                  LD      E,L             ; the DE register pair.
7428   19A3             
7429   19A3             ;; LINE-AD-1
7430   19A3 C1          L1974:  POP     BC              ; restore the line number to BC
7431   19A4 CD AF 19            CALL    L1980           ; routine CP-LINES compares with that
7432   19A7                                             ; addressed by HL
7433   19A7 D0                  RET     NC              ; return if line has been passed or matched.
7434   19A8                                             ; if NZ, address of previous is in DE
7435   19A8             
7436   19A8 C5                  PUSH    BC              ; save the current line number
7437   19A9 CD E7 19            CALL    L19B8           ; routine NEXT-ONE finds address of next
7438   19AC                                             ; line number in DE, previous in HL.
7439   19AC EB                  EX      DE,HL           ; switch so next in HL
7440   19AD 18 F4               JR      L1974           ; back to LINE-AD-1 for another comparison
7441   19AF             
7442   19AF             ; --------------------
7443   19AF             ; Compare line numbers
7444   19AF             ; --------------------
7445   19AF             ; This routine compares a line number supplied in BC with an addressed
7446   19AF             ; line number pointed to by HL.
7447   19AF             
7448   19AF             ;; CP-LINES
7449   19AF 7E          L1980:  LD      A,(HL)          ; Load the high byte of line number and
7450   19B0 B8                  CP      B               ; compare with that of supplied line number.
7451   19B1 C0                  RET     NZ              ; return if yet to match (carry will be set).
7452   19B2             
7453   19B2 23                  INC     HL              ; address low byte of
7454   19B3 7E                  LD      A,(HL)          ; number and pick up in A.
7455   19B4 2B                  DEC     HL              ; step back to first position.
7456   19B5 B9                  CP      C               ; now compare.
7457   19B6 C9                  RET                     ; zero set if exact match.
7458   19B7                                             ; carry set if yet to match.
7459   19B7                                             ; no carry indicates a match or
7460   19B7                                             ; next available BASIC line or
7461   19B7                                             ; program end marker.
7462   19B7             
7463   19B7             ; -------------------
7464   19B7             ; Find each statement
7465   19B7             ; -------------------
7466   19B7             ; The single entry point EACH-STMT is used to
7467   19B7             ; 1) To find the D'th statement in a line.
7468   19B7             ; 2) To find a token in held E.
7469   19B7             
7470   19B7             ;; not-used
7471   19B7 23          L1988:  INC     HL              ;
7472   19B8 23                  INC     HL              ;
7473   19B9 23                  INC     HL              ;
7474   19BA             
7475   19BA             ; -> entry point.
7476   19BA             
7477   19BA             ;; EACH-STMT
7478   19BA 22 5D 5C    L198B:  LD      ($5C5D),HL      ; save HL in CH_ADD
7479   19BD 0E 00               LD      C,$00           ; initialize quotes flag
7480   19BF             
7481   19BF             ;; EACH-S-1
7482   19BF 15          L1990:  DEC     D               ; decrease statement count
7483   19C0 C8                  RET     Z               ; return if zero
7484   19C1             
7485   19C1             
7486   19C1 E7                  RST     20H             ; NEXT-CHAR
7487   19C2 BB                  CP      E               ; is it the search token ?
7488   19C3 20 04               JR      NZ,L199A        ; forward to EACH-S-3 if not
7489   19C5             
7490   19C5 A7                  AND     A               ; clear carry
7491   19C6 C9                  RET                     ; return signalling success.
7492   19C7             
7493   19C7             ; ---
7494   19C7             
7495   19C7             ;; EACH-S-2
7496   19C7 23          L1998:  INC     HL              ; next address
7497   19C8 7E                  LD      A,(HL)          ; next character
7498   19C9             
7499   19C9             ;; EACH-S-3
7500   19C9 CD E5 18    L199A:  CALL    L18B6           ; routine NUMBER skips if number marker
7501   19CC 22 5D 5C            LD      ($5C5D),HL      ; save in CH_ADD
7502   19CF FE 22               CP      $22             ; is it quotes '"' ?
7503   19D1 20 01               JR      NZ,L19A5        ; to EACH-S-4 if not
7504   19D3             
7505   19D3 0D                  DEC     C               ; toggle bit 0 of C
7506   19D4             
7507   19D4             ;; EACH-S-4
7508   19D4 FE 3A       L19A5:  CP      $3A             ; is it ':'
7509   19D6 28 04               JR      Z,L19AD         ; to EACH-S-5
7510   19D8             
7511   19D8 FE CB               CP      $CB             ; 'THEN'
7512   19DA 20 04               JR      NZ,L19B1        ; to EACH-S-6
7513   19DC             
7514   19DC             ;; EACH-S-5
7515   19DC CB 41       L19AD:  BIT     0,C             ; is it in quotes
7516   19DE 28 DF               JR      Z,L1990         ; to EACH-S-1 if not
7517   19E0             
7518   19E0             ;; EACH-S-6
7519   19E0 FE 0D       L19B1:  CP      $0D             ; end of line ?
7520   19E2 20 E3               JR      NZ,L1998        ; to EACH-S-2
7521   19E4             
7522   19E4 15                  DEC     D               ; decrease the statement counter
7523   19E5                                             ; which should be zero else
7524   19E5                                             ; 'Statement Lost'.
7525   19E5 37                  SCF                     ; set carry flag - not found
7526   19E6 C9                  RET                     ; return
7527   19E7             
7528   19E7             ; -----------------------------------------------------------------------
7529   19E7             ; Storage of variables. For full details - see chapter 24.
7530   19E7             ; ZX Spectrum BASIC Programming by Steven Vickers 1982.
7531   19E7             ; It is bits 7-5 of the first character of a variable that allow
7532   19E7             ; the six types to be distinguished. Bits 4-0 are the reduced letter.
7533   19E7             ; So any variable name is higher that $3F and can be distinguished
7534   19E7             ; also from the variables area end-marker $80.
7535   19E7             ;
7536   19E7             ; 76543210 meaning                               brief outline of format.
7537   19E7             ; -------- ------------------------              -----------------------
7538   19E7             ; 010      string variable.                      2 byte length + contents.
7539   19E7             ; 110      string array.                         2 byte length + contents.
7540   19E7             ; 100      array of numbers.                     2 byte length + contents.
7541   19E7             ; 011      simple numeric variable.              5 bytes.
7542   19E7             ; 101      variable length named numeric.        5 bytes.
7543   19E7             ; 111      for-next loop variable.               18 bytes.
7544   19E7             ; 10000000 the variables area end-marker.
7545   19E7             ;
7546   19E7             ; Note. any of the above seven will serve as a program end-marker.
7547   19E7             ;
7548   19E7             ; -----------------------------------------------------------------------
7549   19E7             
7550   19E7             ; ------------
7551   19E7             ; Get next one
7552   19E7             ; ------------
7553   19E7             ; This versatile routine is used to find the address of the next line
7554   19E7             ; in the program area or the next variable in the variables area.
7555   19E7             ; The reason one routine is made to handle two apparently unrelated tasks
7556   19E7             ; is that it can be called indiscriminately when merging a line or a
7557   19E7             ; variable.
7558   19E7             
7559   19E7             ;; NEXT-ONE
7560   19E7 E5          L19B8:  PUSH    HL              ; save the pointer address.
7561   19E8 7E                  LD      A,(HL)          ; get first byte.
7562   19E9 FE 40               CP      $40             ; compare with upper limit for line numbers.
7563   19EB 38 17               JR      C,L19D5         ; forward to NEXT-O-3 if within BASIC area.
7564   19ED             
7565   19ED             ; the continuation here is for the next variable unless the supplied
7566   19ED             ; line number was erroneously over 16383. see RESTORE command.
7567   19ED             
7568   19ED CB 6F               BIT     5,A             ; is it a string or an array variable ?
7569   19EF 28 14               JR      Z,L19D6         ; forward to NEXT-O-4 to compute length.
7570   19F1             
7571   19F1 87                  ADD     A,A             ; test bit 6 for single-character variables.
7572   19F2 FA F6 19            JP      M,L19C7         ; forward to NEXT-O-1 if so
7573   19F5             
7574   19F5 3F                  CCF                     ; clear the carry for long-named variables.
7575   19F6                                             ; it remains set for for-next loop variables.
7576   19F6             
7577   19F6             ;; NEXT-O-1
7578   19F6 01 05 00    L19C7:  LD      BC,$0005        ; set BC to 5 for floating point number
7579   19F9 30 02               JR      NC,L19CE        ; forward to NEXT-O-2 if not a for/next
7580   19FB                                             ; variable.
7581   19FB             
7582   19FB 0E 12               LD      C,$12           ; set BC to eighteen locations.
7583   19FD                                             ; value, limit, step, line and statement.
7584   19FD             
7585   19FD             ; now deal with long-named variables
7586   19FD             
7587   19FD             ;; NEXT-O-2
7588   19FD 17          L19CE:  RLA                     ; test if character inverted. carry will also
7589   19FE                                             ; be set for single character variables
7590   19FE 23                  INC     HL              ; address next location.
7591   19FF 7E                  LD      A,(HL)          ; and load character.
7592   1A00 30 FB               JR      NC,L19CE        ; back to NEXT-O-2 if not inverted bit.
7593   1A02                                             ; forward immediately with single character
7594   1A02                                             ; variable names.
7595   1A02             
7596   1A02 18 06               JR      L19DB           ; forward to NEXT-O-5 to add length of
7597   1A04                                             ; floating point number(s etc.).
7598   1A04             
7599   1A04             ; ---
7600   1A04             
7601   1A04             ; this branch is for line numbers.
7602   1A04             
7603   1A04             ;; NEXT-O-3
7604   1A04 23          L19D5:  INC     HL              ; increment pointer to low byte of line no.
7605   1A05             
7606   1A05             ; strings and arrays rejoin here
7607   1A05             
7608   1A05             ;; NEXT-O-4
7609   1A05 23          L19D6:  INC     HL              ; increment to address the length low byte.
7610   1A06 4E                  LD      C,(HL)          ; transfer to C and
7611   1A07 23                  INC     HL              ; point to high byte of length.
7612   1A08 46                  LD      B,(HL)          ; transfer that to B
7613   1A09 23                  INC     HL              ; point to start of BASIC/variable contents.
7614   1A0A             
7615   1A0A             ; the three types of numeric variables rejoin here
7616   1A0A             
7617   1A0A             ;; NEXT-O-5
7618   1A0A 09          L19DB:  ADD     HL,BC           ; add the length to give address of next
7619   1A0B                                             ; line/variable in HL.
7620   1A0B D1                  POP     DE              ; restore previous address to DE.
7621   1A0C             
7622   1A0C             ; ------------------
7623   1A0C             ; Difference routine
7624   1A0C             ; ------------------
7625   1A0C             ; This routine terminates the above routine and is also called from the
7626   1A0C             ; start of the next routine to calculate the length to reclaim.
7627   1A0C             
7628   1A0C             ;; DIFFER
7629   1A0C A7          L19DD:  AND     A               ; prepare for true subtraction.
7630   1A0D ED 52               SBC     HL,DE           ; subtract the two pointers.
7631   1A0F 44                  LD      B,H             ; transfer result
7632   1A10 4D                  LD      C,L             ; to BC register pair.
7633   1A11 19                  ADD     HL,DE           ; add back
7634   1A12 EB                  EX      DE,HL           ; and switch pointers
7635   1A13 C9                  RET                     ; return values are the length of area in BC,
7636   1A14                                             ; low pointer (previous) in HL,
7637   1A14                                             ; high pointer (next) in DE.
7638   1A14             
7639   1A14             ; -----------------------
7640   1A14             ; Handle reclaiming space
7641   1A14             ; -----------------------
7642   1A14             ;
7643   1A14             
7644   1A14             ;; RECLAIM-1
7645   1A14 CD 0C 1A    L19E5:  CALL    L19DD           ; routine DIFFER immediately above
7646   1A17             
7647   1A17             ;; RECLAIM-2
7648   1A17 C5          L19E8:  PUSH    BC              ;
7649   1A18             
7650   1A18 78                  LD      A,B             ;
7651   1A19 2F                  CPL                     ;
7652   1A1A 47                  LD      B,A             ;
7653   1A1B 79                  LD      A,C             ;
7654   1A1C 2F                  CPL                     ;
7655   1A1D 4F                  LD      C,A             ;
7656   1A1E 03                  INC     BC              ;
7657   1A1F             
7658   1A1F CD 93 16            CALL    L1664           ; routine POINTERS
7659   1A22 EB                  EX      DE,HL           ;
7660   1A23 E1                  POP     HL              ;
7661   1A24             
7662   1A24 19                  ADD     HL,DE           ;
7663   1A25 D5                  PUSH    DE              ;
7664   1A26 ED B0               LDIR                    ; copy bytes
7665   1A28             
7666   1A28 E1                  POP     HL              ;
7667   1A29 C9                  RET                     ;
7668   1A2A             
7669   1A2A             ; ----------------------------------------
7670   1A2A             ; Read line number of line in editing area
7671   1A2A             ; ----------------------------------------
7672   1A2A             ; This routine reads a line number in the editing area returning the number
7673   1A2A             ; in the BC register or zero if no digits exist before commands.
7674   1A2A             ; It is called from LINE-SCAN to check the syntax of the digits.
7675   1A2A             ; It is called from MAIN-3 to extract the line number in preparation for
7676   1A2A             ; inclusion of the line in the BASIC program area.
7677   1A2A             ;
7678   1A2A             ; Interestingly the calculator stack is moved from its normal place at the
7679   1A2A             ; end of dynamic memory to an adequate area within the system variables area.
7680   1A2A             ; This ensures that in a low memory situation, that valid line numbers can
7681   1A2A             ; be extracted without raising an error and that memory can be reclaimed
7682   1A2A             ; by deleting lines. If the stack was in its normal place then a situation
7683   1A2A             ; arises whereby the Spectrum becomes locked with no means of reclaiming space.
7684   1A2A             
7685   1A2A             ;; E-LINE-NO
7686   1A2A 2A 59 5C    L19FB:  LD      HL,($5C59)      ; load HL from system variable E_LINE.
7687   1A2D             
7688   1A2D 2B                  DEC     HL              ; decrease so that NEXT_CHAR can be used
7689   1A2E                                             ; without skipping the first digit.
7690   1A2E             
7691   1A2E 22 5D 5C            LD      ($5C5D),HL      ; store in the system variable CH_ADD.
7692   1A31             
7693   1A31 E7                  RST     20H             ; NEXT-CHAR skips any noise and white-space
7694   1A32                                             ; to point exactly at the first digit.
7695   1A32             
7696   1A32 21 92 5C            LD      HL,$5C92        ; use MEM-0 as a temporary calculator stack
7697   1A35                                             ; an overhead of three locations are needed.
7698   1A35 22 65 5C            LD      ($5C65),HL      ; set new STKEND.
7699   1A38             
7700   1A38 CD 6A 2D            CALL    L2D3B           ; routine INT-TO-FP will read digits till
7701   1A3B                                             ; a non-digit found.
7702   1A3B CD D1 2D            CALL    L2DA2           ; routine FP-TO-BC will retrieve number
7703   1A3E                                             ; from stack at membot.
7704   1A3E 38 04               JR      C,L1A15         ; forward to E-L-1 if overflow i.e. > 65535.
7705   1A40                                             ; 'Nonsense in BASIC'
7706   1A40             
7707   1A40 21 F0 D8            LD      HL,$D8F0        ; load HL with value -9999
7708   1A43 09                  ADD     HL,BC           ; add to line number in BC
7709   1A44             
7710   1A44             ;; E-L-1
7711   1A44 DA B9 1C    L1A15:  JP      C,L1C8A         ; to REPORT-C 'Nonsense in BASIC' if over.
7712   1A47                                             ; Note. As ERR_SP points to ED_ERROR
7713   1A47                                             ; the report is never produced although
7714   1A47                                             ; the RST $08 will update X_PTR leading to
7715   1A47                                             ; the error marker being displayed when
7716   1A47                                             ; the ED_LOOP is reiterated.
7717   1A47                                             ; in fact, since it is immediately
7718   1A47                                             ; cancelled, any report will do.
7719   1A47             
7720   1A47             ; a line in the range 0 - 9999 has been entered.
7721   1A47             
7722   1A47 C3 F4 16            JP      L16C5           ; jump back to SET-STK to set the calculator 
7723   1A4A                                             ; stack back to its normal place and exit 
7724   1A4A                                             ; from there.
7725   1A4A             
7726   1A4A             ; ---------------------------------
7727   1A4A             ; Report and line number outputting
7728   1A4A             ; ---------------------------------
7729   1A4A             ; Entry point OUT-NUM-1 is used by the Error Reporting code to print
7730   1A4A             ; the line number and later the statement number held in BC.
7731   1A4A             ; If the statement was part of a direct command then -2 is used as a
7732   1A4A             ; dummy line number so that zero will be printed in the report.
7733   1A4A             ; This routine is also used to print the exponent of E-format numbers.
7734   1A4A             ;
7735   1A4A             ; Entry point OUT-NUM-2 is used from OUT-LINE to output the line number
7736   1A4A             ; addressed by HL with leading spaces if necessary.
7737   1A4A             
7738   1A4A             ;; OUT-NUM-1
7739   1A4A D5          L1A1B:  PUSH    DE              ; save the
7740   1A4B E5                  PUSH    HL              ; registers.
7741   1A4C AF                  XOR     A               ; set A to zero.
7742   1A4D CB 78               BIT     7,B             ; is the line number minus two ?
7743   1A4F 20 20               JR      NZ,L1A42        ; forward to OUT-NUM-4 if so to print zero 
7744   1A51                                             ; for a direct command.
7745   1A51             
7746   1A51 60                  LD      H,B             ; transfer the
7747   1A52 69                  LD      L,C             ; number to HL.
7748   1A53 1E FF               LD      E,$FF           ; signal 'no leading zeros'.
7749   1A55 18 08               JR      L1A30           ; forward to continue at OUT-NUM-3
7750   1A57             
7751   1A57             ; ---
7752   1A57             
7753   1A57             ; from OUT-LINE - HL addresses line number.
7754   1A57             
7755   1A57             ;; OUT-NUM-2
7756   1A57 D5          L1A28:  PUSH    DE              ; save flags
7757   1A58 56                  LD      D,(HL)          ; high byte to D
7758   1A59 23                  INC     HL              ; address next
7759   1A5A 5E                  LD      E,(HL)          ; low byte to E
7760   1A5B E5                  PUSH    HL              ; save pointer
7761   1A5C EB                  EX      DE,HL           ; transfer number to HL
7762   1A5D 1E 20               LD      E,$20           ; signal 'output leading spaces'
7763   1A5F             
7764   1A5F             ;; OUT-NUM-3
7765   1A5F 01 18 FC    L1A30:  LD      BC,$FC18        ; value -1000
7766   1A62 CD 59 19            CALL    L192A           ; routine OUT-SP-NO outputs space or number
7767   1A65 01 9C FF            LD      BC,$FF9C        ; value -100
7768   1A68 CD 59 19            CALL    L192A           ; routine OUT-SP-NO
7769   1A6B 0E F6               LD      C,$F6           ; value -10 ( B is still $FF )
7770   1A6D CD 59 19            CALL    L192A           ; routine OUT-SP-NO
7771   1A70 7D                  LD      A,L             ; remainder to A.
7772   1A71             
7773   1A71             ;; OUT-NUM-4
7774   1A71 CD 1E 16    L1A42:  CALL    L15EF           ; routine OUT-CODE for final digit.
7775   1A74                                             ; else report code zero wouldn't get
7776   1A74                                             ; printed.
7777   1A74 E1                  POP     HL              ; restore the
7778   1A75 D1                  POP     DE              ; registers and
7779   1A76 C9                  RET                     ; return.
7780   1A77             
7781   1A77             
7782   1A77             ;***************************************************
7783   1A77             ;** Part 7. BASIC LINE AND COMMAND INTERPRETATION **
7784   1A77             ;***************************************************
7785   1A77             
7786   1A77             ; ----------------
7787   1A77             ; The offset table
7788   1A77             ; ----------------
7789   1A77             ; The BASIC interpreter has found a command code $CE - $FF
7790   1A77             ; which is then reduced to range $00 - $31 and added to the base address
7791   1A77             ; of this table to give the address of an offset which, when added to
7792   1A77             ; the offset therein, gives the location in the following parameter table
7793   1A77             ; where a list of class codes, separators and addresses relevant to the
7794   1A77             ; command exists.
7795   1A77             
7796   1A77             ;; offst-tbl
7797   1A77 B1          L1A48:  DEFB    L1AF9 - $       ; B1 offset to Address: P-DEF-FN
7798   1A78 CB                  DEFB    L1B14 - $       ; CB offset to Address: P-CAT
7799   1A79 BC                  DEFB    L1B06 - $       ; BC offset to Address: P-FORMAT
7800   1A7A BF                  DEFB    L1B0A - $       ; BF offset to Address: P-MOVE
7801   1A7B C4                  DEFB    L1B10 - $       ; C4 offset to Address: P-ERASE
7802   1A7C AF                  DEFB    L1AFC - $       ; AF offset to Address: P-OPEN
7803   1A7D B4                  DEFB    L1B02 - $       ; B4 offset to Address: P-CLOSE
7804   1A7E 93                  DEFB    L1AE2 - $       ; 93 offset to Address: P-MERGE
7805   1A7F 91                  DEFB    L1AE1 - $       ; 91 offset to Address: P-VERIFY
7806   1A80 92                  DEFB    L1AE3 - $       ; 92 offset to Address: P-BEEP
7807   1A81 95                  DEFB    L1AE7 - $       ; 95 offset to Address: P-CIRCLE
7808   1A82 98                  DEFB    L1AEB - $       ; 98 offset to Address: P-INK
7809   1A83 98                  DEFB    L1AEC - $       ; 98 offset to Address: P-PAPER
7810   1A84 98                  DEFB    L1AED - $       ; 98 offset to Address: P-FLASH
7811   1A85 98                  DEFB    L1AEE - $       ; 98 offset to Address: P-BRIGHT
7812   1A86 98                  DEFB    L1AEF - $       ; 98 offset to Address: P-INVERSE
7813   1A87 98                  DEFB    L1AF0 - $       ; 98 offset to Address: P-OVER
7814   1A88 98                  DEFB    L1AF1 - $       ; 98 offset to Address: P-OUT
7815   1A89 7F                  DEFB    L1AD9 - $       ; 7F offset to Address: P-LPRINT
7816   1A8A 81                  DEFB    L1ADC - $       ; 81 offset to Address: P-LLIST
7817   1A8B 2E                  DEFB    L1A8A - $       ; 2E offset to Address: P-STOP
7818   1A8C 6C                  DEFB    L1AC9 - $       ; 6C offset to Address: P-READ
7819   1A8D 6E                  DEFB    L1ACC - $       ; 6E offset to Address: P-DATA
7820   1A8E 70                  DEFB    L1ACF - $       ; 70 offset to Address: P-RESTORE
7821   1A8F 48                  DEFB    L1AA8 - $       ; 48 offset to Address: P-NEW
7822   1A90 94                  DEFB    L1AF5 - $       ; 94 offset to Address: P-BORDER
7823   1A91 56                  DEFB    L1AB8 - $       ; 56 offset to Address: P-CONT
7824   1A92 3F                  DEFB    L1AA2 - $       ; 3F offset to Address: P-DIM
7825   1A93 41                  DEFB    L1AA5 - $       ; 41 offset to Address: P-REM
7826   1A94 2B                  DEFB    L1A90 - $       ; 2B offset to Address: P-FOR
7827   1A95 17                  DEFB    L1A7D - $       ; 17 offset to Address: P-GO-TO
7828   1A96 1F                  DEFB    L1A86 - $       ; 1F offset to Address: P-GO-SUB
7829   1A97 37                  DEFB    L1A9F - $       ; 37 offset to Address: P-INPUT
7830   1A98 77                  DEFB    L1AE0 - $       ; 77 offset to Address: P-LOAD
7831   1A99 44                  DEFB    L1AAE - $       ; 44 offset to Address: P-LIST
7832   1A9A 0F                  DEFB    L1A7A - $       ; 0F offset to Address: P-LET
7833   1A9B 59                  DEFB    L1AC5 - $       ; 59 offset to Address: P-PAUSE
7834   1A9C 2B                  DEFB    L1A98 - $       ; 2B offset to Address: P-NEXT
7835   1A9D 43                  DEFB    L1AB1 - $       ; 43 offset to Address: P-POKE
7836   1A9E 2D                  DEFB    L1A9C - $       ; 2D offset to Address: P-PRINT
7837   1A9F 51                  DEFB    L1AC1 - $       ; 51 offset to Address: P-PLOT
7838   1AA0 3A                  DEFB    L1AAB - $       ; 3A offset to Address: P-RUN
7839   1AA1 6D                  DEFB    L1ADF - $       ; 6D offset to Address: P-SAVE
7840   1AA2 42                  DEFB    L1AB5 - $       ; 42 offset to Address: P-RANDOM
7841   1AA3 0D                  DEFB    L1A81 - $       ; 0D offset to Address: P-IF
7842   1AA4 49                  DEFB    L1ABE - $       ; 49 offset to Address: P-CLS
7843   1AA5 5C                  DEFB    L1AD2 - $       ; 5C offset to Address: P-DRAW
7844   1AA6 44                  DEFB    L1ABB - $       ; 44 offset to Address: P-CLEAR
7845   1AA7 15                  DEFB    L1A8D - $       ; 15 offset to Address: P-RETURN
7846   1AA8 5D                  DEFB    L1AD6 - $       ; 5D offset to Address: P-COPY
7847   1AA9             
7848   1AA9             
7849   1AA9             ; -------------------------------
7850   1AA9             ; The parameter or "Syntax" table
7851   1AA9             ; -------------------------------
7852   1AA9             ; For each command there exists a variable list of parameters.
7853   1AA9             ; If the character is greater than a space it is a required separator.
7854   1AA9             ; If less, then it is a command class in the range 00 - 0B.
7855   1AA9             ; Note that classes 00, 03 and 05 will fetch the addresses from this table.
7856   1AA9             ; Some classes e.g. 07 and 0B have the same address in all invocations
7857   1AA9             ; and the command is re-computed from the low-byte of the parameter address.
7858   1AA9             ; Some e.g. 02 are only called once so a call to the command is made from
7859   1AA9             ; within the class routine rather than holding the address within the table.
7860   1AA9             ; Some class routines check syntax entirely and some leave this task for the
7861   1AA9             ; command itself.
7862   1AA9             ; Others for example CIRCLE (x,y,z) check the first part (x,y) using the
7863   1AA9             ; class routine and the final part (,z) within the command.
7864   1AA9             ; The last few commands appear to have been added in a rush but their syntax
7865   1AA9             ; is rather simple e.g. MOVE "M1","M2"
7866   1AA9             
7867   1AA9             ;; P-LET
7868   1AA9 01          L1A7A:  DEFB    $01             ; Class-01 - A variable is required.
7869   1AAA 3D                  DEFB    $3D             ; Separator:  '='
7870   1AAB 02                  DEFB    $02             ; Class-02 - An expression, numeric or string,
7871   1AAC                                             ; must follow.
7872   1AAC             
7873   1AAC             ;; P-GO-TO
7874   1AAC 06          L1A7D:  DEFB    $06             ; Class-06 - A numeric expression must follow.
7875   1AAD 00                  DEFB    $00             ; Class-00 - No further operands.
7876   1AAE 96 1E               DEFW    L1E67           ; Address: $1E67; Address: GO-TO
7877   1AB0             
7878   1AB0             ;; P-IF
7879   1AB0 06          L1A81:  DEFB    $06             ; Class-06 - A numeric expression must follow.
7880   1AB1 CB                  DEFB    $CB             ; Separator:  'THEN'
7881   1AB2 05                  DEFB    $05             ; Class-05 - Variable syntax checked
7882   1AB3                                             ; by routine.
7883   1AB3 1F 1D               DEFW    L1CF0           ; Address: $1CF0; Address: IF
7884   1AB5             
7885   1AB5             ;; P-GO-SUB
7886   1AB5 06          L1A86:  DEFB    $06             ; Class-06 - A numeric expression must follow.
7887   1AB6 00                  DEFB    $00             ; Class-00 - No further operands.
7888   1AB7 1C 1F               DEFW    L1EED           ; Address: $1EED; Address: GO-SUB
7889   1AB9             
7890   1AB9             ;; P-STOP
7891   1AB9 00          L1A8A:  DEFB    $00             ; Class-00 - No further operands.
7892   1ABA 1D 1D               DEFW    L1CEE           ; Address: $1CEE; Address: STOP
7893   1ABC             
7894   1ABC             ;; P-RETURN
7895   1ABC 00          L1A8D:  DEFB    $00             ; Class-00 - No further operands.
7896   1ABD 52 1F               DEFW    L1F23           ; Address: $1F23; Address: RETURN
7897   1ABF             
7898   1ABF             ;; P-FOR
7899   1ABF 04          L1A90:  DEFB    $04             ; Class-04 - A single character variable must
7900   1AC0                                             ; follow.
7901   1AC0 3D                  DEFB    $3D             ; Separator:  '='
7902   1AC1 06                  DEFB    $06             ; Class-06 - A numeric expression must follow.
7903   1AC2 CC                  DEFB    $CC             ; Separator:  'TO'
7904   1AC3 06                  DEFB    $06             ; Class-06 - A numeric expression must follow.
7905   1AC4 05                  DEFB    $05             ; Class-05 - Variable syntax checked
7906   1AC5                                             ; by routine.
7907   1AC5 32 1D               DEFW    L1D03           ; Address: $1D03; Address: FOR
7908   1AC7             
7909   1AC7             ;; P-NEXT
7910   1AC7 04          L1A98:  DEFB    $04             ; Class-04 - A single character variable must
7911   1AC8                                             ; follow.
7912   1AC8 00                  DEFB    $00             ; Class-00 - No further operands.
7913   1AC9 DA 1D               DEFW    L1DAB           ; Address: $1DAB; Address: NEXT
7914   1ACB             
7915   1ACB             ;; P-PRINT
7916   1ACB 05          L1A9C:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7917   1ACC                                             ; by routine.
7918   1ACC FC 1F               DEFW    L1FCD           ; Address: $1FCD; Address: PRINT
7919   1ACE             
7920   1ACE             ;; P-INPUT
7921   1ACE 05          L1A9F:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7922   1ACF                                             ; by routine.
7923   1ACF B8 20               DEFW    L2089           ; Address: $2089; Address: INPUT
7924   1AD1             
7925   1AD1             ;; P-DIM
7926   1AD1 05          L1AA2:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7927   1AD2                                             ; by routine.
7928   1AD2 31 2C               DEFW    L2C02           ; Address: $2C02; Address: DIM
7929   1AD4             
7930   1AD4             ;; P-REM
7931   1AD4 05          L1AA5:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7932   1AD5                                             ; by routine.
7933   1AD5 E1 1B               DEFW    L1BB2           ; Address: $1BB2; Address: REM
7934   1AD7             
7935   1AD7             ;; P-NEW
7936   1AD7 00          L1AA8:  DEFB    $00             ; Class-00 - No further operands.
7937   1AD8 E6 11               DEFW    L11B7           ; Address: $11B7; Address: NEW
7938   1ADA             
7939   1ADA             ;; P-RUN
7940   1ADA 03          L1AAB:  DEFB    $03             ; Class-03 - A numeric expression may follow
7941   1ADB                                             ; else default to zero.
7942   1ADB D0 1E               DEFW    L1EA1           ; Address: $1EA1; Address: RUN
7943   1ADD             
7944   1ADD             ;; P-LIST
7945   1ADD 05          L1AAE:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7946   1ADE                                             ; by routine.
7947   1ADE 28 18               DEFW    L17F9           ; Address: $17F9; Address: LIST
7948   1AE0             
7949   1AE0             ;; P-POKE
7950   1AE0 08          L1AB1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
7951   1AE1                                             ; expressions required.
7952   1AE1 00                  DEFB    $00             ; Class-00 - No further operands.
7953   1AE2 AF 1E               DEFW    L1E80           ; Address: $1E80; Address: POKE
7954   1AE4             
7955   1AE4             ;; P-RANDOM
7956   1AE4 03          L1AB5:  DEFB    $03             ; Class-03 - A numeric expression may follow
7957   1AE5                                             ; else default to zero.
7958   1AE5 7E 1E               DEFW    L1E4F           ; Address: $1E4F; Address: RANDOMIZE
7959   1AE7             
7960   1AE7             ;; P-CONT
7961   1AE7 00          L1AB8:  DEFB    $00             ; Class-00 - No further operands.
7962   1AE8 8E 1E               DEFW    L1E5F           ; Address: $1E5F; Address: CONTINUE
7963   1AEA             
7964   1AEA             ;; P-CLEAR
7965   1AEA 03          L1ABB:  DEFB    $03             ; Class-03 - A numeric expression may follow
7966   1AEB                                             ; else default to zero.
7967   1AEB DB 1E               DEFW    L1EAC           ; Address: $1EAC; Address: CLEAR
7968   1AED             
7969   1AED             ;; P-CLS
7970   1AED 00          L1ABE:  DEFB    $00             ; Class-00 - No further operands.
7971   1AEE 9A 0D               DEFW    L0D6B           ; Address: $0D6B; Address: CLS
7972   1AF0             
7973   1AF0             ;; P-PLOT
7974   1AF0 09          L1AC1:  DEFB    $09             ; Class-09 - Two comma-separated numeric
7975   1AF1                                             ; expressions required with optional colour
7976   1AF1                                             ; items.
7977   1AF1 00                  DEFB    $00             ; Class-00 - No further operands.
7978   1AF2 0B 23               DEFW    L22DC           ; Address: $22DC; Address: PLOT
7979   1AF4             
7980   1AF4             ;; P-PAUSE
7981   1AF4 06          L1AC5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
7982   1AF5 00                  DEFB    $00             ; Class-00 - No further operands.
7983   1AF6 69 1F               DEFW    L1F3A           ; Address: $1F3A; Address: PAUSE
7984   1AF8             
7985   1AF8             ;; P-READ
7986   1AF8 05          L1AC9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7987   1AF9                                             ; by routine.
7988   1AF9 1C 1E               DEFW    L1DED           ; Address: $1DED; Address: READ
7989   1AFB             
7990   1AFB             ;; P-DATA
7991   1AFB 05          L1ACC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
7992   1AFC                                             ; by routine.
7993   1AFC 56 1E               DEFW    L1E27           ; Address: $1E27; Address: DATA
7994   1AFE             
7995   1AFE             ;; P-RESTORE
7996   1AFE 03          L1ACF:  DEFB    $03             ; Class-03 - A numeric expression may follow
7997   1AFF                                             ; else default to zero.
7998   1AFF 71 1E               DEFW    L1E42           ; Address: $1E42; Address: RESTORE
7999   1B01             
8000   1B01             ;; P-DRAW
8001   1B01 09          L1AD2:  DEFB    $09             ; Class-09 - Two comma-separated numeric
8002   1B02                                             ; expressions required with optional colour
8003   1B02                                             ; items.
8004   1B02 05                  DEFB    $05             ; Class-05 - Variable syntax checked
8005   1B03                                             ; by routine.
8006   1B03 B1 23               DEFW    L2382           ; Address: $2382; Address: DRAW
8007   1B05             
8008   1B05             ;; P-COPY
8009   1B05 00          L1AD6:  DEFB    $00             ; Class-00 - No further operands.
8010   1B06 DB 0E               DEFW    L0EAC           ; Address: $0EAC; Address: COPY
8011   1B08             
8012   1B08             ;; P-LPRINT
8013   1B08 05          L1AD9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
8014   1B09                                             ; by routine.
8015   1B09 F8 1F               DEFW    L1FC9           ; Address: $1FC9; Address: LPRINT
8016   1B0B             
8017   1B0B             ;; P-LLIST
8018   1B0B 05          L1ADC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
8019   1B0C                                             ; by routine.
8020   1B0C 24 18               DEFW    L17F5           ; Address: $17F5; Address: LLIST
8021   1B0E             
8022   1B0E             ;; P-SAVE
8023   1B0E 0B          L1ADF:  DEFB    $0B             ; Class-0B - Offset address converted to tape
8024   1B0F                                             ; command.
8025   1B0F             
8026   1B0F             ;; P-LOAD
8027   1B0F 0B          L1AE0:  DEFB    $0B             ; Class-0B - Offset address converted to tape
8028   1B10                                             ; command.
8029   1B10             
8030   1B10             ;; P-VERIFY
8031   1B10 0B          L1AE1:  DEFB    $0B             ; Class-0B - Offset address converted to tape
8032   1B11                                             ; command.
8033   1B11             
8034   1B11             ;; P-MERGE
8035   1B11 0B          L1AE2:  DEFB    $0B             ; Class-0B - Offset address converted to tape
8036   1B12                                             ; command.
8037   1B12             
8038   1B12             ;; P-BEEP
8039   1B12 08          L1AE3:  DEFB    $08             ; Class-08 - Two comma-separated numeric
8040   1B13                                             ; expressions required.
8041   1B13 00                  DEFB    $00             ; Class-00 - No further operands.
8042   1B14 27 04               DEFW    L03F8           ; Address: $03F8; Address: BEEP
8043   1B16             
8044   1B16             ;; P-CIRCLE
8045   1B16 09          L1AE7:  DEFB    $09             ; Class-09 - Two comma-separated numeric
8046   1B17                                             ; expressions required with optional colour
8047   1B17                                             ; items.
8048   1B17 05                  DEFB    $05             ; Class-05 - Variable syntax checked
8049   1B18                                             ; by routine.
8050   1B18 4F 23               DEFW    L2320           ; Address: $2320; Address: CIRCLE
8051   1B1A             
8052   1B1A             ;; P-INK
8053   1B1A 07          L1AEB:  DEFB    $07             ; Class-07 - Offset address is converted to
8054   1B1B                                             ; colour code.
8055   1B1B             
8056   1B1B             ;; P-PAPER
8057   1B1B 07          L1AEC:  DEFB    $07             ; Class-07 - Offset address is converted to
8058   1B1C                                             ; colour code.
8059   1B1C             
8060   1B1C             ;; P-FLASH
8061   1B1C 07          L1AED:  DEFB    $07             ; Class-07 - Offset address is converted to
8062   1B1D                                             ; colour code.
8063   1B1D             
8064   1B1D             ;; P-BRIGHT
8065   1B1D 07          L1AEE:  DEFB    $07             ; Class-07 - Offset address is converted to
8066   1B1E                                             ; colour code.
8067   1B1E             
8068   1B1E             ;; P-INVERSE
8069   1B1E 07          L1AEF:  DEFB    $07             ; Class-07 - Offset address is converted to
8070   1B1F                                             ; colour code.
8071   1B1F             
8072   1B1F             ;; P-OVER
8073   1B1F 07          L1AF0:  DEFB    $07             ; Class-07 - Offset address is converted to
8074   1B20                                             ; colour code.
8075   1B20             
8076   1B20             ;; P-OUT
8077   1B20 08          L1AF1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
8078   1B21                                             ; expressions required.
8079   1B21 00                  DEFB    $00             ; Class-00 - No further operands.
8080   1B22 A9 1E               DEFW    L1E7A           ; Address: $1E7A; Address: OUT
8081   1B24             
8082   1B24             ;; P-BORDER
8083   1B24 06          L1AF5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
8084   1B25 00                  DEFB    $00             ; Class-00 - No further operands.
8085   1B26 C3 22               DEFW    L2294           ; Address: $2294; Address: BORDER
8086   1B28             
8087   1B28             ;; P-DEF-FN
8088   1B28 05          L1AF9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
8089   1B29                                             ; by routine.
8090   1B29 8F 1F               DEFW    L1F60           ; Address: $1F60; Address: DEF-FN
8091   1B2B             
8092   1B2B             ;; P-OPEN
8093   1B2B 06          L1AFC:  DEFB    $06             ; Class-06 - A numeric expression must follow.
8094   1B2C 2C                  DEFB    $2C             ; Separator:  ','          see Footnote *
8095   1B2D 0A                  DEFB    $0A             ; Class-0A - A string expression must follow.
8096   1B2E 00                  DEFB    $00             ; Class-00 - No further operands.
8097   1B2F 65 17               DEFW    L1736           ; Address: $1736; Address: OPEN
8098   1B31             
8099   1B31             ;; P-CLOSE
8100   1B31 06          L1B02:  DEFB    $06             ; Class-06 - A numeric expression must follow.
8101   1B32 00                  DEFB    $00             ; Class-00 - No further operands.
8102   1B33 14 17               DEFW    L16E5           ; Address: $16E5; Address: CLOSE
8103   1B35             
8104   1B35             ;; P-FORMAT
8105   1B35 0A          L1B06:  DEFB    $0A             ; Class-0A - A string expression must follow.
8106   1B36 00                  DEFB    $00             ; Class-00 - No further operands.
8107   1B37 C2 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
8108   1B39             
8109   1B39             ;; P-MOVE
8110   1B39 0A          L1B0A:  DEFB    $0A             ; Class-0A - A string expression must follow.
8111   1B3A 2C                  DEFB    $2C             ; Separator:  ','
8112   1B3B 0A                  DEFB    $0A             ; Class-0A - A string expression must follow.
8113   1B3C 00                  DEFB    $00             ; Class-00 - No further operands.
8114   1B3D C2 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
8115   1B3F             
8116   1B3F             ;; P-ERASE
8117   1B3F 0A          L1B10:  DEFB    $0A             ; Class-0A - A string expression must follow.
8118   1B40 00                  DEFB    $00             ; Class-00 - No further operands.
8119   1B41 C2 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
8120   1B43             
8121   1B43             ;; P-CAT
8122   1B43 00          L1B14:  DEFB    $00             ; Class-00 - No further operands.
8123   1B44 C2 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
8124   1B46             
8125   1B46             ; * Note that a comma is required as a separator with the OPEN command
8126   1B46             ; but the Interface 1 programmers relaxed this allowing ';' as an
8127   1B46             ; alternative for their channels creating a confusing mixture of
8128   1B46             ; allowable syntax as it is this ROM which opens or re-opens the
8129   1B46             ; normal channels.
8130   1B46             
8131   1B46             ; -------------------------------
8132   1B46             ; Main parser (BASIC interpreter)
8133   1B46             ; -------------------------------
8134   1B46             ; This routine is called once from MAIN-2 when the BASIC line is to
8135   1B46             ; be entered or re-entered into the Program area and the syntax
8136   1B46             ; requires checking.
8137   1B46             
8138   1B46             ;; LINE-SCAN
8139   1B46 FD CB 01 BE L1B17:  RES     7,(IY+$01)      ; update FLAGS - signal checking syntax
8140   1B4A CD 2A 1A            CALL    L19FB           ; routine E-LINE-NO              >>
8141   1B4D                                             ; fetches the line number if in range.
8142   1B4D             
8143   1B4D AF                  XOR     A               ; clear the accumulator.
8144   1B4E 32 47 5C            LD      ($5C47),A       ; set statement number SUBPPC to zero.
8145   1B51 3D                  DEC     A               ; set accumulator to $FF.
8146   1B52 32 3A 5C            LD      ($5C3A),A       ; set ERR_NR to 'OK' - 1.
8147   1B55 18 01               JR      L1B29           ; forward to continue at STMT-L-1.
8148   1B57             
8149   1B57             ; --------------
8150   1B57             ; Statement loop
8151   1B57             ; --------------
8152   1B57             ;
8153   1B57             ;
8154   1B57             
8155   1B57             ;; STMT-LOOP
8156   1B57 E7          L1B28:  RST     20H             ; NEXT-CHAR
8157   1B58             
8158   1B58             ; -> the entry point from above or LINE-RUN
8159   1B58             ;; STMT-L-1
8160   1B58 CD EE 16    L1B29:  CALL    L16BF           ; routine SET-WORK clears workspace etc.
8161   1B5B             
8162   1B5B FD 34 0D            INC     (IY+$0D)        ; increment statement number SUBPPC
8163   1B5E FA B9 1C            JP      M,L1C8A         ; to REPORT-C to raise
8164   1B61                                             ; 'Nonsense in BASIC' if over 127.
8165   1B61             
8166   1B61 DF                  RST     18H             ; GET-CHAR
8167   1B62             
8168   1B62 06 00               LD      B,$00           ; set B to zero for later indexing.
8169   1B64                                             ; early so any other reason ???
8170   1B64             
8171   1B64 FE 0D               CP      $0D             ; is character carriage return ?
8172   1B66                                             ; i.e. an empty statement.
8173   1B66 28 7A               JR      Z,L1BB3         ; forward to LINE-END if so.
8174   1B68             
8175   1B68 FE 3A               CP      $3A             ; is it statement end marker ':' ?
8176   1B6A                                             ; i.e. another type of empty statement.
8177   1B6A 28 EB               JR      Z,L1B28         ; back to STMT-LOOP if so.
8178   1B6C             
8179   1B6C 21 A5 1B            LD      HL,L1B76        ; address: STMT-RET
8180   1B6F E5                  PUSH    HL              ; is now pushed as a return address
8181   1B70 4F                  LD      C,A             ; transfer the current character to C.
8182   1B71             
8183   1B71             ; advance CH_ADD to a position after command and test if it is a command.
8184   1B71             
8185   1B71 E7                  RST     20H             ; NEXT-CHAR to advance pointer
8186   1B72 79                  LD      A,C             ; restore current character
8187   1B73 D6 CE               SUB     $CE             ; subtract 'DEF FN' - first command
8188   1B75 DA B9 1C            JP      C,L1C8A         ; jump to REPORT-C if less than a command
8189   1B78                                             ; raising 
8190   1B78                                             ; 'Nonsense in BASIC'
8191   1B78             
8192   1B78 4F                  LD      C,A             ; put the valid command code back in C.
8193   1B79                                             ; register B is zero.
8194   1B79 21 77 1A            LD      HL,L1A48        ; address: offst-tbl
8195   1B7C 09                  ADD     HL,BC           ; index into table with one of 50 commands.
8196   1B7D 4E                  LD      C,(HL)          ; pick up displacement to syntax table entry.
8197   1B7E 09                  ADD     HL,BC           ; add to address the relevant entry.
8198   1B7F 18 03               JR      L1B55           ; forward to continue at GET-PARAM
8199   1B81             
8200   1B81             ; ----------------------
8201   1B81             ; The main scanning loop
8202   1B81             ; ----------------------
8203   1B81             ; not documented properly
8204   1B81             ;
8205   1B81             
8206   1B81             ;; SCAN-LOOP
8207   1B81 2A 74 5C    L1B52:  LD      HL,($5C74)      ; fetch temporary address from T_ADDR
8208   1B84                                             ; during subsequent loops.
8209   1B84             
8210   1B84             ; -> the initial entry point with HL addressing start of syntax table entry.
8211   1B84             
8212   1B84             ;; GET-PARAM
8213   1B84 7E          L1B55:  LD      A,(HL)          ; pick up the parameter.
8214   1B85 23                  INC     HL              ; address next one.
8215   1B86 22 74 5C            LD      ($5C74),HL      ; save pointer in system variable T_ADDR
8216   1B89             
8217   1B89 01 81 1B            LD      BC,L1B52        ; address: SCAN-LOOP
8218   1B8C C5                  PUSH    BC              ; is now pushed on stack as looping address.
8219   1B8D 4F                  LD      C,A             ; store parameter in C.
8220   1B8E FE 20               CP      $20             ; is it greater than ' '  ?
8221   1B90 30 0C               JR      NC,L1B6F        ; forward to SEPARATOR to check that correct
8222   1B92                                             ; separator appears in statement if so.
8223   1B92             
8224   1B92 21 30 1C            LD      HL,L1C01        ; address: class-tbl.
8225   1B95 06 00               LD      B,$00           ; prepare to index into the class table.
8226   1B97 09                  ADD     HL,BC           ; index to find displacement to routine.
8227   1B98 4E                  LD      C,(HL)          ; displacement to BC
8228   1B99 09                  ADD     HL,BC           ; add to address the CLASS routine.
8229   1B9A E5                  PUSH    HL              ; push the address on the stack.
8230   1B9B             
8231   1B9B DF                  RST     18H             ; GET-CHAR - HL points to place in statement.
8232   1B9C             
8233   1B9C 05                  DEC     B               ; reset the zero flag - the initial state
8234   1B9D                                             ; for all class routines.
8235   1B9D             
8236   1B9D C9                  RET                     ; and make an indirect jump to routine
8237   1B9E                                             ; and then SCAN-LOOP (also on stack).
8238   1B9E             
8239   1B9E             ; Note. one of the class routines will eventually drop the return address
8240   1B9E             ; off the stack breaking out of the above seemingly endless loop.
8241   1B9E             
8242   1B9E             ; -----------------------
8243   1B9E             ; THE 'SEPARATOR' ROUTINE
8244   1B9E             ; -----------------------
8245   1B9E             ;   This routine is called once to verify that the mandatory separator
8246   1B9E             ;   present in the parameter table is also present in the correct
8247   1B9E             ;   location following the command.  For example, the 'THEN' token after
8248   1B9E             ;   the 'IF' token and expression.
8249   1B9E             
8250   1B9E             ;; SEPARATOR
8251   1B9E DF          L1B6F:  RST     18H             ; GET-CHAR
8252   1B9F B9                  CP      C               ; does it match the character in C ?
8253   1BA0 C2 B9 1C            JP      NZ,L1C8A        ; jump forward to REPORT-C if not
8254   1BA3                                             ; 'Nonsense in BASIC'.
8255   1BA3             
8256   1BA3 E7                  RST     20H             ; NEXT-CHAR advance to next character
8257   1BA4 C9                  RET                     ; return.
8258   1BA5             
8259   1BA5             ; ------------------------------
8260   1BA5             ; Come here after interpretation
8261   1BA5             ; ------------------------------
8262   1BA5             ;
8263   1BA5             ;
8264   1BA5             
8265   1BA5             ;; STMT-RET
8266   1BA5 CD 83 1F    L1B76:  CALL    L1F54           ; routine BREAK-KEY is tested after every
8267   1BA8                                             ; statement.
8268   1BA8 38 02               JR      C,L1B7D         ; step forward to STMT-R-1 if not pressed.
8269   1BAA             
8270   1BAA             ;; REPORT-L
8271   1BAA CF          L1B7B:  RST     08H             ; ERROR-1
8272   1BAB 14                  DEFB    $14             ; Error Report: BREAK into program
8273   1BAC             
8274   1BAC             ;; STMT-R-1
8275   1BAC FD CB 0A 7E L1B7D:  BIT     7,(IY+$0A)      ; test NSPPC - will be set if $FF -
8276   1BB0                                             ; no jump to be made.
8277   1BB0 20 71               JR      NZ,L1BF4        ; forward to STMT-NEXT if a program line.
8278   1BB2             
8279   1BB2 2A 42 5C            LD      HL,($5C42)      ; fetch line number from NEWPPC
8280   1BB5 CB 7C               BIT     7,H             ; will be set if minus two - direct command(s)
8281   1BB7 28 14               JR      Z,L1B9E         ; forward to LINE-NEW if a jump is to be
8282   1BB9                                             ; made to a new program line/statement.
8283   1BB9             
8284   1BB9             ; --------------------
8285   1BB9             ; Run a direct command
8286   1BB9             ; --------------------
8287   1BB9             ; A direct command is to be run or, if continuing from above,
8288   1BB9             ; the next statement of a direct command is to be considered.
8289   1BB9             
8290   1BB9             ;; LINE-RUN
8291   1BB9 21 FE FF    L1B8A:  LD      HL,$FFFE        ; The dummy value minus two
8292   1BBC 22 45 5C            LD      ($5C45),HL      ; is set/reset as line number in PPC.
8293   1BBF 2A 61 5C            LD      HL,($5C61)      ; point to end of line + 1 - WORKSP.
8294   1BC2 2B                  DEC     HL              ; now point to $80 end-marker.
8295   1BC3 ED 5B 59 5C         LD      DE,($5C59)      ; address the start of line E_LINE.
8296   1BC7 1B                  DEC     DE              ; now location before - for GET-CHAR.
8297   1BC8 3A 44 5C            LD      A,($5C44)       ; load statement to A from NSPPC.
8298   1BCB 18 33               JR      L1BD1           ; forward to NEXT-LINE.
8299   1BCD             
8300   1BCD             ; ------------------------------
8301   1BCD             ; Find start address of new line
8302   1BCD             ; ------------------------------
8303   1BCD             ; The branch was to here if a jump is to made to a new line number
8304   1BCD             ; and statement.
8305   1BCD             ; That is the previous statement was a GO TO, GO SUB, RUN, RETURN, NEXT etc..
8306   1BCD             
8307   1BCD             ;; LINE-NEW
8308   1BCD CD 9D 19    L1B9E:  CALL    L196E           ; routine LINE-ADDR gets address of line
8309   1BD0                                             ; returning zero flag set if line found.
8310   1BD0 3A 44 5C            LD      A,($5C44)       ; fetch new statement from NSPPC
8311   1BD3 28 19               JR      Z,L1BBF         ; forward to LINE-USE if line matched.
8312   1BD5             
8313   1BD5             ; continue as must be a direct command.
8314   1BD5             
8315   1BD5 A7                  AND     A               ; test statement which should be zero
8316   1BD6 20 43               JR      NZ,L1BEC        ; forward to REPORT-N if not.
8317   1BD8                                             ; 'Statement lost'
8318   1BD8             
8319   1BD8             ; 
8320   1BD8             
8321   1BD8 47                  LD      B,A             ; save statement in B.??
8322   1BD9 7E                  LD      A,(HL)          ; fetch high byte of line number.
8323   1BDA E6 C0               AND     $C0             ; test if using direct command
8324   1BDC                                             ; a program line is less than $3F
8325   1BDC 78                  LD      A,B             ; retrieve statement.
8326   1BDD                                             ; (we can assume it is zero).
8327   1BDD 28 0F               JR      Z,L1BBF         ; forward to LINE-USE if was a program line
8328   1BDF             
8329   1BDF             ; Alternatively a direct statement has finished correctly.
8330   1BDF             
8331   1BDF             ;; REPORT-0
8332   1BDF CF          L1BB0:  RST     08H             ; ERROR-1
8333   1BE0 FF                  DEFB    $FF             ; Error Report: OK
8334   1BE1             
8335   1BE1             ; -----------------
8336   1BE1             ; THE 'REM' COMMAND
8337   1BE1             ; -----------------
8338   1BE1             ; The REM command routine.
8339   1BE1             ; The return address STMT-RET is dropped and the rest of line ignored.
8340   1BE1             
8341   1BE1             ;; REM
8342   1BE1 C1          L1BB2:  POP     BC              ; drop return address STMT-RET and
8343   1BE2                                             ; continue ignoring rest of line.
8344   1BE2             
8345   1BE2             ; ------------
8346   1BE2             ; End of line?
8347   1BE2             ; ------------
8348   1BE2             ;
8349   1BE2             ;
8350   1BE2             
8351   1BE2             ;; LINE-END
8352   1BE2 CD 5F 25    L1BB3:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
8353   1BE5 C8                  RET     Z               ; return if checking syntax.
8354   1BE6             
8355   1BE6 2A 55 5C            LD      HL,($5C55)      ; fetch NXTLIN to HL.
8356   1BE9 3E C0               LD      A,$C0           ; test against the
8357   1BEB A6                  AND     (HL)            ; system limit $3F.
8358   1BEC C0                  RET     NZ              ; return if more as must be
8359   1BED                                             ; end of program.
8360   1BED                                             ; (or direct command)
8361   1BED             
8362   1BED AF                  XOR     A               ; set statement to zero.
8363   1BEE             
8364   1BEE             ; and continue to set up the next following line and then consider this new one.
8365   1BEE             
8366   1BEE             ; ---------------------
8367   1BEE             ; General line checking
8368   1BEE             ; ---------------------
8369   1BEE             ; The branch was here from LINE-NEW if BASIC is branching.
8370   1BEE             ; or a continuation from above if dealing with a new sequential line.
8371   1BEE             ; First make statement zero number one leaving others unaffected.
8372   1BEE             
8373   1BEE             ;; LINE-USE
8374   1BEE FE 01       L1BBF:  CP      $01             ; will set carry if zero.
8375   1BF0 CE 00               ADC     A,$00           ; add in any carry.
8376   1BF2             
8377   1BF2 56                  LD      D,(HL)          ; high byte of line number to D.
8378   1BF3 23                  INC     HL              ; advance pointer.
8379   1BF4 5E                  LD      E,(HL)          ; low byte of line number to E.
8380   1BF5 ED 53 45 5C         LD      ($5C45),DE      ; set system variable PPC.
8381   1BF9             
8382   1BF9 23                  INC     HL              ; advance pointer.
8383   1BFA 5E                  LD      E,(HL)          ; low byte of line length to E.
8384   1BFB 23                  INC     HL              ; advance pointer.
8385   1BFC 56                  LD      D,(HL)          ; high byte of line length to D.
8386   1BFD             
8387   1BFD EB                  EX      DE,HL           ; swap pointer to DE before
8388   1BFE 19                  ADD     HL,DE           ; adding to address the end of line.
8389   1BFF 23                  INC     HL              ; advance to start of next line.
8390   1C00             
8391   1C00             ; -----------------------------
8392   1C00             ; Update NEXT LINE but consider
8393   1C00             ; previous line or edit line.
8394   1C00             ; -----------------------------
8395   1C00             ; The pointer will be the next line if continuing from above or to
8396   1C00             ; edit line end-marker ($80) if from LINE-RUN.
8397   1C00             
8398   1C00             ;; NEXT-LINE
8399   1C00 22 55 5C    L1BD1:  LD      ($5C55),HL      ; store pointer in system variable NXTLIN
8400   1C03             
8401   1C03 EB                  EX      DE,HL           ; bring back pointer to previous or edit line
8402   1C04 22 5D 5C            LD      ($5C5D),HL      ; and update CH_ADD with character address.
8403   1C07             
8404   1C07 57                  LD      D,A             ; store statement in D.
8405   1C08 1E 00               LD      E,$00           ; set E to zero to suppress token searching
8406   1C0A                                             ; if EACH-STMT is to be called.
8407   1C0A FD 36 0A FF         LD      (IY+$0A),$FF    ; set statement NSPPC to $FF signalling
8408   1C0E                                             ; no jump to be made.
8409   1C0E 15                  DEC     D               ; decrement and test statement
8410   1C0F FD 72 0D            LD      (IY+$0D),D      ; set SUBPPC to decremented statement number.
8411   1C12 CA 57 1B            JP      Z,L1B28         ; to STMT-LOOP if result zero as statement is
8412   1C15                                             ; at start of line and address is known.
8413   1C15             
8414   1C15 14                  INC     D               ; else restore statement.
8415   1C16 CD BA 19            CALL    L198B           ; routine EACH-STMT finds the D'th statement
8416   1C19                                             ; address as E does not contain a token.
8417   1C19 28 08               JR      Z,L1BF4         ; forward to STMT-NEXT if address found.
8418   1C1B             
8419   1C1B             ;; REPORT-N
8420   1C1B CF          L1BEC:  RST     08H             ; ERROR-1
8421   1C1C 16                  DEFB    $16             ; Error Report: Statement lost
8422   1C1D             
8423   1C1D             ; -----------------
8424   1C1D             ; End of statement?
8425   1C1D             ; -----------------
8426   1C1D             ; This combination of routines is called from 20 places when
8427   1C1D             ; the end of a statement should have been reached and all preceding
8428   1C1D             ; syntax is in order.
8429   1C1D             
8430   1C1D             ;; CHECK-END
8431   1C1D CD 5F 25    L1BEE:  CALL    L2530           ; routine SYNTAX-Z
8432   1C20 C0                  RET     NZ              ; return immediately in runtime
8433   1C21             
8434   1C21 C1                  POP     BC              ; drop address of calling routine.
8435   1C22 C1                  POP     BC              ; drop address STMT-RET.
8436   1C23                                             ; and continue to find next statement.
8437   1C23             
8438   1C23             ; --------------------
8439   1C23             ; Go to next statement
8440   1C23             ; --------------------
8441   1C23             ; Acceptable characters at this point are carriage return and ':'.
8442   1C23             ; If so go to next statement which in the first case will be on next line.
8443   1C23             
8444   1C23             ;; STMT-NEXT
8445   1C23 DF          L1BF4:  RST     18H             ; GET-CHAR - ignoring white space etc.
8446   1C24             
8447   1C24 FE 0D               CP      $0D             ; is it carriage return ?
8448   1C26 28 BA               JR      Z,L1BB3         ; back to LINE-END if so.
8449   1C28             
8450   1C28 FE 3A               CP      $3A             ; is it ':' ?
8451   1C2A CA 57 1B            JP      Z,L1B28         ; jump back to STMT-LOOP to consider
8452   1C2D                                             ; further statements
8453   1C2D             
8454   1C2D C3 B9 1C            JP      L1C8A           ; jump to REPORT-C with any other character
8455   1C30                                             ; 'Nonsense in BASIC'.
8456   1C30             
8457   1C30             ; Note. the two-byte sequence 'rst 08; defb $0b' could replace the above jp.
8458   1C30             
8459   1C30             ; -------------------
8460   1C30             ; Command class table
8461   1C30             ; -------------------
8462   1C30             ;
8463   1C30             
8464   1C30             ;; class-tbl
8465   1C30 0F          L1C01:  DEFB    L1C10 - $       ; 0F offset to Address: CLASS-00
8466   1C31 1D                  DEFB    L1C1F - $       ; 1D offset to Address: CLASS-01
8467   1C32 4B                  DEFB    L1C4E - $       ; 4B offset to Address: CLASS-02
8468   1C33 09                  DEFB    L1C0D - $       ; 09 offset to Address: CLASS-03
8469   1C34 67                  DEFB    L1C6C - $       ; 67 offset to Address: CLASS-04
8470   1C35 0B                  DEFB    L1C11 - $       ; 0B offset to Address: CLASS-05
8471   1C36 7B                  DEFB    L1C82 - $       ; 7B offset to Address: CLASS-06
8472   1C37 8E                  DEFB    L1C96 - $       ; 8E offset to Address: CLASS-07
8473   1C38 71                  DEFB    L1C7A - $       ; 71 offset to Address: CLASS-08
8474   1C39 B4                  DEFB    L1CBE - $       ; B4 offset to Address: CLASS-09
8475   1C3A 81                  DEFB    L1C8C - $       ; 81 offset to Address: CLASS-0A
8476   1C3B CF                  DEFB    L1CDB - $       ; CF offset to Address: CLASS-0B
8477   1C3C             
8478   1C3C             
8479   1C3C             ; --------------------------------
8480   1C3C             ; Command classes---00, 03, and 05
8481   1C3C             ; --------------------------------
8482   1C3C             ; class-03 e.g. RUN or RUN 200   ;  optional operand
8483   1C3C             ; class-00 e.g. CONTINUE         ;  no operand
8484   1C3C             ; class-05 e.g. PRINT            ;  variable syntax checked by routine
8485   1C3C             
8486   1C3C             ;; CLASS-03
8487   1C3C CD 0D 1D    L1C0D:  CALL    L1CDE           ; routine FETCH-NUM
8488   1C3F             
8489   1C3F             ;; CLASS-00
8490   1C3F             
8491   1C3F BF          L1C10:  CP      A               ; reset zero flag.
8492   1C40             
8493   1C40             ; if entering here then all class routines are entered with zero reset.
8494   1C40             
8495   1C40             ;; CLASS-05
8496   1C40 C1          L1C11:  POP     BC              ; drop address SCAN-LOOP.
8497   1C41 CC 1D 1C            CALL    Z,L1BEE         ; if zero set then call routine CHECK-END >>>
8498   1C44                                             ; as should be no further characters.
8499   1C44             
8500   1C44 EB                  EX      DE,HL           ; save HL to DE.
8501   1C45 2A 74 5C            LD      HL,($5C74)      ; fetch T_ADDR
8502   1C48 4E                  LD      C,(HL)          ; fetch low byte of routine
8503   1C49 23                  INC     HL              ; address next.
8504   1C4A 46                  LD      B,(HL)          ; fetch high byte of routine.
8505   1C4B EB                  EX      DE,HL           ; restore HL from DE
8506   1C4C C5                  PUSH    BC              ; push the address
8507   1C4D C9                  RET                     ; and make an indirect jump to the command.
8508   1C4E             
8509   1C4E             ; --------------------------------
8510   1C4E             ; Command classes---01, 02, and 04
8511   1C4E             ; --------------------------------
8512   1C4E             ; class-01  e.g. LET A = 2*3     ; a variable is reqd
8513   1C4E             
8514   1C4E             ; This class routine is also called from INPUT and READ to find the
8515   1C4E             ; destination variable for an assignment.
8516   1C4E             
8517   1C4E             ;; CLASS-01
8518   1C4E CD E1 28    L1C1F:  CALL    L28B2           ; routine LOOK-VARS returns carry set if not
8519   1C51                                             ; found in runtime.
8520   1C51             
8521   1C51             ; ----------------------
8522   1C51             ; Variable in assignment
8523   1C51             ; ----------------------
8524   1C51             ;
8525   1C51             ;
8526   1C51             
8527   1C51             ;; VAR-A-1
8528   1C51 FD 36 37 00 L1C22:  LD      (IY+$37),$00    ; set FLAGX to zero
8529   1C55 30 08               JR      NC,L1C30        ; forward to VAR-A-2 if found or checking
8530   1C57                                             ; syntax.
8531   1C57             
8532   1C57 FD CB 37 CE         SET     1,(IY+$37)      ; FLAGX  - Signal a new variable
8533   1C5B 20 18               JR      NZ,L1C46        ; to VAR-A-3 if not assigning to an array
8534   1C5D                                             ; e.g. LET a$(3,3) = "X"
8535   1C5D             
8536   1C5D             ;; REPORT-2
8537   1C5D CF          L1C2E:  RST     08H             ; ERROR-1
8538   1C5E 01                  DEFB    $01             ; Error Report: Variable not found
8539   1C5F             
8540   1C5F             ;; VAR-A-2
8541   1C5F CC C5 29    L1C30:  CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
8542   1C62 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
8543   1C66 20 0D               JR      NZ,L1C46        ; to VAR-A-3 if numeric
8544   1C68             
8545   1C68 AF                  XOR     A               ; default to array/slice - to be retained.
8546   1C69 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
8547   1C6C C4 20 2C            CALL    NZ,L2BF1        ; routine STK-FETCH is called in runtime
8548   1C6F                                             ; may overwrite A with 1.
8549   1C6F 21 71 5C            LD      HL,$5C71        ; address system variable FLAGX
8550   1C72 B6                  OR      (HL)            ; set bit 0 if simple variable to be reclaimed
8551   1C73 77                  LD      (HL),A          ; update FLAGX
8552   1C74 EB                  EX      DE,HL           ; start of string/subscript to DE
8553   1C75             
8554   1C75             ;; VAR-A-3
8555   1C75 ED 43 72 5C L1C46:  LD      ($5C72),BC      ; update STRLEN
8556   1C79 22 4D 5C            LD      ($5C4D),HL      ; and DEST of assigned string.
8557   1C7C C9                  RET                     ; return.
8558   1C7D             
8559   1C7D             ; -------------------------------------------------
8560   1C7D             ; class-02 e.g. LET a = 1 + 1   ; an expression must follow
8561   1C7D             
8562   1C7D             ;; CLASS-02
8563   1C7D C1          L1C4E:  POP     BC              ; drop return address SCAN-LOOP
8564   1C7E CD 85 1C            CALL    L1C56           ; routine VAL-FET-1 is called to check
8565   1C81                                             ; expression and assign result in runtime
8566   1C81 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END checks nothing else
8567   1C84                                             ; is present in statement.
8568   1C84 C9                  RET                     ; Return
8569   1C85             
8570   1C85             ; -------------
8571   1C85             ; Fetch a value
8572   1C85             ; -------------
8573   1C85             ;
8574   1C85             ;
8575   1C85             
8576   1C85             ;; VAL-FET-1
8577   1C85 3A 3B 5C    L1C56:  LD      A,($5C3B)       ; initial FLAGS to A
8578   1C88             
8579   1C88             ;; VAL-FET-2
8580   1C88 F5          L1C59:  PUSH    AF              ; save A briefly
8581   1C89 CD 2A 25            CALL    L24FB           ; routine SCANNING evaluates expression.
8582   1C8C F1                  POP     AF              ; restore A
8583   1C8D FD 56 01            LD      D,(IY+$01)      ; post-SCANNING FLAGS to D
8584   1C90 AA                  XOR     D               ; xor the two sets of flags
8585   1C91 E6 40               AND     $40             ; pick up bit 6 of xored FLAGS should be zero
8586   1C93 20 24               JR      NZ,L1C8A        ; forward to REPORT-C if not zero
8587   1C95                                             ; 'Nonsense in BASIC' - results don't agree.
8588   1C95             
8589   1C95 CB 7A               BIT     7,D             ; test FLAGS - is syntax being checked ?
8590   1C97 C2 2E 2B            JP      NZ,L2AFF        ; jump forward to LET to make the assignment
8591   1C9A                                             ; in runtime.
8592   1C9A             
8593   1C9A C9                  RET                     ; but return from here if checking syntax.
8594   1C9B             
8595   1C9B             ; ------------------
8596   1C9B             ; Command class---04
8597   1C9B             ; ------------------
8598   1C9B             ; class-04 e.g. FOR i            ; a single character variable must follow
8599   1C9B             
8600   1C9B             ;; CLASS-04
8601   1C9B CD E1 28    L1C6C:  CALL    L28B2           ; routine LOOK-VARS
8602   1C9E F5                  PUSH    AF              ; preserve flags.
8603   1C9F 79                  LD      A,C             ; fetch type - should be 011xxxxx
8604   1CA0 F6 9F               OR      $9F             ; combine with 10011111.
8605   1CA2 3C                  INC     A               ; test if now $FF by incrementing.
8606   1CA3 20 14               JR      NZ,L1C8A        ; forward to REPORT-C if result not zero.
8607   1CA5             
8608   1CA5 F1                  POP     AF              ; else restore flags.
8609   1CA6 18 A9               JR      L1C22           ; back to VAR-A-1
8610   1CA8             
8611   1CA8             
8612   1CA8             ; --------------------------------
8613   1CA8             ; Expect numeric/string expression
8614   1CA8             ; --------------------------------
8615   1CA8             ; This routine is used to get the two coordinates of STRING$, ATTR and POINT.
8616   1CA8             ; It is also called from PRINT-ITEM to get the two numeric expressions that
8617   1CA8             ; follow the AT ( in PRINT AT, INPUT AT).
8618   1CA8             
8619   1CA8             ;; NEXT-2NUM
8620   1CA8 E7          L1C79:  RST     20H             ; NEXT-CHAR advance past 'AT' or '('.
8621   1CA9             
8622   1CA9             ; --------
8623   1CA9             ; class-08 e.g. POKE 65535,2     ; two numeric expressions separated by comma
8624   1CA9             ;; CLASS-08
8625   1CA9             ;; EXPT-2NUM
8626   1CA9 CD B1 1C    L1C7A:  CALL    L1C82           ; routine EXPT-1NUM is called for first
8627   1CAC                                             ; numeric expression
8628   1CAC FE 2C               CP      $2C             ; is character ',' ?
8629   1CAE 20 09               JR      NZ,L1C8A        ; to REPORT-C if not required separator.
8630   1CB0                                             ; 'Nonsense in BASIC'.
8631   1CB0             
8632   1CB0 E7                  RST     20H             ; NEXT-CHAR
8633   1CB1             
8634   1CB1             ; ->
8635   1CB1             ;  class-06  e.g. GOTO a*1000   ; a numeric expression must follow
8636   1CB1             ;; CLASS-06
8637   1CB1             ;; EXPT-1NUM
8638   1CB1 CD 2A 25    L1C82:  CALL    L24FB           ; routine SCANNING
8639   1CB4 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
8640   1CB8 C0                  RET     NZ              ; return if result is numeric.
8641   1CB9             
8642   1CB9             ;; REPORT-C
8643   1CB9 CF          L1C8A:  RST     08H             ; ERROR-1
8644   1CBA 0B                  DEFB    $0B             ; Error Report: Nonsense in BASIC
8645   1CBB             
8646   1CBB             ; ---------------------------------------------------------------
8647   1CBB             ; class-0A e.g. ERASE "????"    ; a string expression must follow.
8648   1CBB             ;                               ; these only occur in unimplemented commands
8649   1CBB             ;                               ; although the routine expt-exp is called
8650   1CBB             ;                               ; from SAVE-ETC
8651   1CBB             
8652   1CBB             ;; CLASS-0A
8653   1CBB             ;; EXPT-EXP
8654   1CBB CD 2A 25    L1C8C:  CALL    L24FB           ; routine SCANNING
8655   1CBE FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
8656   1CC2 C8                  RET     Z               ; return if string result.
8657   1CC3             
8658   1CC3 18 F4               JR      L1C8A           ; back to REPORT-C if numeric.
8659   1CC5             
8660   1CC5             ; ---------------------
8661   1CC5             ; Set permanent colours
8662   1CC5             ; class 07
8663   1CC5             ; ---------------------
8664   1CC5             ; class-07 e.g. PAPER 6          ; a single class for a collection of
8665   1CC5             ;                               ; similar commands. Clever.
8666   1CC5             ;
8667   1CC5             ; Note. these commands should ensure that current channel is 'S'
8668   1CC5             
8669   1CC5             ;; CLASS-07
8670   1CC5 FD CB 01 7E L1C96:  BIT     7,(IY+$01)      ; test FLAGS - checking syntax only ?
8671   1CC9                                             ; Note. there is a subroutine to do this.
8672   1CC9 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
8673   1CCD C4 7C 0D            CALL    NZ,L0D4D        ; routine TEMPS is called in runtime.
8674   1CD0 F1                  POP     AF              ; drop return address SCAN-LOOP
8675   1CD1 3A 74 5C            LD      A,($5C74)       ; T_ADDR_lo to accumulator.
8676   1CD4                                             ; points to '$07' entry + 1
8677   1CD4                                             ; e.g. for INK points to $EC now
8678   1CD4             
8679   1CD4             ; Note if you move alter the syntax table next line may have to be altered.
8680   1CD4             
8681   1CD4             ; Note. For ZASM assembler replace following expression with SUB $13.
8682   1CD4             
8683   1CD4 D6 42       L1CA5:  SUB     L1AEB-$D8 % 256 ; convert $EB to $D8 ('INK') etc.
8684   1CD6                                             ; ( is SUB $13 in standard ROM )
8685   1CD6             
8686   1CD6 CD 2B 22            CALL    L21FC           ; routine CO-TEMP-4
8687   1CD9 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END check that nothing else
8688   1CDC                                             ; in statement.
8689   1CDC             
8690   1CDC             ; return here in runtime.
8691   1CDC             
8692   1CDC 2A 8F 5C            LD      HL,($5C8F)      ; pick up ATTR_T and MASK_T
8693   1CDF 22 8D 5C            LD      ($5C8D),HL      ; and store in ATTR_P and MASK_P
8694   1CE2 21 91 5C            LD      HL,$5C91        ; point to P_FLAG.
8695   1CE5 7E                  LD      A,(HL)          ; pick up in A
8696   1CE6 07                  RLCA                    ; rotate to left
8697   1CE7 AE                  XOR     (HL)            ; combine with HL
8698   1CE8 E6 AA               AND     $AA             ; 10101010
8699   1CEA AE                  XOR     (HL)            ; only permanent bits affected
8700   1CEB 77                  LD      (HL),A          ; reload into P_FLAG.
8701   1CEC C9                  RET                     ; return.
8702   1CED             
8703   1CED             ; ------------------
8704   1CED             ; Command class---09
8705   1CED             ; ------------------
8706   1CED             ; e.g. PLOT PAPER 0; 128,88     ; two coordinates preceded by optional
8707   1CED             ;                               ; embedded colour items.
8708   1CED             ;
8709   1CED             ; Note. this command should ensure that current channel is actually 'S'.
8710   1CED             
8711   1CED             ;; CLASS-09
8712   1CED CD 5F 25    L1CBE:  CALL    L2530           ; routine SYNTAX-Z
8713   1CF0 28 13               JR      Z,L1CD6         ; forward to CL-09-1 if checking syntax.
8714   1CF2             
8715   1CF2 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
8716   1CF6 CD 7C 0D            CALL    L0D4D           ; routine TEMPS is called.
8717   1CF9 21 90 5C            LD      HL,$5C90        ; point to MASK_T
8718   1CFC 7E                  LD      A,(HL)          ; fetch mask to accumulator.
8719   1CFD F6 F8               OR      $F8             ; or with 11111000 paper/bright/flash 8
8720   1CFF 77                  LD      (HL),A          ; mask back to MASK_T system variable.
8721   1D00 FD CB 57 B6         RES     6,(IY+$57)      ; reset P_FLAG  - signal NOT PAPER 9 ?
8722   1D04             
8723   1D04 DF                  RST     18H             ; GET-CHAR
8724   1D05             
8725   1D05             ;; CL-09-1
8726   1D05 CD 11 22    L1CD6:  CALL    L21E2           ; routine CO-TEMP-2 deals with any embedded
8727   1D08                                             ; colour items.
8728   1D08 18 9F               JR      L1C7A           ; exit via EXPT-2NUM to check for x,y.
8729   1D0A             
8730   1D0A             ; Note. if either of the numeric expressions contain STR$ then the flag setting 
8731   1D0A             ; above will be undone when the channel flags are reset during STR$.
8732   1D0A             ; e.g. 
8733   1D0A             ; 10 BORDER 3 : PLOT VAL STR$ 128, VAL STR$ 100
8734   1D0A             ; credit John Elliott.
8735   1D0A             
8736   1D0A             ; ------------------
8737   1D0A             ; Command class---0B
8738   1D0A             ; ------------------
8739   1D0A             ; Again a single class for four commands.
8740   1D0A             ; This command just jumps back to SAVE-ETC to handle the four tape commands.
8741   1D0A             ; The routine itself works out which command has called it by examining the
8742   1D0A             ; address in T_ADDR_lo. Note therefore that the syntax table has to be
8743   1D0A             ; located where these and other sequential command addresses are not split
8744   1D0A             ; over a page boundary.
8745   1D0A             
8746   1D0A             ;; CLASS-0B
8747   1D0A C3 34 06    L1CDB:  JP      L0605           ; jump way back to SAVE-ETC
8748   1D0D             
8749   1D0D             ; --------------
8750   1D0D             ; Fetch a number
8751   1D0D             ; --------------
8752   1D0D             ; This routine is called from CLASS-03 when a command may be followed by
8753   1D0D             ; an optional numeric expression e.g. RUN. If the end of statement has
8754   1D0D             ; been reached then zero is used as the default.
8755   1D0D             ; Also called from LIST-4.
8756   1D0D             
8757   1D0D             ;; FETCH-NUM
8758   1D0D FE 0D       L1CDE:  CP      $0D             ; is character a carriage return ?
8759   1D0F 28 04               JR      Z,L1CE6         ; forward to USE-ZERO if so
8760   1D11             
8761   1D11 FE 3A               CP      $3A             ; is it ':' ?
8762   1D13 20 9C               JR      NZ,L1C82        ; forward to EXPT-1NUM if not.
8763   1D15                                             ; else continue and use zero.
8764   1D15             
8765   1D15             ; ----------------
8766   1D15             ; Use zero routine
8767   1D15             ; ----------------
8768   1D15             ; This routine is called four times to place the value zero on the
8769   1D15             ; calculator stack as a default value in runtime.
8770   1D15             
8771   1D15             ;; USE-ZERO
8772   1D15 CD 5F 25    L1CE6:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
8773   1D18 C8                  RET     Z               ;
8774   1D19             
8775   1D19 EF                  RST     28H             ;; FP-CALC
8776   1D1A A0                  DEFB    $A0             ;;stk-zero       ;0.
8777   1D1B 38                  DEFB    $38             ;;end-calc
8778   1D1C             
8779   1D1C C9                  RET                     ; return.
8780   1D1D             
8781   1D1D             ; -------------------
8782   1D1D             ; Handle STOP command
8783   1D1D             ; -------------------
8784   1D1D             ; Command Syntax: STOP
8785   1D1D             ; One of the shortest and least used commands. As with 'OK' not an error.
8786   1D1D             
8787   1D1D             ;; REPORT-9
8788   1D1D             ;; STOP
8789   1D1D CF          L1CEE:  RST     08H             ; ERROR-1
8790   1D1E 08                  DEFB    $08             ; Error Report: STOP statement
8791   1D1F             
8792   1D1F             ; -----------------
8793   1D1F             ; Handle IF command
8794   1D1F             ; -----------------
8795   1D1F             ; e.g. IF score>100 THEN PRINT "You Win"
8796   1D1F             ; The parser has already checked the expression the result of which is on
8797   1D1F             ; the calculator stack. The presence of the 'THEN' separator has also been
8798   1D1F             ; checked and CH-ADD points to the command after THEN.
8799   1D1F             ;
8800   1D1F             
8801   1D1F             ;; IF
8802   1D1F C1          L1CF0:  POP     BC              ; drop return address - STMT-RET
8803   1D20 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
8804   1D23 28 0A               JR      Z,L1D00         ; forward to IF-1 if checking syntax
8805   1D25                                             ; to check syntax of PRINT "You Win"
8806   1D25             
8807   1D25             
8808   1D25 EF                  RST     28H             ;; FP-CALC    score>100 (1=TRUE 0=FALSE)
8809   1D26 02                  DEFB    $02             ;;delete      .
8810   1D27 38                  DEFB    $38             ;;end-calc
8811   1D28             
8812   1D28 EB                  EX      DE,HL           ; make HL point to deleted value
8813   1D29 CD 18 35            CALL    L34E9           ; routine TEST-ZERO
8814   1D2C DA E2 1B            JP      C,L1BB3         ; jump to LINE-END if FALSE (0)
8815   1D2F             
8816   1D2F             ;; IF-1
8817   1D2F C3 58 1B    L1D00:  JP      L1B29           ; to STMT-L-1, if true (1) to execute command
8818   1D32                                             ; after 'THEN' token.
8819   1D32             
8820   1D32             ; ------------------
8821   1D32             ; Handle FOR command
8822   1D32             ; ------------------
8823   1D32             ; e.g. FOR i = 0 TO 1 STEP 0.1
8824   1D32             ; Using the syntax tables, the parser has already checked for a start and
8825   1D32             ; limit value and also for the intervening separator.
8826   1D32             ; the two values v,l are on the calculator stack.
8827   1D32             ; CLASS-04 has also checked the variable and the name is in STRLEN_lo.
8828   1D32             ; The routine begins by checking for an optional STEP.
8829   1D32             
8830   1D32             ;; FOR
8831   1D32 FE CD       L1D03:  CP      $CD             ; is there a 'STEP' ?
8832   1D34 20 09               JR      NZ,L1D10        ; to F-USE-1 if not to use 1 as default.
8833   1D36             
8834   1D36 E7                  RST     20H             ; NEXT-CHAR
8835   1D37 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM
8836   1D3A CD 1D 1C            CALL    L1BEE           ; routine CHECK-END
8837   1D3D 18 06               JR      L1D16           ; to F-REORDER
8838   1D3F             
8839   1D3F             ; ---
8840   1D3F             
8841   1D3F             ;; F-USE-1
8842   1D3F CD 1D 1C    L1D10:  CALL    L1BEE           ; routine CHECK-END
8843   1D42             
8844   1D42 EF                  RST     28H             ;; FP-CALC      v,l.
8845   1D43 A1                  DEFB    $A1             ;;stk-one       v,l,1=s.
8846   1D44 38                  DEFB    $38             ;;end-calc
8847   1D45             
8848   1D45             
8849   1D45             ;; F-REORDER
8850   1D45 EF          L1D16:  RST     28H             ;; FP-CALC       v,l,s.
8851   1D46 C0                  DEFB    $C0             ;;st-mem-0       v,l,s.
8852   1D47 02                  DEFB    $02             ;;delete         v,l.
8853   1D48 01                  DEFB    $01             ;;exchange       l,v.
8854   1D49 E0                  DEFB    $E0             ;;get-mem-0      l,v,s.
8855   1D4A 01                  DEFB    $01             ;;exchange       l,s,v.
8856   1D4B 38                  DEFB    $38             ;;end-calc
8857   1D4C             
8858   1D4C CD 2E 2B            CALL    L2AFF           ; routine LET assigns the initial value v to
8859   1D4F                                             ; the variable altering type if necessary.
8860   1D4F 22 68 5C            LD      ($5C68),HL      ; The system variable MEM is made to point to
8861   1D52                                             ; the variable instead of its normal
8862   1D52                                             ; location MEMBOT
8863   1D52 2B                  DEC     HL              ; point to single-character name
8864   1D53 7E                  LD      A,(HL)          ; fetch name
8865   1D54 CB FE               SET     7,(HL)          ; set bit 7 at location
8866   1D56 01 06 00            LD      BC,$0006        ; add six to HL
8867   1D59 09                  ADD     HL,BC           ; to address where limit should be.
8868   1D5A 07                  RLCA                    ; test bit 7 of original name.
8869   1D5B 38 06               JR      C,L1D34         ; forward to F-L-S if already a FOR/NEXT
8870   1D5D                                             ; variable
8871   1D5D             
8872   1D5D 0E 0D               LD      C,$0D           ; otherwise an additional 13 bytes are needed.
8873   1D5F                                             ; 5 for each value, two for line number and
8874   1D5F                                             ; 1 byte for looping statement.
8875   1D5F CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates them.
8876   1D62 23                  INC     HL              ; make HL address limit.
8877   1D63             
8878   1D63             ;; F-L-S
8879   1D63 E5          L1D34:  PUSH    HL              ; save position.
8880   1D64             
8881   1D64 EF                  RST     28H             ;; FP-CALC         l,s.
8882   1D65 02                  DEFB    $02             ;;delete           l.
8883   1D66 02                  DEFB    $02             ;;delete           .
8884   1D67 38                  DEFB    $38             ;;end-calc
8885   1D68                                             ; DE points to STKEND, l.
8886   1D68             
8887   1D68 E1                  POP     HL              ; restore variable position
8888   1D69 EB                  EX      DE,HL           ; swap pointers
8889   1D6A 0E 0A               LD      C,$0A           ; ten bytes to move
8890   1D6C ED B0               LDIR                    ; Copy 'deleted' values to variable.
8891   1D6E 2A 45 5C            LD      HL,($5C45)      ; Load with current line number from PPC
8892   1D71 EB                  EX      DE,HL           ; exchange pointers.
8893   1D72 73                  LD      (HL),E          ; save the looping line
8894   1D73 23                  INC     HL              ; in the next
8895   1D74 72                  LD      (HL),D          ; two locations.
8896   1D75 FD 56 0D            LD      D,(IY+$0D)      ; fetch statement from SUBPPC system variable.
8897   1D78 14                  INC     D               ; increment statement.
8898   1D79 23                  INC     HL              ; and pointer
8899   1D7A 72                  LD      (HL),D          ; and store the looping statement.
8900   1D7B                                             ;
8901   1D7B CD 09 1E            CALL    L1DDA           ; routine NEXT-LOOP considers an initial
8902   1D7E D0                  RET     NC              ; iteration. Return to STMT-RET if a loop is
8903   1D7F                                             ; possible to execute next statement.
8904   1D7F             
8905   1D7F             ; no loop is possible so execution continues after the matching 'NEXT'
8906   1D7F             
8907   1D7F FD 46 38            LD      B,(IY+$38)      ; get single-character name from STRLEN_lo
8908   1D82 2A 45 5C            LD      HL,($5C45)      ; get the current line from PPC
8909   1D85 22 42 5C            LD      ($5C42),HL      ; and store it in NEWPPC
8910   1D88 3A 47 5C            LD      A,($5C47)       ; fetch current statement from SUBPPC
8911   1D8B ED 44               NEG                     ; Negate as counter decrements from zero
8912   1D8D                                             ; initially and we are in the middle of a
8913   1D8D                                             ; line.
8914   1D8D 57                  LD      D,A             ; Store result in D.
8915   1D8E 2A 5D 5C            LD      HL,($5C5D)      ; get current address from CH_ADD
8916   1D91 1E F3               LD      E,$F3           ; search will be for token 'NEXT'
8917   1D93             
8918   1D93             ;; F-LOOP
8919   1D93 C5          L1D64:  PUSH    BC              ; save variable name.
8920   1D94 ED 4B 55 5C         LD      BC,($5C55)      ; fetch NXTLIN
8921   1D98 CD B5 1D            CALL    L1D86           ; routine LOOK-PROG searches for 'NEXT' token.
8922   1D9B ED 43 55 5C         LD      ($5C55),BC      ; update NXTLIN
8923   1D9F C1                  POP     BC              ; and fetch the letter
8924   1DA0 38 11               JR      C,L1D84         ; forward to REPORT-I if the end of program
8925   1DA2                                             ; was reached by LOOK-PROG.
8926   1DA2                                             ; 'FOR without NEXT'
8927   1DA2             
8928   1DA2 E7                  RST     20H             ; NEXT-CHAR fetches character after NEXT
8929   1DA3 F6 20               OR      $20             ; ensure it is upper-case.
8930   1DA5 B8                  CP      B               ; compare with FOR variable name
8931   1DA6 28 03               JR      Z,L1D7C         ; forward to F-FOUND if it matches.
8932   1DA8             
8933   1DA8             ; but if no match i.e. nested FOR/NEXT loops then continue search.
8934   1DA8             
8935   1DA8 E7                  RST     20H             ; NEXT-CHAR
8936   1DA9 18 E8               JR      L1D64           ; back to F-LOOP
8937   1DAB             
8938   1DAB             ; ---
8939   1DAB             
8940   1DAB             
8941   1DAB             ;; F-FOUND
8942   1DAB E7          L1D7C:  RST     20H             ; NEXT-CHAR
8943   1DAC 3E 01               LD      A,$01           ; subtract the negated counter from 1
8944   1DAE 92                  SUB     D               ; to give the statement after the NEXT
8945   1DAF 32 44 5C            LD      ($5C44),A       ; set system variable NSPPC
8946   1DB2 C9                  RET                     ; return to STMT-RET to branch to new
8947   1DB3                                             ; line and statement. ->
8948   1DB3             ; ---
8949   1DB3             
8950   1DB3             ;; REPORT-I
8951   1DB3 CF          L1D84:  RST     08H             ; ERROR-1
8952   1DB4 11                  DEFB    $11             ; Error Report: FOR without NEXT
8953   1DB5             
8954   1DB5             ; ---------
8955   1DB5             ; LOOK-PROG
8956   1DB5             ; ---------
8957   1DB5             ; Find DATA, DEF FN or NEXT.
8958   1DB5             ; This routine searches the program area for one of the above three keywords.
8959   1DB5             ; On entry, HL points to start of search area.
8960   1DB5             ; The token is in E, and D holds a statement count, decremented from zero.
8961   1DB5             
8962   1DB5             ;; LOOK-PROG
8963   1DB5 7E          L1D86:  LD      A,(HL)          ; fetch current character
8964   1DB6 FE 3A               CP      $3A             ; is it ':' a statement separator ?
8965   1DB8 28 18               JR      Z,L1DA3         ; forward to LOOK-P-2 if so.
8966   1DBA             
8967   1DBA             ; The starting point was PROG - 1 or the end of a line.
8968   1DBA             
8969   1DBA             ;; LOOK-P-1
8970   1DBA 23          L1D8B:  INC     HL              ; increment pointer to address
8971   1DBB 7E                  LD      A,(HL)          ; the high byte of line number
8972   1DBC E6 C0               AND     $C0             ; test for program end marker $80 or a
8973   1DBE                                             ; variable
8974   1DBE 37                  SCF                     ; Set Carry Flag
8975   1DBF C0                  RET     NZ              ; return with carry set if at end
8976   1DC0                                             ; of program.           ->
8977   1DC0             
8978   1DC0 46                  LD      B,(HL)          ; high byte of line number to B
8979   1DC1 23                  INC     HL              ;
8980   1DC2 4E                  LD      C,(HL)          ; low byte to C.
8981   1DC3 ED 43 42 5C         LD      ($5C42),BC      ; set system variable NEWPPC.
8982   1DC7 23                  INC     HL              ;
8983   1DC8 4E                  LD      C,(HL)          ; low byte of line length to C.
8984   1DC9 23                  INC     HL              ;
8985   1DCA 46                  LD      B,(HL)          ; high byte to B.
8986   1DCB E5                  PUSH    HL              ; save address
8987   1DCC 09                  ADD     HL,BC           ; add length to position.
8988   1DCD 44                  LD      B,H             ; and save result
8989   1DCE 4D                  LD      C,L             ; in BC.
8990   1DCF E1                  POP     HL              ; restore address.
8991   1DD0 16 00               LD      D,$00           ; initialize statement counter to zero.
8992   1DD2             
8993   1DD2             ;; LOOK-P-2
8994   1DD2 C5          L1DA3:  PUSH    BC              ; save address of next line
8995   1DD3 CD BA 19            CALL    L198B           ; routine EACH-STMT searches current line.
8996   1DD6 C1                  POP     BC              ; restore address.
8997   1DD7 D0                  RET     NC              ; return if match was found. ->
8998   1DD8             
8999   1DD8 18 E0               JR      L1D8B           ; back to LOOK-P-1 for next line.
9000   1DDA             
9001   1DDA             ; -------------------
9002   1DDA             ; Handle NEXT command
9003   1DDA             ; -------------------
9004   1DDA             ; e.g. NEXT i
9005   1DDA             ; The parameter tables have already evaluated the presence of a variable
9006   1DDA             
9007   1DDA             ;; NEXT
9008   1DDA FD CB 37 4E L1DAB:  BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
9009   1DDE C2 5D 1C            JP      NZ,L1C2E        ; jump back to REPORT-2 if so
9010   1DE1                                             ; 'Variable not found'
9011   1DE1             
9012   1DE1             ; now test if found variable is a simple variable uninitialized by a FOR.
9013   1DE1             
9014   1DE1 2A 4D 5C            LD      HL,($5C4D)      ; load address of variable from DEST
9015   1DE4 CB 7E               BIT     7,(HL)          ; is it correct type ?
9016   1DE6 28 1F               JR      Z,L1DD8         ; forward to REPORT-1 if not
9017   1DE8                                             ; 'NEXT without FOR'
9018   1DE8             
9019   1DE8 23                  INC     HL              ; step past variable name
9020   1DE9 22 68 5C            LD      ($5C68),HL      ; and set MEM to point to three 5-byte values
9021   1DEC                                             ; value, limit, step.
9022   1DEC             
9023   1DEC EF                  RST     28H             ;; FP-CALC     add step and re-store
9024   1DED E0                  DEFB    $E0             ;;get-mem-0    v.
9025   1DEE E2                  DEFB    $E2             ;;get-mem-2    v,s.
9026   1DEF 0F                  DEFB    $0F             ;;addition     v+s.
9027   1DF0 C0                  DEFB    $C0             ;;st-mem-0     v+s.
9028   1DF1 02                  DEFB    $02             ;;delete       .
9029   1DF2 38                  DEFB    $38             ;;end-calc
9030   1DF3             
9031   1DF3 CD 09 1E            CALL    L1DDA           ; routine NEXT-LOOP tests against limit.
9032   1DF6 D8                  RET     C               ; return if no more iterations possible.
9033   1DF7             
9034   1DF7 2A 68 5C            LD      HL,($5C68)      ; find start of variable contents from MEM.
9035   1DFA 11 0F 00            LD      DE,$000F        ; add 3*5 to
9036   1DFD 19                  ADD     HL,DE           ; address the looping line number
9037   1DFE 5E                  LD      E,(HL)          ; low byte to E
9038   1DFF 23                  INC     HL              ;
9039   1E00 56                  LD      D,(HL)          ; high byte to D
9040   1E01 23                  INC     HL              ; address looping statement
9041   1E02 66                  LD      H,(HL)          ; and store in H
9042   1E03 EB                  EX      DE,HL           ; swap registers
9043   1E04 C3 A2 1E            JP      L1E73           ; exit via GO-TO-2 to execute another loop.
9044   1E07             
9045   1E07             ; ---
9046   1E07             
9047   1E07             ;; REPORT-1
9048   1E07 CF          L1DD8:  RST     08H             ; ERROR-1
9049   1E08 00                  DEFB    $00             ; Error Report: NEXT without FOR
9050   1E09             
9051   1E09             
9052   1E09             ; -----------------
9053   1E09             ; Perform NEXT loop
9054   1E09             ; -----------------
9055   1E09             ; This routine is called from the FOR command to test for an initial
9056   1E09             ; iteration and from the NEXT command to test for all subsequent iterations.
9057   1E09             ; the system variable MEM addresses the variable's contents which, in the
9058   1E09             ; latter case, have had the step, possibly negative, added to the value.
9059   1E09             
9060   1E09             ;; NEXT-LOOP
9061   1E09 EF          L1DDA:  RST     28H             ;; FP-CALC
9062   1E0A E1                  DEFB    $E1             ;;get-mem-1        l.
9063   1E0B E0                  DEFB    $E0             ;;get-mem-0        l,v.
9064   1E0C E2                  DEFB    $E2             ;;get-mem-2        l,v,s.
9065   1E0D 36                  DEFB    $36             ;;less-0           l,v,(1/0) negative step ?
9066   1E0E 00                  DEFB    $00             ;;jump-true        l,v.(1/0)
9067   1E0F             
9068   1E0F 02                  DEFB    $02             ;;to L1DE2, NEXT-1 if step negative
9069   1E10             
9070   1E10 01                  DEFB    $01             ;;exchange         v,l.
9071   1E11             
9072   1E11             ;; NEXT-1
9073   1E11 03          L1DE2:  DEFB    $03             ;;subtract         l-v OR v-l.
9074   1E12 37                  DEFB    $37             ;;greater-0        (1/0)
9075   1E13 00                  DEFB    $00             ;;jump-true        .
9076   1E14             
9077   1E14 04                  DEFB    $04             ;;to L1DE9, NEXT-2 if no more iterations.
9078   1E15             
9079   1E15 38                  DEFB    $38             ;;end-calc         .
9080   1E16             
9081   1E16 A7                  AND     A               ; clear carry flag signalling another loop.
9082   1E17 C9                  RET                     ; return
9083   1E18             
9084   1E18             ; ---
9085   1E18             
9086   1E18             ;; NEXT-2
9087   1E18 38          L1DE9:  DEFB    $38             ;;end-calc         .
9088   1E19             
9089   1E19 37                  SCF                     ; set carry flag signalling looping exhausted.
9090   1E1A C9                  RET                     ; return
9091   1E1B             
9092   1E1B             
9093   1E1B             ; -------------------
9094   1E1B             ; Handle READ command
9095   1E1B             ; -------------------
9096   1E1B             ; e.g. READ a, b$, c$(1000 TO 3000)
9097   1E1B             ; A list of comma-separated variables is assigned from a list of
9098   1E1B             ; comma-separated expressions.
9099   1E1B             ; As it moves along the first list, the character address CH_ADD is stored
9100   1E1B             ; in X_PTR while CH_ADD is used to read the second list.
9101   1E1B             
9102   1E1B             ;; READ-3
9103   1E1B E7          L1DEC:  RST     20H             ; NEXT-CHAR
9104   1E1C             
9105   1E1C             ; -> Entry point.
9106   1E1C             ;; READ
9107   1E1C CD 4E 1C    L1DED:  CALL    L1C1F           ; routine CLASS-01 checks variable.
9108   1E1F CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
9109   1E22 28 29               JR      Z,L1E1E         ; forward to READ-2 if checking syntax
9110   1E24             
9111   1E24             
9112   1E24 DF                  RST     18H             ; GET-CHAR
9113   1E25 22 5F 5C            LD      ($5C5F),HL      ; save character position in X_PTR.
9114   1E28 2A 57 5C            LD      HL,($5C57)      ; load HL with Data Address DATADD, which is
9115   1E2B                                             ; the start of the program or the address
9116   1E2B                                             ; after the last expression that was read or
9117   1E2B                                             ; the address of the line number of the 
9118   1E2B                                             ; last RESTORE command.
9119   1E2B 7E                  LD      A,(HL)          ; fetch character
9120   1E2C FE 2C               CP      $2C             ; is it a comma ?
9121   1E2E 28 09               JR      Z,L1E0A         ; forward to READ-1 if so.
9122   1E30             
9123   1E30             ; else all data in this statement has been read so look for next DATA token
9124   1E30             
9125   1E30 1E E4               LD      E,$E4           ; token 'DATA'
9126   1E32 CD B5 1D            CALL    L1D86           ; routine LOOK-PROG
9127   1E35 30 02               JR      NC,L1E0A        ; forward to READ-1 if DATA found
9128   1E37             
9129   1E37             ; else report the error.
9130   1E37             
9131   1E37             ;; REPORT-E
9132   1E37 CF          L1E08:  RST     08H             ; ERROR-1
9133   1E38 0D                  DEFB    $0D             ; Error Report: Out of DATA
9134   1E39             
9135   1E39             ;; READ-1
9136   1E39 CD 77 00    L1E0A:  CALL    L0077           ; routine TEMP-PTR1 advances updating CH_ADD
9137   1E3C                                             ; with new DATADD position.
9138   1E3C CD 85 1C            CALL    L1C56           ; routine VAL-FET-1 assigns value to variable
9139   1E3F                                             ; checking type match and adjusting CH_ADD.
9140   1E3F             
9141   1E3F DF                  RST     18H             ; GET-CHAR fetches adjusted character position
9142   1E40 22 57 5C            LD      ($5C57),HL      ; store back in DATADD
9143   1E43 2A 5F 5C            LD      HL,($5C5F)      ; fetch X_PTR  the original READ CH_ADD
9144   1E46 FD 36 26 00         LD      (IY+$26),$00    ; now nullify X_PTR_hi
9145   1E4A CD 78 00            CALL    L0078           ; routine TEMP-PTR2 restores READ CH_ADD
9146   1E4D             
9147   1E4D             ;; READ-2
9148   1E4D DF          L1E1E:  RST     18H             ; GET-CHAR
9149   1E4E FE 2C               CP      $2C             ; is it ',' indicating more variables to read ?
9150   1E50 28 C9               JR      Z,L1DEC         ; back to READ-3 if so
9151   1E52             
9152   1E52 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END
9153   1E55 C9                  RET                     ; return from here in runtime to STMT-RET.
9154   1E56             
9155   1E56             ; -------------------
9156   1E56             ; Handle DATA command
9157   1E56             ; -------------------
9158   1E56             ; In runtime this 'command' is passed by but the syntax is checked when such
9159   1E56             ; a statement is found while parsing a line.
9160   1E56             ; e.g. DATA 1, 2, "text", score-1, a$(location, room, object), FN r(49),
9161   1E56             ;         wages - tax, TRUE, The meaning of life
9162   1E56             
9163   1E56             ;; DATA
9164   1E56 CD 5F 25    L1E27:  CALL    L2530           ; routine SYNTAX-Z to check status
9165   1E59 20 0B               JR      NZ,L1E37        ; forward to DATA-2 if in runtime
9166   1E5B             
9167   1E5B             ;; DATA-1
9168   1E5B CD 2A 25    L1E2C:  CALL    L24FB           ; routine SCANNING to check syntax of
9169   1E5E                                             ; expression
9170   1E5E FE 2C               CP      $2C             ; is it a comma ?
9171   1E60 C4 1D 1C            CALL    NZ,L1BEE        ; routine CHECK-END checks that statement
9172   1E63                                             ; is complete. Will make an early exit if
9173   1E63                                             ; so. >>>
9174   1E63 E7                  RST     20H             ; NEXT-CHAR
9175   1E64 18 F5               JR      L1E2C           ; back to DATA-1
9176   1E66             
9177   1E66             ; ---
9178   1E66             
9179   1E66             ;; DATA-2
9180   1E66 3E E4       L1E37:  LD      A,$E4           ; set token to 'DATA' and continue into
9181   1E68                                             ; the PASS-BY routine.
9182   1E68             
9183   1E68             
9184   1E68             ; ----------------------------------
9185   1E68             ; Check statement for DATA or DEF FN
9186   1E68             ; ----------------------------------
9187   1E68             ; This routine is used to backtrack to a command token and then
9188   1E68             ; forward to the next statement in runtime.
9189   1E68             
9190   1E68             ;; PASS-BY
9191   1E68 47          L1E39:  LD      B,A             ; Give BC enough space to find token.
9192   1E69 ED B9               CPDR                    ; Compare decrement and repeat. (Only use).
9193   1E6B                                             ; Work backwards till keyword is found which
9194   1E6B                                             ; is start of statement before any quotes.
9195   1E6B                                             ; HL points to location before keyword.
9196   1E6B 11 00 02            LD      DE,$0200        ; count 1+1 statements, dummy value in E to
9197   1E6E                                             ; inhibit searching for a token.
9198   1E6E C3 BA 19            JP      L198B           ; to EACH-STMT to find next statement
9199   1E71             
9200   1E71             ; -----------------------------------------------------------------------
9201   1E71             ; A General Note on Invalid Line Numbers.
9202   1E71             ; =======================================
9203   1E71             ; One of the revolutionary concepts of Sinclair BASIC was that it supported
9204   1E71             ; virtual line numbers. That is the destination of a GO TO, RESTORE etc. need
9205   1E71             ; not exist. It could be a point before or after an actual line number.
9206   1E71             ; Zero suffices for a before but the after should logically be infinity.
9207   1E71             ; Since the maximum actual line limit is 9999 then the system limit, 16383
9208   1E71             ; when variables kick in, would serve fine as a virtual end point.
9209   1E71             ; However, ironically, only the LOAD command gets it right. It will not
9210   1E71             ; autostart a program that has been saved with a line higher than 16383.
9211   1E71             ; All the other commands deal with the limit unsatisfactorily.
9212   1E71             ; LIST, RUN, GO TO, GO SUB and RESTORE have problems and the latter may
9213   1E71             ; crash the machine when supplied with an inappropriate virtual line number.
9214   1E71             ; This is puzzling as very careful consideration must have been given to
9215   1E71             ; this point when the new variable types were allocated their masks and also
9216   1E71             ; when the routine NEXT-ONE was successfully re-written to reflect this.
9217   1E71             ; An enigma.
9218   1E71             ; -------------------------------------------------------------------------
9219   1E71             
9220   1E71             ; ----------------------
9221   1E71             ; Handle RESTORE command
9222   1E71             ; ----------------------
9223   1E71             ; The restore command sets the system variable for the data address to
9224   1E71             ; point to the location before the supplied line number or first line
9225   1E71             ; thereafter.
9226   1E71             ; This alters the position where subsequent READ commands look for data.
9227   1E71             ; Note. If supplied with inappropriate high numbers the system may crash
9228   1E71             ; in the LINE-ADDR routine as it will pass the program/variables end-marker
9229   1E71             ; and then lose control of what it is looking for - variable or line number.
9230   1E71             ; - observation, Steven Vickers, 1984, Pitman.
9231   1E71             
9232   1E71             ;; RESTORE
9233   1E71 CD C8 1E    L1E42:  CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
9234   1E74                                             ; Note. B should be checked against limit $3F
9235   1E74                                             ; and an error generated if higher.
9236   1E74             
9237   1E74             ; this entry point is used from RUN command with BC holding zero
9238   1E74             
9239   1E74             ;; REST-RUN
9240   1E74 60          L1E45:  LD      H,B             ; transfer the line
9241   1E75 69                  LD      L,C             ; number to the HL register.
9242   1E76 CD 9D 19            CALL    L196E           ; routine LINE-ADDR to fetch the address.
9243   1E79 2B                  DEC     HL              ; point to the location before the line.
9244   1E7A 22 57 5C            LD      ($5C57),HL      ; update system variable DATADD.
9245   1E7D C9                  RET                     ; return to STMT-RET (or RUN)
9246   1E7E             
9247   1E7E             ; ------------------------
9248   1E7E             ; Handle RANDOMIZE command
9249   1E7E             ; ------------------------
9250   1E7E             ; This command sets the SEED for the RND function to a fixed value.
9251   1E7E             ; With the parameter zero, a random start point is used depending on
9252   1E7E             ; how long the computer has been switched on.
9253   1E7E             
9254   1E7E             ;; RANDOMIZE
9255   1E7E CD C8 1E    L1E4F:  CALL    L1E99           ; routine FIND-INT2 puts parameter in BC.
9256   1E81 78                  LD      A,B             ; test this
9257   1E82 B1                  OR      C               ; for zero.
9258   1E83 20 04               JR      NZ,L1E5A        ; forward to RAND-1 if not zero.
9259   1E85             
9260   1E85 ED 4B 78 5C         LD      BC,($5C78)      ; use the lower two bytes at FRAMES1.
9261   1E89             
9262   1E89             ;; RAND-1
9263   1E89 ED 43 76 5C L1E5A:  LD      ($5C76),BC      ; place in SEED system variable.
9264   1E8D C9                  RET                     ; return to STMT-RET
9265   1E8E             
9266   1E8E             ; -----------------------
9267   1E8E             ; Handle CONTINUE command
9268   1E8E             ; -----------------------
9269   1E8E             ; The CONTINUE command transfers the OLD (but incremented) values of
9270   1E8E             ; line number and statement to the equivalent "NEW VALUE" system variables
9271   1E8E             ; by using the last part of GO TO and exits indirectly to STMT-RET.
9272   1E8E             
9273   1E8E             ;; CONTINUE
9274   1E8E 2A 6E 5C    L1E5F:  LD      HL,($5C6E)      ; fetch OLDPPC line number.
9275   1E91 FD 56 36            LD      D,(IY+$36)      ; fetch OSPPC statement.
9276   1E94 18 0C               JR      L1E73           ; forward to GO-TO-2
9277   1E96             
9278   1E96             ; --------------------
9279   1E96             ; Handle GO TO command
9280   1E96             ; --------------------
9281   1E96             ; The GO TO command routine is also called by GO SUB and RUN routines
9282   1E96             ; to evaluate the parameters of both commands.
9283   1E96             ; It updates the system variables used to fetch the next line/statement.
9284   1E96             ; It is at STMT-RET that the actual change in control takes place.
9285   1E96             ; Unlike some BASICs the line number need not exist.
9286   1E96             ; Note. the high byte of the line number is incorrectly compared with $F0
9287   1E96             ; instead of $3F. This leads to commands with operands greater than 32767
9288   1E96             ; being considered as having been run from the editing area and the
9289   1E96             ; error report 'Statement Lost' is given instead of 'OK'.
9290   1E96             ; - Steven Vickers, 1984.
9291   1E96             
9292   1E96             ;; GO-TO
9293   1E96 CD C8 1E    L1E67:  CALL    L1E99           ; routine FIND-INT2 puts operand in BC
9294   1E99 60                  LD      H,B             ; transfer line
9295   1E9A 69                  LD      L,C             ; number to HL.
9296   1E9B 16 00               LD      D,$00           ; set statement to 0 - first.
9297   1E9D 7C                  LD      A,H             ; compare high byte only
9298   1E9E FE F0               CP      $F0             ; to $F0 i.e. 61439 in full.
9299   1EA0 30 2C               JR      NC,L1E9F        ; forward to REPORT-B if above.
9300   1EA2             
9301   1EA2             ; This call entry point is used to update the system variables e.g. by RETURN.
9302   1EA2             
9303   1EA2             ;; GO-TO-2
9304   1EA2 22 42 5C    L1E73:  LD      ($5C42),HL      ; save line number in NEWPPC
9305   1EA5 FD 72 0A            LD      (IY+$0A),D      ; and statement in NSPPC
9306   1EA8 C9                  RET                     ; to STMT-RET (or GO-SUB command)
9307   1EA9             
9308   1EA9             ; ------------------
9309   1EA9             ; Handle OUT command
9310   1EA9             ; ------------------
9311   1EA9             ; Syntax has been checked and the two comma-separated values are on the
9312   1EA9             ; calculator stack.
9313   1EA9             
9314   1EA9             ;; OUT
9315   1EA9 CD B4 1E    L1E7A:  CALL    L1E85           ; routine TWO-PARAM fetches values
9316   1EAC                                             ; to BC and A.
9317   1EAC ED 79               OUT     (C),A           ; perform the operation.
9318   1EAE C9                  RET                     ; return to STMT-RET.
9319   1EAF             
9320   1EAF             ; -------------------
9321   1EAF             ; Handle POKE command
9322   1EAF             ; -------------------
9323   1EAF             ; This routine alters a single byte in the 64K address space.
9324   1EAF             ; Happily no check is made as to whether ROM or RAM is addressed.
9325   1EAF             ; Sinclair BASIC requires no poking of system variables.
9326   1EAF             
9327   1EAF             ;; POKE
9328   1EAF CD B4 1E    L1E80:  CALL    L1E85           ; routine TWO-PARAM fetches values
9329   1EB2                                             ; to BC and A.
9330   1EB2 02                  LD      (BC),A          ; load memory location with A.
9331   1EB3 C9                  RET                     ; return to STMT-RET.
9332   1EB4             
9333   1EB4             ; ------------------------------------
9334   1EB4             ; Fetch two  parameters from calculator stack
9335   1EB4             ; ------------------------------------
9336   1EB4             ; This routine fetches a byte and word from the calculator stack
9337   1EB4             ; producing an error if either is out of range.
9338   1EB4             
9339   1EB4             ;; TWO-PARAM
9340   1EB4 CD 04 2E    L1E85:  CALL    L2DD5           ; routine FP-TO-A
9341   1EB7 38 15               JR      C,L1E9F         ; forward to REPORT-B if overflow occurred
9342   1EB9             
9343   1EB9 28 02               JR      Z,L1E8E         ; forward to TWO-P-1 if positive
9344   1EBB             
9345   1EBB ED 44               NEG                     ; negative numbers are made positive
9346   1EBD             
9347   1EBD             ;; TWO-P-1
9348   1EBD F5          L1E8E:  PUSH    AF              ; save the value
9349   1EBE CD C8 1E            CALL    L1E99           ; routine FIND-INT2 gets integer to BC
9350   1EC1 F1                  POP     AF              ; restore the value
9351   1EC2 C9                  RET                     ; return
9352   1EC3             
9353   1EC3             ; -------------
9354   1EC3             ; Find integers
9355   1EC3             ; -------------
9356   1EC3             ; The first of these routines fetches a 8-bit integer (range 0-255) from the
9357   1EC3             ; calculator stack to the accumulator and is used for colours, streams,
9358   1EC3             ; durations and coordinates.
9359   1EC3             ; The second routine fetches 16-bit integers to the BC register pair 
9360   1EC3             ; and is used to fetch command and function arguments involving line numbers
9361   1EC3             ; or memory addresses and also array subscripts and tab arguments.
9362   1EC3             ; ->
9363   1EC3             
9364   1EC3             ;; FIND-INT1
9365   1EC3 CD 04 2E    L1E94:  CALL    L2DD5           ; routine FP-TO-A
9366   1EC6 18 03               JR      L1E9C           ; forward to FIND-I-1 for common exit routine.
9367   1EC8             
9368   1EC8             ; ---
9369   1EC8             
9370   1EC8             ; ->
9371   1EC8             
9372   1EC8             ;; FIND-INT2
9373   1EC8 CD D1 2D    L1E99:  CALL    L2DA2           ; routine FP-TO-BC
9374   1ECB             
9375   1ECB             ;; FIND-I-1
9376   1ECB 38 01       L1E9C:  JR      C,L1E9F         ; to REPORT-Bb with overflow.
9377   1ECD             
9378   1ECD C8                  RET     Z               ; return if positive.
9379   1ECE             
9380   1ECE             
9381   1ECE             ;; REPORT-Bb
9382   1ECE CF          L1E9F:  RST     08H             ; ERROR-1
9383   1ECF 0A                  DEFB    $0A             ; Error Report: Integer out of range
9384   1ED0             
9385   1ED0             ; ------------------
9386   1ED0             ; Handle RUN command
9387   1ED0             ; ------------------
9388   1ED0             ; This command runs a program starting at an optional line.
9389   1ED0             ; It performs a 'RESTORE 0' then CLEAR
9390   1ED0             
9391   1ED0             ;; RUN
9392   1ED0 CD 96 1E    L1EA1:  CALL    L1E67           ; routine GO-TO puts line number in
9393   1ED3                                             ; system variables.
9394   1ED3 01 00 00            LD      BC,$0000        ; prepare to set DATADD to first line.
9395   1ED6 CD 74 1E            CALL    L1E45           ; routine REST-RUN does the 'restore'.
9396   1ED9                                             ; Note BC still holds zero.
9397   1ED9 18 03               JR      L1EAF           ; forward to CLEAR-RUN to clear variables
9398   1EDB                                             ; without disturbing RAMTOP and
9399   1EDB                                             ; exit indirectly to STMT-RET
9400   1EDB             
9401   1EDB             ; --------------------
9402   1EDB             ; Handle CLEAR command
9403   1EDB             ; --------------------
9404   1EDB             ; This command reclaims the space used by the variables.
9405   1EDB             ; It also clears the screen and the GO SUB stack.
9406   1EDB             ; With an integer expression, it sets the uppermost memory
9407   1EDB             ; address within the BASIC system.
9408   1EDB             ; "Contrary to the manual, CLEAR doesn't execute a RESTORE" -
9409   1EDB             ; Steven Vickers, Pitman Pocket Guide to the Spectrum, 1984.
9410   1EDB             
9411   1EDB             ;; CLEAR
9412   1EDB CD C8 1E    L1EAC:  CALL    L1E99           ; routine FIND-INT2 fetches to BC.
9413   1EDE             
9414   1EDE             ;; CLEAR-RUN
9415   1EDE 78          L1EAF:  LD      A,B             ; test for
9416   1EDF B1                  OR      C               ; zero.
9417   1EE0 20 04               JR      NZ,L1EB7        ; skip to CLEAR-1 if not zero.
9418   1EE2             
9419   1EE2 ED 4B B2 5C         LD      BC,($5CB2)      ; use the existing value of RAMTOP if zero.
9420   1EE6             
9421   1EE6             ;; CLEAR-1
9422   1EE6 C5          L1EB7:  PUSH    BC              ; save ramtop value.
9423   1EE7             
9424   1EE7 ED 5B 4B 5C         LD      DE,($5C4B)      ; fetch VARS
9425   1EEB 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE
9426   1EEE 2B                  DEC     HL              ; adjust to point at variables end-marker.
9427   1EEF CD 14 1A            CALL    L19E5           ; routine RECLAIM-1 reclaims the space used by
9428   1EF2                                             ; the variables.
9429   1EF2             
9430   1EF2 CD 9A 0D            CALL    L0D6B           ; routine CLS to clear screen.
9431   1EF5             
9432   1EF5 2A 65 5C            LD      HL,($5C65)      ; fetch STKEND the start of free memory.
9433   1EF8 11 32 00            LD      DE,$0032        ; allow for another 50 bytes.
9434   1EFB 19                  ADD     HL,DE           ; add the overhead to HL.
9435   1EFC             
9436   1EFC D1                  POP     DE              ; restore the ramtop value.
9437   1EFD ED 52               SBC     HL,DE           ; if HL is greater than the value then jump
9438   1EFF 30 08               JR      NC,L1EDA        ; forward to REPORT-M
9439   1F01                                             ; 'RAMTOP no good'
9440   1F01             
9441   1F01 2A B4 5C            LD      HL,($5CB4)      ; now P-RAMT ($7FFF on 16K RAM machine)
9442   1F04 A7                  AND     A               ; exact this time.
9443   1F05 ED 52               SBC     HL,DE           ; new ramtop must be lower or the same.
9444   1F07 30 02               JR      NC,L1EDC        ; skip to CLEAR-2 if in actual RAM.
9445   1F09             
9446   1F09             ;; REPORT-M
9447   1F09 CF          L1EDA:  RST     08H             ; ERROR-1
9448   1F0A 15                  DEFB    $15             ; Error Report: RAMTOP no good
9449   1F0B             
9450   1F0B             ;; CLEAR-2
9451   1F0B EB          L1EDC:  EX      DE,HL           ; transfer ramtop value to HL.
9452   1F0C 22 B2 5C            LD      ($5CB2),HL      ; update system variable RAMTOP.
9453   1F0F D1                  POP     DE              ; pop the return address STMT-RET.
9454   1F10 C1                  POP     BC              ; pop the Error Address.
9455   1F11 36 3E               LD      (HL),$3E        ; now put the GO SUB end-marker at RAMTOP.
9456   1F13 2B                  DEC     HL              ; leave a location beneath it.
9457   1F14 F9                  LD      SP,HL           ; initialize the machine stack pointer.
9458   1F15 C5                  PUSH    BC              ; push the error address.
9459   1F16 ED 73 3D 5C         LD      ($5C3D),SP      ; make ERR_SP point to location.
9460   1F1A EB                  EX      DE,HL           ; put STMT-RET in HL.
9461   1F1B E9                  JP      (HL)            ; and go there directly.
9462   1F1C             
9463   1F1C             ; ---------------------
9464   1F1C             ; Handle GO SUB command
9465   1F1C             ; ---------------------
9466   1F1C             ; The GO SUB command diverts BASIC control to a new line number
9467   1F1C             ; in a very similar manner to GO TO but
9468   1F1C             ; the current line number and current statement + 1
9469   1F1C             ; are placed on the GO SUB stack as a RETURN point.
9470   1F1C             
9471   1F1C             ;; GO-SUB
9472   1F1C D1          L1EED:  POP     DE              ; drop the address STMT-RET
9473   1F1D FD 66 0D            LD      H,(IY+$0D)      ; fetch statement from SUBPPC and
9474   1F20 24                  INC     H               ; increment it
9475   1F21 E3                  EX      (SP),HL         ; swap - error address to HL,
9476   1F22                                             ; H (statement) at top of stack,
9477   1F22                                             ; L (unimportant) beneath.
9478   1F22 33                  INC     SP              ; adjust to overwrite unimportant byte
9479   1F23 ED 4B 45 5C         LD      BC,($5C45)      ; fetch the current line number from PPC
9480   1F27 C5                  PUSH    BC              ; and PUSH onto GO SUB stack.
9481   1F28                                             ; the empty machine-stack can be rebuilt
9482   1F28 E5                  PUSH    HL              ; push the error address.
9483   1F29 ED 73 3D 5C         LD      ($5C3D),SP      ; make system variable ERR_SP point to it.
9484   1F2D D5                  PUSH    DE              ; push the address STMT-RET.
9485   1F2E CD 96 1E            CALL    L1E67           ; call routine GO-TO to update the system
9486   1F31                                             ; variables NEWPPC and NSPPC.
9487   1F31                                             ; then make an indirect exit to STMT-RET via
9488   1F31 01 14 00            LD      BC,$0014        ; a 20-byte overhead memory check.
9489   1F34             
9490   1F34             ; ----------------------
9491   1F34             ; Check available memory
9492   1F34             ; ----------------------
9493   1F34             ; This routine is used on many occasions when extending a dynamic area
9494   1F34             ; upwards or the GO SUB stack downwards.
9495   1F34             
9496   1F34             ;; TEST-ROOM
9497   1F34 2A 65 5C    L1F05:  LD      HL,($5C65)      ; fetch STKEND
9498   1F37 09                  ADD     HL,BC           ; add the supplied test value
9499   1F38 38 0A               JR      C,L1F15         ; forward to REPORT-4 if over $FFFF
9500   1F3A             
9501   1F3A EB                  EX      DE,HL           ; was less so transfer to DE
9502   1F3B 21 50 00            LD      HL,$0050        ; test against another 80 bytes
9503   1F3E 19                  ADD     HL,DE           ; anyway
9504   1F3F 38 03               JR      C,L1F15         ; forward to REPORT-4 if this passes $FFFF
9505   1F41             
9506   1F41 ED 72               SBC     HL,SP           ; if less than the machine stack pointer
9507   1F43 D8                  RET     C               ; then return - OK.
9508   1F44             
9509   1F44             ;; REPORT-4
9510   1F44 2E 03       L1F15:  LD      L,$03           ; prepare 'Out of Memory' 
9511   1F46 C3 55 00            JP      L0055           ; jump back to ERROR-3 at $0055
9512   1F49                                             ; Note. this error can't be trapped at $0008
9513   1F49             
9514   1F49             ; ------------------------------
9515   1F49             ; THE 'FREE MEMORY' USER ROUTINE
9516   1F49             ; ------------------------------
9517   1F49             ; This routine is not used by the ROM but allows users to evaluate
9518   1F49             ; approximate free memory with PRINT 65536 - USR 7962.
9519   1F49             
9520   1F49             ;; free-mem
9521   1F49 01 00 00    L1F1A:  LD      BC,$0000        ; allow no overhead.
9522   1F4C             
9523   1F4C CD 34 1F            CALL    L1F05           ; routine TEST-ROOM.
9524   1F4F             
9525   1F4F 44                  LD      B,H             ; transfer the result
9526   1F50 4D                  LD      C,L             ; to the BC register.
9527   1F51 C9                  RET                     ; the USR function returns value of BC.
9528   1F52             
9529   1F52             ; --------------------
9530   1F52             ; THE 'RETURN' COMMAND
9531   1F52             ; --------------------
9532   1F52             ; As with any command, there are two values on the machine stack at the time 
9533   1F52             ; it is invoked.  The machine stack is below the GOSUB stack.  Both grow 
9534   1F52             ; downwards, the machine stack by two bytes, the GOSUB stack by 3 bytes. 
9535   1F52             ; The highest location is a statement byte followed by a two-byte line number.
9536   1F52             
9537   1F52             ;; RETURN
9538   1F52 C1          L1F23:  POP     BC              ; drop the address STMT-RET.
9539   1F53 E1                  POP     HL              ; now the error address.
9540   1F54 D1                  POP     DE              ; now a possible BASIC return line.
9541   1F55 7A                  LD      A,D             ; the high byte $00 - $27 is 
9542   1F56 FE 3E               CP      $3E             ; compared with the traditional end-marker $3E.
9543   1F58 28 0B               JR      Z,L1F36         ; forward to REPORT-7 with a match.
9544   1F5A                                             ; 'RETURN without GOSUB'
9545   1F5A             
9546   1F5A             ; It was not the end-marker so a single statement byte remains at the base of 
9547   1F5A             ; the calculator stack. It can't be popped off.
9548   1F5A             
9549   1F5A 3B                  DEC     SP              ; adjust stack pointer to create room for two 
9550   1F5B                                             ; bytes.
9551   1F5B E3                  EX      (SP),HL         ; statement to H, error address to base of
9552   1F5C                                             ; new machine stack.
9553   1F5C EB                  EX      DE,HL           ; statement to D,  BASIC line number to HL.
9554   1F5D ED 73 3D 5C         LD      ($5C3D),SP      ; adjust ERR_SP to point to new stack pointer
9555   1F61 C5                  PUSH    BC              ; now re-stack the address STMT-RET
9556   1F62 C3 A2 1E            JP      L1E73           ; to GO-TO-2 to update statement and line
9557   1F65                                             ; system variables and exit indirectly to the
9558   1F65                                             ; address just pushed on stack.
9559   1F65             
9560   1F65             ; ---
9561   1F65             
9562   1F65             ;; REPORT-7
9563   1F65 D5          L1F36:  PUSH    DE              ; replace the end-marker.
9564   1F66 E5                  PUSH    HL              ; now restore the error address
9565   1F67                                             ; as will be required in a few clock cycles.
9566   1F67             
9567   1F67 CF                  RST     08H             ; ERROR-1
9568   1F68 06                  DEFB    $06             ; Error Report: RETURN without GOSUB
9569   1F69             
9570   1F69             ; --------------------
9571   1F69             ; Handle PAUSE command
9572   1F69             ; --------------------
9573   1F69             ; The pause command takes as its parameter the number of interrupts
9574   1F69             ; for which to wait. PAUSE 50 pauses for about a second.
9575   1F69             ; PAUSE 0 pauses indefinitely.
9576   1F69             ; Both forms can be finished by pressing a key.
9577   1F69             
9578   1F69             ;; PAUSE
9579   1F69 CD C8 1E    L1F3A:  CALL    L1E99           ; routine FIND-INT2 puts value in BC
9580   1F6C             
9581   1F6C             ;; PAUSE-1
9582   1F6C 76          L1F3D:  HALT                    ; wait for interrupt.
9583   1F6D 0B                  DEC     BC              ; decrease counter.
9584   1F6E 78                  LD      A,B             ; test if
9585   1F6F B1                  OR      C               ; result is zero.
9586   1F70 28 0C               JR      Z,L1F4F         ; forward to PAUSE-END if so.
9587   1F72             
9588   1F72 78                  LD      A,B             ; test if
9589   1F73 A1                  AND     C               ; now $FFFF
9590   1F74 3C                  INC     A               ; that is, initially zero.
9591   1F75 20 01               JR      NZ,L1F49        ; skip forward to PAUSE-2 if not.
9592   1F77             
9593   1F77 03                  INC     BC              ; restore counter to zero.
9594   1F78             
9595   1F78             ;; PAUSE-2
9596   1F78 FD CB 01 6E L1F49:  BIT     5,(IY+$01)      ; test FLAGS - has a new key been pressed ?
9597   1F7C 28 EE               JR      Z,L1F3D         ; back to PAUSE-1 if not.
9598   1F7E             
9599   1F7E             ;; PAUSE-END
9600   1F7E FD CB 01 AE L1F4F:  RES     5,(IY+$01)      ; update FLAGS - signal no new key
9601   1F82 C9                  RET                     ; and return.
9602   1F83             
9603   1F83             ; -------------------
9604   1F83             ; Check for BREAK key
9605   1F83             ; -------------------
9606   1F83             ; This routine is called from COPY-LINE, when interrupts are disabled,
9607   1F83             ; to test if BREAK (SHIFT - SPACE) is being pressed.
9608   1F83             ; It is also called at STMT-RET after every statement.
9609   1F83             
9610   1F83             ;; BREAK-KEY
9611   1F83 3E EF       L1F54:  LD      A,$EF           ; Input address: $EFFE ; Panagis Upper right row
9612   1F85 DB FE               IN      A,($FE)         ; read upper right keys
9613   1F87 1F                  RRA                     ; rotate bit 0 - SPACE ; Panagis 0 is pressed
9614   1F88 D8                  RET     C               ; return if not reset
9615   1F89             
9616   1F89 3E FE               LD      A,$FE           ; Input address: $FEFE
9617   1F8B DB FE               IN      A,($FE)         ; read lower left keys
9618   1F8D 1F                  RRA                     ; rotate bit 0 - SHIFT
9619   1F8E C9                  RET                     ; carry will be set if not pressed.
9620   1F8F                                             ; return with no carry if both keys
9621   1F8F                                             ; pressed.
9622   1F8F             
9623   1F8F             ; ---------------------
9624   1F8F             ; Handle DEF FN command
9625   1F8F             ; ---------------------
9626   1F8F             ; e.g. DEF FN r$(a$,a) = a$(a TO )
9627   1F8F             ; this 'command' is ignored in runtime but has its syntax checked
9628   1F8F             ; during line-entry.
9629   1F8F             
9630   1F8F             ;; DEF-FN
9631   1F8F CD 5F 25    L1F60:  CALL    L2530           ; routine SYNTAX-Z
9632   1F92 28 05               JR      Z,L1F6A         ; forward to DEF-FN-1 if parsing
9633   1F94             
9634   1F94 3E CE               LD      A,$CE           ; else load A with 'DEF FN' and
9635   1F96 C3 68 1E            JP      L1E39           ; jump back to PASS-BY
9636   1F99             
9637   1F99             ; ---
9638   1F99             
9639   1F99             ; continue here if checking syntax.
9640   1F99             
9641   1F99             ;; DEF-FN-1
9642   1F99 FD CB 01 F6 L1F6A:  SET      6,(IY+$01)     ; set FLAGS  - Assume numeric result
9643   1F9D CD BC 2C            CALL    L2C8D           ; call routine ALPHA
9644   1FA0 30 16               JR      NC,L1F89        ; if not then to DEF-FN-4 to jump to
9645   1FA2                                             ; 'Nonsense in BASIC'
9646   1FA2             
9647   1FA2             
9648   1FA2 E7                  RST     20H             ; NEXT-CHAR
9649   1FA3 FE 24               CP      $24             ; is it '$' ?
9650   1FA5 20 05               JR      NZ,L1F7D        ; to DEF-FN-2 if not as numeric.
9651   1FA7             
9652   1FA7 FD CB 01 B6         RES     6,(IY+$01)      ; set FLAGS  - Signal string result
9653   1FAB             
9654   1FAB E7                  RST     20H             ; get NEXT-CHAR
9655   1FAC             
9656   1FAC             ;; DEF-FN-2
9657   1FAC FE 28       L1F7D:  CP      $28             ; is it '(' ?
9658   1FAE 20 3C               JR      NZ,L1FBD        ; to DEF-FN-7 'Nonsense in BASIC'
9659   1FB0             
9660   1FB0             
9661   1FB0 E7                  RST     20H             ; NEXT-CHAR
9662   1FB1 FE 29               CP      $29             ; is it ')' ?
9663   1FB3 28 20               JR      Z,L1FA6         ; to DEF-FN-6 if null argument
9664   1FB5             
9665   1FB5             ;; DEF-FN-3
9666   1FB5 CD BC 2C    L1F86:  CALL    L2C8D           ; routine ALPHA checks that it is the expected
9667   1FB8                                             ; alphabetic character.
9668   1FB8             
9669   1FB8             ;; DEF-FN-4
9670   1FB8 D2 B9 1C    L1F89:  JP      NC,L1C8A        ; to REPORT-C  if not
9671   1FBB                                             ; 'Nonsense in BASIC'.
9672   1FBB             
9673   1FBB EB                  EX      DE,HL           ; save pointer in DE
9674   1FBC             
9675   1FBC E7                  RST     20H             ; NEXT-CHAR re-initializes HL from CH_ADD
9676   1FBD                                             ; and advances.
9677   1FBD FE 24               CP      $24             ; '$' ? is it a string argument.
9678   1FBF 20 02               JR      NZ,L1F94        ; forward to DEF-FN-5 if not.
9679   1FC1             
9680   1FC1 EB                  EX      DE,HL           ; save pointer to '$' in DE
9681   1FC2             
9682   1FC2 E7                  RST     20H             ; NEXT-CHAR re-initializes HL and advances
9683   1FC3             
9684   1FC3             ;; DEF-FN-5
9685   1FC3 EB          L1F94:  EX      DE,HL           ; bring back pointer.
9686   1FC4 01 06 00            LD      BC,$0006        ; the function requires six hidden bytes for
9687   1FC7                                             ; each parameter passed.
9688   1FC7                                             ; The first byte will be $0E
9689   1FC7                                             ; then 5-byte numeric value
9690   1FC7                                             ; or 5-byte string pointer.
9691   1FC7             
9692   1FC7 CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates space in program
9693   1FCA                                             ; area.
9694   1FCA             
9695   1FCA 23                  INC     HL              ; adjust HL (set by LDDR)
9696   1FCB 23                  INC     HL              ; to point to first location.
9697   1FCC 36 0E               LD      (HL),$0E        ; insert the 'hidden' marker.
9698   1FCE             
9699   1FCE             ; Note. these invisible storage locations hold nothing meaningful for the
9700   1FCE             ; moment. They will be used every time the corresponding function is
9701   1FCE             ; evaluated in runtime.
9702   1FCE             ; Now consider the following character fetched earlier.
9703   1FCE             
9704   1FCE FE 2C               CP      $2C             ; is it ',' ? (more than one parameter)
9705   1FD0 20 03               JR      NZ,L1FA6        ; to DEF-FN-6 if not
9706   1FD2             
9707   1FD2             
9708   1FD2 E7                  RST     20H             ; else NEXT-CHAR
9709   1FD3 18 E0               JR      L1F86           ; and back to DEF-FN-3
9710   1FD5             
9711   1FD5             ; ---
9712   1FD5             
9713   1FD5             ;; DEF-FN-6
9714   1FD5 FE 29       L1FA6:  CP      $29             ; should close with a ')'
9715   1FD7 20 13               JR      NZ,L1FBD        ; to DEF-FN-7 if not
9716   1FD9                                             ; 'Nonsense in BASIC'
9717   1FD9             
9718   1FD9             
9719   1FD9 E7                  RST     20H             ; get NEXT-CHAR
9720   1FDA FE 3D               CP      $3D             ; is it '=' ?
9721   1FDC 20 0E               JR      NZ,L1FBD        ; to DEF-FN-7 if not 'Nonsense...'
9722   1FDE             
9723   1FDE             
9724   1FDE E7                  RST     20H             ; address NEXT-CHAR
9725   1FDF 3A 3B 5C            LD      A,($5C3B)       ; get FLAGS which has been set above
9726   1FE2 F5                  PUSH    AF              ; and preserve
9727   1FE3             
9728   1FE3 CD 2A 25            CALL    L24FB           ; routine SCANNING checks syntax of expression
9729   1FE6                                             ; and also sets flags.
9730   1FE6             
9731   1FE6 F1                  POP     AF              ; restore previous flags
9732   1FE7 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS - bit 6 should be same 
9733   1FEA                                             ; therefore will be reset.
9734   1FEA E6 40               AND     $40             ; isolate bit 6.
9735   1FEC             
9736   1FEC             ;; DEF-FN-7
9737   1FEC C2 B9 1C    L1FBD:  JP      NZ,L1C8A        ; jump back to REPORT-C if the expected result 
9738   1FEF                                             ; is not the same type.
9739   1FEF                                             ; 'Nonsense in BASIC'
9740   1FEF             
9741   1FEF CD 1D 1C            CALL    L1BEE           ; routine CHECK-END will return early if
9742   1FF2                                             ; at end of statement and move onto next
9743   1FF2                                             ; else produce error report. >>>
9744   1FF2             
9745   1FF2                                             ; There will be no return to here.
9746   1FF2             
9747   1FF2             ; -------------------------------
9748   1FF2             ; Returning early from subroutine
9749   1FF2             ; -------------------------------
9750   1FF2             ; All routines are capable of being run in two modes - syntax checking mode
9751   1FF2             ; and runtime mode.  This routine is called often to allow a routine to return 
9752   1FF2             ; early if checking syntax.
9753   1FF2             
9754   1FF2             ;; UNSTACK-Z
9755   1FF2 CD 5F 25    L1FC3:  CALL    L2530           ; routine SYNTAX-Z sets zero flag if syntax
9756   1FF5                                             ; is being checked.
9757   1FF5             
9758   1FF5 E1                  POP     HL              ; drop the return address.
9759   1FF6 C8                  RET      Z              ; return to previous call in chain if checking
9760   1FF7                                             ; syntax.
9761   1FF7             
9762   1FF7 E9                  JP      (HL)            ; jump to return address as BASIC program is
9763   1FF8                                             ; actually running.
9764   1FF8             
9765   1FF8             ; ---------------------
9766   1FF8             ; Handle LPRINT command
9767   1FF8             ; ---------------------
9768   1FF8             ; A simple form of 'PRINT #3' although it can output to 16 streams.
9769   1FF8             ; Probably for compatibility with other BASICs particularly ZX81 BASIC.
9770   1FF8             ; An extra UDG might have been better.
9771   1FF8             
9772   1FF8             ;; LPRINT
9773   1FF8 3E 03       L1FC9:  LD      A,$03           ; the printer channel
9774   1FFA 18 02               JR      L1FCF           ; forward to PRINT-1
9775   1FFC             
9776   1FFC             ; ---------------------
9777   1FFC             ; Handle PRINT commands
9778   1FFC             ; ---------------------
9779   1FFC             ; The Spectrum's main stream output command.
9780   1FFC             ; The default stream is stream 2 which is normally the upper screen
9781   1FFC             ; of the computer. However the stream can be altered in range 0 - 15.
9782   1FFC             
9783   1FFC             ;; PRINT
9784   1FFC 3E 02       L1FCD:  LD      A,$02           ; the stream for the upper screen.
9785   1FFE             
9786   1FFE             ; The LPRINT command joins here.
9787   1FFE             
9788   1FFE             ;; PRINT-1
9789   1FFE CD 5F 25    L1FCF:  CALL    L2530           ; routine SYNTAX-Z checks if program running
9790   2001 C4 30 16            CALL    NZ,L1601        ; routine CHAN-OPEN if so
9791   2004 CD 7C 0D            CALL    L0D4D           ; routine TEMPS sets temporary colours.
9792   2007 CD 0E 20            CALL    L1FDF           ; routine PRINT-2 - the actual item
9793   200A CD 1D 1C            CALL    L1BEE           ; routine CHECK-END gives error if not at end
9794   200D                                             ; of statement
9795   200D C9                  RET                     ; and return >>>
9796   200E             
9797   200E             ; ------------------------------------
9798   200E             ; this subroutine is called from above
9799   200E             ; and also from INPUT.
9800   200E             
9801   200E             ;; PRINT-2
9802   200E DF          L1FDF:  RST     18H             ; GET-CHAR gets printable character
9803   200F CD 74 20            CALL    L2045           ; routine PR-END-Z checks if more printing
9804   2012 28 0D               JR      Z,L1FF2         ; to PRINT-4 if not     e.g. just 'PRINT :'
9805   2014             
9806   2014             ; This tight loop deals with combinations of positional controls and
9807   2014             ; print items. An early return can be made from within the loop
9808   2014             ; if the end of a print sequence is reached.
9809   2014             
9810   2014             ;; PRINT-3
9811   2014 CD 7D 20    L1FE5:  CALL    L204E           ; routine PR-POSN-1 returns zero if more
9812   2017                                             ; but returns early at this point if
9813   2017                                             ; at end of statement!
9814   2017                                             ; 
9815   2017 28 FB               JR      Z,L1FE5         ; to PRINT-3 if consecutive positioners
9816   2019             
9817   2019 CD 2B 20            CALL    L1FFC           ; routine PR-ITEM-1 deals with strings etc.
9818   201C CD 7D 20            CALL    L204E           ; routine PR-POSN-1 for more position codes
9819   201F 28 F3               JR      Z,L1FE5         ; loop back to PRINT-3 if so
9820   2021             
9821   2021             ;; PRINT-4
9822   2021 FE 29       L1FF2:  CP      $29             ; return now if this is ')' from input-item.
9823   2023                                             ; (see INPUT.)
9824   2023 C8                  RET     Z               ; or continue and print carriage return in
9825   2024                                             ; runtime
9826   2024             
9827   2024             ; ---------------------
9828   2024             ; Print carriage return
9829   2024             ; ---------------------
9830   2024             ; This routine which continues from above prints a carriage return
9831   2024             ; in run-time. It is also called once from PRINT-POSN.
9832   2024             
9833   2024             ;; PRINT-CR
9834   2024 CD F2 1F    L1FF5:  CALL    L1FC3           ; routine UNSTACK-Z
9835   2027             
9836   2027 3E 0D               LD      A,$0D           ; prepare a carriage return
9837   2029             
9838   2029 D7                  RST     10H             ; PRINT-A
9839   202A C9                  RET                     ; return
9840   202B             
9841   202B             
9842   202B             ; -----------
9843   202B             ; Print items
9844   202B             ; -----------
9845   202B             ; This routine deals with print items as in
9846   202B             ; PRINT AT 10,0;"The value of A is ";a
9847   202B             ; It returns once a single item has been dealt with as it is part
9848   202B             ; of a tight loop that considers sequences of positional and print items
9849   202B             
9850   202B             ;; PR-ITEM-1
9851   202B DF          L1FFC:  RST     18H             ; GET-CHAR
9852   202C FE AC               CP      $AC             ; is character 'AT' ?
9853   202E 20 0D               JR      NZ,L200E        ; forward to PR-ITEM-2 if not.
9854   2030             
9855   2030 CD A8 1C            CALL    L1C79           ; routine NEXT-2NUM  check for two comma 
9856   2033                                             ; separated numbers placing them on the 
9857   2033                                             ; calculator stack in runtime. 
9858   2033 CD F2 1F            CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
9859   2036             
9860   2036 CD 36 23            CALL    L2307           ; routine STK-TO-BC get the numbers in B and C.
9861   2039 3E 16               LD      A,$16           ; prepare the 'at' control.
9862   203B 18 10               JR      L201E           ; forward to PR-AT-TAB to print the sequence.
9863   203D             
9864   203D             ; ---
9865   203D             
9866   203D             ;; PR-ITEM-2
9867   203D FE AD       L200E:  CP      $AD             ; is character 'TAB' ?
9868   203F 20 12               JR      NZ,L2024        ; to PR-ITEM-3 if not
9869   2041             
9870   2041             
9871   2041 E7                  RST     20H             ; NEXT-CHAR to address next character
9872   2042 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM
9873   2045 CD F2 1F            CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
9874   2048             
9875   2048 CD C8 1E            CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
9876   204B 3E 17               LD      A,$17           ; prepare the 'tab' control.
9877   204D             
9878   204D             ;; PR-AT-TAB
9879   204D D7          L201E:  RST     10H             ; PRINT-A outputs the control
9880   204E             
9881   204E 79                  LD      A,C             ; first value to A
9882   204F D7                  RST     10H             ; PRINT-A outputs it.
9883   2050             
9884   2050 78                  LD      A,B             ; second value
9885   2051 D7                  RST     10H             ; PRINT-A
9886   2052             
9887   2052 C9                  RET                     ; return - item finished >>>
9888   2053             
9889   2053             ; ---
9890   2053             
9891   2053             ; Now consider paper 2; #2; a$
9892   2053             
9893   2053             ;; PR-ITEM-3
9894   2053 CD 21 22    L2024:  CALL    L21F2           ; routine CO-TEMP-3 will print any colour
9895   2056 D0                  RET     NC              ; items - return if success.
9896   2057             
9897   2057 CD 9F 20            CALL    L2070           ; routine STR-ALTER considers new stream
9898   205A D0                  RET     NC              ; return if altered.
9899   205B             
9900   205B CD 2A 25            CALL    L24FB           ; routine SCANNING now to evaluate expression
9901   205E CD F2 1F            CALL    L1FC3           ; routine UNSTACK-Z if not runtime.
9902   2061             
9903   2061 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
9904   2065 CC 20 2C            CALL    Z,L2BF1         ; routine STK-FETCH if string.
9905   2068                                             ; note no flags affected.
9906   2068 C2 12 2E            JP      NZ,L2DE3        ; to PRINT-FP to print if numeric >>>
9907   206B             
9908   206B             ; It was a string expression - start in DE, length in BC
9909   206B             ; Now enter a loop to print it
9910   206B             
9911   206B             ;; PR-STRING
9912   206B 78          L203C:  LD      A,B             ; this tests if the
9913   206C B1                  OR      C               ; length is zero and sets flag accordingly.
9914   206D 0B                  DEC     BC              ; this doesn't but decrements counter.
9915   206E C8                  RET     Z               ; return if zero.
9916   206F             
9917   206F 1A                  LD      A,(DE)          ; fetch character.
9918   2070 13                  INC     DE              ; address next location.
9919   2071             
9920   2071 D7                  RST     10H             ; PRINT-A.
9921   2072             
9922   2072 18 F7               JR      L203C           ; loop back to PR-STRING.
9923   2074             
9924   2074             ; ---------------
9925   2074             ; End of printing
9926   2074             ; ---------------
9927   2074             ; This subroutine returns zero if no further printing is required
9928   2074             ; in the current statement.
9929   2074             ; The first terminator is found in  escaped input items only,
9930   2074             ; the others in print_items.
9931   2074             
9932   2074             ;; PR-END-Z
9933   2074 FE 29       L2045:  CP      $29             ; is character a ')' ?
9934   2076 C8                  RET     Z               ; return if so -        e.g. INPUT (p$); a$
9935   2077             
9936   2077             ;; PR-ST-END
9937   2077 FE 0D       L2048:  CP      $0D             ; is it a carriage return ?
9938   2079 C8                  RET     Z               ; return also -         e.g. PRINT a
9939   207A             
9940   207A FE 3A               CP      $3A             ; is character a ':' ?
9941   207C C9                  RET                     ; return - zero flag will be set if so.
9942   207D                                             ;                       e.g. PRINT a :
9943   207D             
9944   207D             ; --------------
9945   207D             ; Print position
9946   207D             ; --------------
9947   207D             ; This routine considers a single positional character ';', ',', '''
9948   207D             
9949   207D             ;; PR-POSN-1
9950   207D DF          L204E:  RST     18H             ; GET-CHAR
9951   207E FE 3B               CP      $3B             ; is it ';' ?             
9952   2080                                             ; i.e. print from last position.
9953   2080 28 14               JR      Z,L2067         ; forward to PR-POSN-3 if so.
9954   2082                                             ; i.e. do nothing.
9955   2082             
9956   2082 FE 2C               CP      $2C             ; is it ',' ?
9957   2084                                             ; i.e. print at next tabstop.
9958   2084 20 0A               JR      NZ,L2061        ; forward to PR-POSN-2 if anything else.
9959   2086             
9960   2086 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
9961   2089 28 0B               JR      Z,L2067         ; forward to PR-POSN-3 if checking syntax.
9962   208B             
9963   208B 3E 06               LD      A,$06           ; prepare the 'comma' control character.
9964   208D             
9965   208D D7                  RST     10H             ; PRINT-A  outputs to current channel in
9966   208E                                             ; run-time.
9967   208E             
9968   208E 18 06               JR      L2067           ; skip to PR-POSN-3.
9969   2090             
9970   2090             ; ---
9971   2090             
9972   2090             ; check for newline.
9973   2090             
9974   2090             ;; PR-POSN-2
9975   2090 FE 27       L2061:  CP      $27             ; is character a "'" ? (newline)
9976   2092 C0                  RET     NZ              ; return if no match              >>>
9977   2093             
9978   2093 CD 24 20            CALL    L1FF5           ; routine PRINT-CR outputs a carriage return
9979   2096                                             ; in runtime only.
9980   2096             
9981   2096             ;; PR-POSN-3
9982   2096 E7          L2067:  RST     20H             ; NEXT-CHAR to A.
9983   2097 CD 74 20            CALL    L2045           ; routine PR-END-Z checks if at end.
9984   209A 20 01               JR      NZ,L206E        ; to PR-POSN-4 if not.
9985   209C             
9986   209C C1                  POP     BC              ; drop return address if at end.
9987   209D             
9988   209D             ;; PR-POSN-4
9989   209D BF          L206E:  CP      A               ; reset the zero flag.
9990   209E C9                  RET                     ; and return to loop or quit.
9991   209F             
9992   209F             ; ------------
9993   209F             ; Alter stream
9994   209F             ; ------------
9995   209F             ; This routine is called from PRINT ITEMS above, and also LIST as in
9996   209F             ; LIST #15
9997   209F             
9998   209F             ;; STR-ALTER
9999   209F FE 23       L2070:  CP      $23             ; is character '#' ?
10000  20A1 37                  SCF                     ; set carry flag.
10001  20A2 C0                  RET     NZ              ; return if no match.
10002  20A3             
10003  20A3             
10004  20A3 E7                  RST      20H            ; NEXT-CHAR
10005  20A4 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM gets stream number
10006  20A7 A7                  AND     A               ; prepare to exit early with carry reset
10007  20A8 CD F2 1F            CALL    L1FC3           ; routine UNSTACK-Z exits early if parsing
10008  20AB CD C3 1E            CALL    L1E94           ; routine FIND-INT1 gets number off stack
10009  20AE FE 10               CP      $10             ; must be range 0 - 15 decimal.
10010  20B0 D2 3D 16            JP      NC,L160E        ; jump back to REPORT-Oa if not
10011  20B3                                             ; 'Invalid stream'.
10012  20B3             
10013  20B3 CD 30 16            CALL    L1601           ; routine CHAN-OPEN
10014  20B6 A7                  AND     A               ; clear carry - signal item dealt with.
10015  20B7 C9                  RET                     ; return
10016  20B8             
10017  20B8             ; -------------------
10018  20B8             ; THE 'INPUT' COMMAND 
10019  20B8             ; -------------------
10020  20B8             ; This command is mysterious.
10021  20B8             ;
10022  20B8             
10023  20B8             ;; INPUT
10024  20B8 CD 5F 25    L2089:  CALL    L2530           ; routine SYNTAX-Z to check if in runtime.
10025  20BB             
10026  20BB 28 08               JR      Z,L2096         ; forward to INPUT-1 if checking syntax.
10027  20BD             
10028  20BD 3E 01               LD      A,$01           ; select channel 'K' the keyboard for input.
10029  20BF CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens the channel and sets
10030  20C2                                             ; bit 0 of TV_FLAG.
10031  20C2             
10032  20C2             ;   Note. As a consequence of clearing the lower screen channel 0 is made 
10033  20C2             ;   the current channel so the above two instructions are superfluous.
10034  20C2             
10035  20C2 CD 9D 0D            CALL    L0D6E           ; routine CLS-LOWER clears the lower screen
10036  20C5                                             ; and sets DF_SZ to two and TV_FLAG to $01.
10037  20C5             
10038  20C5             ;; INPUT-1
10039  20C5 FD 36 02 01 L2096:  LD      (IY+$02),$01    ; update TV_FLAG - signal lower screen in use
10040  20C9                                             ; ensuring that the correct set of system 
10041  20C9                                             ; variables are updated and that the border 
10042  20C9                                             ; colour is used. 
10043  20C9             
10044  20C9             ;   Note. The Complete Spectrum ROM Disassembly incorrectly names DF-SZ as the
10045  20C9             ;   system variable that is updated above and if, as some have done, you make 
10046  20C9             ;   this unnecessary alteration then there will be two blank lines between the
10047  20C9             ;   lower screen and the upper screen areas which will also scroll wrongly.
10048  20C9             
10049  20C9 CD F0 20            CALL    L20C1           ; routine IN-ITEM-1 to handle the input.
10050  20CC             
10051  20CC CD 1D 1C            CALL    L1BEE           ; routine CHECK-END will make an early exit
10052  20CF                                             ; if checking syntax. >>>
10053  20CF             
10054  20CF             ;   Keyboard input has been made and it remains to adjust the upper
10055  20CF             ;   screen in case the lower two lines have been extended upwards.
10056  20CF             
10057  20CF ED 4B 88 5C         LD      BC,($5C88)      ; fetch S_POSN current line/column of
10058  20D3                                             ; the upper screen.
10059  20D3 3A 6B 5C            LD      A,($5C6B)       ; fetch DF_SZ the display file size of
10060  20D6                                             ; the lower screen.
10061  20D6 B8                  CP      B               ; test that lower screen does not overlap
10062  20D7 38 03               JR      C,L20AD         ; forward to INPUT-2 if not.
10063  20D9             
10064  20D9             ; the two screens overlap so adjust upper screen.
10065  20D9             
10066  20D9 0E 21               LD      C,$21           ; set column of upper screen to leftmost.
10067  20DB 47                  LD      B,A             ; and line to one above lower screen.
10068  20DC                                             ; continue forward to update upper screen
10069  20DC                                             ; print position.
10070  20DC             
10071  20DC             ;; INPUT-2
10072  20DC ED 43 88 5C L20AD:  LD      ($5C88),BC      ; set S_POSN update upper screen line/column.
10073  20E0 3E 19               LD      A,$19           ; subtract from twenty five
10074  20E2 90                  SUB     B               ; the new line number.
10075  20E3 32 8C 5C            LD      ($5C8C),A       ; and place result in SCR_CT - scroll count.
10076  20E6 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use.
10077  20EA             
10078  20EA CD 08 0E            CALL    L0DD9           ; routine CL-SET sets the print position
10079  20ED                                             ; system variables for the upper screen.
10080  20ED             
10081  20ED C3 9D 0D            JP      L0D6E           ; jump back to CLS-LOWER and make
10082  20F0                                             ; an indirect exit >>.
10083  20F0             
10084  20F0             ; ---------------------
10085  20F0             ; INPUT ITEM subroutine
10086  20F0             ; ---------------------
10087  20F0             ;   This subroutine deals with the input items and print items.
10088  20F0             ;   from  the current input channel.
10089  20F0             ;   It is only called from the above INPUT routine but was obviously
10090  20F0             ;   once called from somewhere else in another context.
10091  20F0             
10092  20F0             ;; IN-ITEM-1
10093  20F0 CD 7D 20    L20C1:  CALL    L204E           ; routine PR-POSN-1 deals with a single
10094  20F3                                             ; position item at each call.
10095  20F3 28 FB               JR      Z,L20C1         ; back to IN-ITEM-1 until no more in a
10096  20F5                                             ; sequence.
10097  20F5             
10098  20F5 FE 28               CP      $28             ; is character '(' ?
10099  20F7 20 0E               JR      NZ,L20D8        ; forward to IN-ITEM-2 if not.
10100  20F9             
10101  20F9             ;   any variables within braces will be treated as part, or all, of the prompt
10102  20F9             ;   instead of being used as destination variables.
10103  20F9             
10104  20F9 E7                  RST     20H             ; NEXT-CHAR
10105  20FA CD 0E 20            CALL    L1FDF           ; routine PRINT-2 to output the dynamic
10106  20FD                                             ; prompt.
10107  20FD             
10108  20FD DF                  RST     18H             ; GET-CHAR
10109  20FE FE 29               CP      $29             ; is character a matching ')' ?
10110  2100 C2 B9 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not.
10111  2103                                             ; 'Nonsense in BASIC'.
10112  2103             
10113  2103 E7                  RST     20H             ; NEXT-CHAR
10114  2104 C3 E1 21            JP      L21B2           ; forward to IN-NEXT-2
10115  2107             
10116  2107             ; ---
10117  2107             
10118  2107             ;; IN-ITEM-2
10119  2107 FE CA       L20D8:  CP      $CA             ; is the character the token 'LINE' ?
10120  2109 20 11               JR      NZ,L20ED        ; forward to IN-ITEM-3 if not.
10121  210B             
10122  210B E7                  RST     20H             ; NEXT-CHAR - variable must come next.
10123  210C CD 4E 1C            CALL    L1C1F           ; routine CLASS-01 returns destination
10124  210F                                             ; address of variable to be assigned.
10125  210F                                             ; or generates an error if no variable
10126  210F                                             ; at this position.
10127  210F             
10128  210F FD CB 37 FE         SET     7,(IY+$37)      ; update FLAGX  - signal handling INPUT LINE
10129  2113 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - numeric or string result ?
10130  2117 C2 B9 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not string
10131  211A                                             ; 'Nonsense in BASIC'.
10132  211A             
10133  211A 18 0D               JR      L20FA           ; forward to IN-PROMPT to set up workspace.
10134  211C             
10135  211C             ; ---
10136  211C             
10137  211C             ;   the jump was here for other variables.
10138  211C             
10139  211C             ;; IN-ITEM-3
10140  211C CD BC 2C    L20ED:  CALL     L2C8D          ; routine ALPHA checks if character is
10141  211F                                             ; a suitable variable name.
10142  211F D2 DE 21            JP      NC,L21AF        ; forward to IN-NEXT-1 if not
10143  2122             
10144  2122 CD 4E 1C            CALL    L1C1F           ; routine CLASS-01 returns destination
10145  2125                                             ; address of variable to be assigned.
10146  2125 FD CB 37 BE         RES     7,(IY+$37)      ; update FLAGX  - signal not INPUT LINE.
10147  2129             
10148  2129             ;; IN-PROMPT
10149  2129 CD 5F 25    L20FA:  CALL    L2530           ; routine SYNTAX-Z
10150  212C CA E1 21            JP      Z,L21B2         ; forward to IN-NEXT-2 if checking syntax.
10151  212F             
10152  212F CD EE 16            CALL    L16BF           ; routine SET-WORK clears workspace.
10153  2132 21 71 5C            LD      HL,$5C71        ; point to system variable FLAGX
10154  2135 CB B6               RES     6,(HL)          ; signal string result.
10155  2137 CB EE               SET     5,(HL)          ; signal in Input Mode for editor.
10156  2139 01 01 00            LD      BC,$0001        ; initialize space required to one for
10157  213C                                             ; the carriage return.
10158  213C CB 7E               BIT     7,(HL)          ; test FLAGX - INPUT LINE in use ?
10159  213E 20 0B               JR      NZ,L211C        ; forward to IN-PR-2 if so as that is
10160  2140                                             ; all the space that is required.
10161  2140             
10162  2140 3A 3B 5C            LD      A,($5C3B)       ; load accumulator from FLAGS
10163  2143 E6 40               AND     $40             ; mask to test BIT 6 of FLAGS and clear
10164  2145                                             ; the other bits in A.
10165  2145                                             ; numeric result expected ?
10166  2145 20 02               JR      NZ,L211A        ; forward to IN-PR-1 if so
10167  2147             
10168  2147 0E 03               LD      C,$03           ; increase space to three bytes for the
10169  2149                                             ; pair of surrounding quotes.
10170  2149             
10171  2149             ;; IN-PR-1
10172  2149 B6          L211A:  OR      (HL)            ; if numeric result, set bit 6 of FLAGX.
10173  214A 77                  LD      (HL),A          ; and update system variable
10174  214B             
10175  214B             ;; IN-PR-2
10176  214B F7          L211C:  RST     30H             ; BC-SPACES opens 1 or 3 bytes in workspace
10177  214C 36 0D               LD      (HL),$0D        ; insert carriage return at last new location.
10178  214E 79                  LD      A,C             ; fetch the length, one or three.
10179  214F 0F                  RRCA                    ; lose bit 0.
10180  2150 0F                  RRCA                    ; test if quotes required.
10181  2151 30 05               JR      NC,L2129        ; forward to IN-PR-3 if not.
10182  2153             
10183  2153 3E 22               LD      A,$22           ; load the '"' character
10184  2155 12                  LD      (DE),A          ; place quote in first new location at DE.
10185  2156 2B                  DEC     HL              ; decrease HL - from carriage return.
10186  2157 77                  LD      (HL),A          ; and place a quote in second location.
10187  2158             
10188  2158             ;; IN-PR-3
10189  2158 22 5B 5C    L2129:  LD      ($5C5B),HL      ; set keyboard cursor K_CUR to HL
10190  215B FD CB 37 7E         BIT     7,(IY+$37)      ; test FLAGX  - is this INPUT LINE ??
10191  215F 20 2C               JR      NZ,L215E        ; forward to IN-VAR-3 if so as input will
10192  2161                                             ; be accepted without checking its syntax.
10193  2161             
10194  2161 2A 5D 5C            LD      HL,($5C5D)      ; fetch CH_ADD
10195  2164 E5                  PUSH    HL              ; and save on stack.
10196  2165 2A 3D 5C            LD      HL,($5C3D)      ; fetch ERR_SP
10197  2168 E5                  PUSH    HL              ; and save on stack
10198  2169             
10199  2169             ;; IN-VAR-1
10200  2169 21 69 21    L213A:  LD      HL,L213A        ; address: IN-VAR-1 - this address
10201  216C E5                  PUSH    HL              ; is saved on stack to handle errors.
10202  216D FD CB 30 66         BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
10203  2171 28 04               JR      Z,L2148         ; forward to IN-VAR-2 if not using the
10204  2173                                             ; keyboard for input. (??)
10205  2173             
10206  2173 ED 73 3D 5C         LD      ($5C3D),SP      ; set ERR_SP to point to IN-VAR-1 on stack.
10207  2177             
10208  2177             ;; IN-VAR-2
10209  2177 2A 61 5C    L2148:  LD      HL,($5C61)      ; set HL to WORKSP - start of workspace.
10210  217A CD D6 11            CALL    L11A7           ; routine REMOVE-FP removes floating point
10211  217D                                             ; forms when looping in error condition.
10212  217D FD 36 00 FF         LD      (IY+$00),$FF    ; set ERR_NR to 'OK' cancelling the error.
10213  2181                                             ; but X_PTR causes flashing error marker
10214  2181                                             ; to be displayed at each call to the editor.
10215  2181 CD 5B 0F            CALL    L0F2C           ; routine EDITOR allows input to be entered
10216  2184                                             ; or corrected if this is second time around.
10217  2184             
10218  2184             ; if we pass to next then there are no system errors
10219  2184             
10220  2184 FD CB 01 BE         RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax
10221  2188 CD E8 21            CALL    L21B9           ; routine IN-ASSIGN checks syntax using
10222  218B                                             ; the VAL-FET-2 and powerful SCANNING routines.
10223  218B                                             ; any syntax error and its back to IN-VAR-1.
10224  218B                                             ; but with the flashing error marker showing
10225  218B                                             ; where the error is.
10226  218B                                             ; Note. the syntax of string input has to be
10227  218B                                             ; checked as the user may have removed the
10228  218B                                             ; bounding quotes or escaped them as with
10229  218B                                             ; "hat" + "stand" for example.
10230  218B             ; proceed if syntax passed.
10231  218B             
10232  218B 18 03               JR      L2161           ; jump forward to IN-VAR-4
10233  218D             
10234  218D             ; ---
10235  218D             
10236  218D             ; the jump was to here when using INPUT LINE.
10237  218D             
10238  218D             ;; IN-VAR-3
10239  218D CD 5B 0F    L215E:  CALL    L0F2C           ; routine EDITOR is called for input
10240  2190             
10241  2190             ; when ENTER received rejoin other route but with no syntax check.
10242  2190             
10243  2190             ; INPUT and INPUT LINE converge here.
10244  2190             
10245  2190             ;; IN-VAR-4
10246  2190 FD 36 22 00 L2161:  LD      (IY+$22),$00    ; set K_CUR_hi to a low value so that the cursor
10247  2194                                             ; no longer appears in the input line.
10248  2194             
10249  2194 CD 05 22            CALL    L21D6           ; routine IN-CHAN-K tests if the keyboard
10250  2197                                             ; is being used for input.
10251  2197 20 0A               JR      NZ,L2174        ; forward to IN-VAR-5 if using another input 
10252  2199                                             ; channel.
10253  2199             
10254  2199             ; continue here if using the keyboard.
10255  2199             
10256  2199 CD 4C 11            CALL    L111D           ; routine ED-COPY overprints the edit line
10257  219C                                             ; to the lower screen. The only visible
10258  219C                                             ; affect is that the cursor disappears.
10259  219C                                             ; if you're inputting more than one item in
10260  219C                                             ; a statement then that becomes apparent.
10261  219C             
10262  219C ED 4B 82 5C         LD      BC,($5C82)      ; fetch line and column from ECHO_E
10263  21A0 CD 08 0E            CALL    L0DD9           ; routine CL-SET sets S-POSNL to those
10264  21A3                                             ; values.
10265  21A3             
10266  21A3             ; if using another input channel rejoin here.
10267  21A3             
10268  21A3             ;; IN-VAR-5
10269  21A3 21 71 5C    L2174:  LD      HL,$5C71        ; point HL to FLAGX
10270  21A6 CB AE               RES     5,(HL)          ; signal not in input mode
10271  21A8 CB 7E               BIT     7,(HL)          ; is this INPUT LINE ?
10272  21AA CB BE               RES     7,(HL)          ; cancel the bit anyway.
10273  21AC 20 1C               JR      NZ,L219B        ; forward to IN-VAR-6 if INPUT LINE.
10274  21AE             
10275  21AE E1                  POP     HL              ; drop the looping address
10276  21AF E1                  POP     HL              ; drop the address of previous
10277  21B0                                             ; error handler.
10278  21B0 22 3D 5C            LD      ($5C3D),HL      ; set ERR_SP to point to it.
10279  21B3 E1                  POP     HL              ; drop original CH_ADD which points to
10280  21B4                                             ; INPUT command in BASIC line.
10281  21B4 22 5F 5C            LD      ($5C5F),HL      ; save in X_PTR while input is assigned.
10282  21B7 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS - Signal running program
10283  21BB CD E8 21            CALL    L21B9           ; routine IN-ASSIGN is called again
10284  21BE                                             ; this time the variable will be assigned
10285  21BE                                             ; the input value without error.
10286  21BE                                             ; Note. the previous example now
10287  21BE                                             ; becomes "hatstand"
10288  21BE             
10289  21BE 2A 5F 5C            LD      HL,($5C5F)      ; fetch stored CH_ADD value from X_PTR.
10290  21C1 FD 36 26 00         LD      (IY+$26),$00    ; set X_PTR_hi so that iy is no longer relevant.
10291  21C5 22 5D 5C            LD      ($5C5D),HL      ; put restored value back in CH_ADD
10292  21C8 18 17               JR      L21B2           ; forward to IN-NEXT-2 to see if anything
10293  21CA                                             ; more in the INPUT list.
10294  21CA             
10295  21CA             ; ---
10296  21CA             
10297  21CA             ; the jump was to here with INPUT LINE only
10298  21CA             
10299  21CA             ;; IN-VAR-6
10300  21CA 2A 63 5C    L219B:  LD      HL,($5C63)      ; STKBOT points to the end of the input.
10301  21CD ED 5B 61 5C         LD      DE,($5C61)      ; WORKSP points to the beginning.
10302  21D1 37                  SCF                     ; prepare for true subtraction.
10303  21D2 ED 52               SBC     HL,DE           ; subtract to get length
10304  21D4 44                  LD      B,H             ; transfer it to
10305  21D5 4D                  LD      C,L             ; the BC register pair.
10306  21D6 CD E1 2A            CALL    L2AB2           ; routine STK-STO-$ stores parameters on
10307  21D9                                             ; the calculator stack.
10308  21D9 CD 2E 2B            CALL    L2AFF           ; routine LET assigns it to destination.
10309  21DC 18 03               JR      L21B2           ; forward to IN-NEXT-2 as print items
10310  21DE                                             ; not allowed with INPUT LINE.
10311  21DE                                             ; Note. that "hat" + "stand" will, for
10312  21DE                                             ; example, be unchanged as also would
10313  21DE                                             ; 'PRINT "Iris was here"'.
10314  21DE             
10315  21DE             ; ---
10316  21DE             
10317  21DE             ; the jump was to here when ALPHA found more items while looking for
10318  21DE             ; a variable name.
10319  21DE             
10320  21DE             ;; IN-NEXT-1
10321  21DE CD 2B 20    L21AF:  CALL    L1FFC           ; routine PR-ITEM-1 considers further items.
10322  21E1             
10323  21E1             ;; IN-NEXT-2
10324  21E1 CD 7D 20    L21B2:  CALL    L204E           ; routine PR-POSN-1 handles a position item.
10325  21E4 CA F0 20            JP      Z,L20C1         ; jump back to IN-ITEM-1 if the zero flag
10326  21E7                                             ; indicates more items are present.
10327  21E7             
10328  21E7 C9                  RET                     ; return.
10329  21E8             
10330  21E8             ; ---------------------------
10331  21E8             ; INPUT ASSIGNMENT Subroutine
10332  21E8             ; ---------------------------
10333  21E8             ; This subroutine is called twice from the INPUT command when normal
10334  21E8             ; keyboard input is assigned. On the first occasion syntax is checked
10335  21E8             ; using SCANNING. The final call with the syntax flag reset is to make
10336  21E8             ; the assignment.
10337  21E8             
10338  21E8             ;; IN-ASSIGN
10339  21E8 2A 61 5C    L21B9:  LD      HL,($5C61)      ; fetch WORKSP start of input
10340  21EB 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to first character
10341  21EE             
10342  21EE DF                  RST     18H             ; GET-CHAR ignoring leading white-space.
10343  21EF FE E2               CP      $E2             ; is it 'STOP'
10344  21F1 28 0C               JR      Z,L21D0         ; forward to IN-STOP if so.
10345  21F3             
10346  21F3 3A 71 5C            LD      A,($5C71)       ; load accumulator from FLAGX
10347  21F6 CD 88 1C            CALL    L1C59           ; routine VAL-FET-2 makes assignment
10348  21F9                                             ; or goes through the motions if checking
10349  21F9                                             ; syntax. SCANNING is used.
10350  21F9             
10351  21F9 DF                  RST     18H             ; GET-CHAR
10352  21FA FE 0D               CP      $0D             ; is it carriage return ?
10353  21FC C8                  RET     Z               ; return if so
10354  21FD                                             ; either syntax is OK
10355  21FD                                             ; or assignment has been made.
10356  21FD             
10357  21FD             ; if another character was found then raise an error.
10358  21FD             ; User doesn't see report but the flashing error marker
10359  21FD             ; appears in the lower screen.
10360  21FD             
10361  21FD             ;; REPORT-Cb
10362  21FD CF          L21CE:  RST     08H             ; ERROR-1
10363  21FE 0B                  DEFB    $0B             ; Error Report: Nonsense in BASIC
10364  21FF             
10365  21FF             ;; IN-STOP
10366  21FF CD 5F 25    L21D0:  CALL    L2530           ; routine SYNTAX-Z (UNSTACK-Z?)
10367  2202 C8                  RET     Z               ; return if checking syntax
10368  2203                                             ; as user wouldn't see error report.
10369  2203                                             ; but generate visible error report
10370  2203                                             ; on second invocation.
10371  2203             
10372  2203             ;; REPORT-H
10373  2203 CF          L21D4:  RST     08H             ; ERROR-1
10374  2204 10                  DEFB    $10             ; Error Report: STOP in INPUT
10375  2205             
10376  2205             ; -----------------------------------
10377  2205             ; THE 'TEST FOR CHANNEL K' SUBROUTINE
10378  2205             ; -----------------------------------
10379  2205             ;   This subroutine is called once from the keyboard INPUT command to check if 
10380  2205             ;   the input routine in use is the one for the keyboard.
10381  2205             
10382  2205             ;; IN-CHAN-K
10383  2205 2A 51 5C    L21D6:  LD      HL,($5C51)      ; fetch address of current channel CURCHL
10384  2208 23                  INC     HL              ;
10385  2209 23                  INC     HL              ; advance past
10386  220A 23                  INC     HL              ; input and
10387  220B 23                  INC     HL              ; output streams
10388  220C 7E                  LD      A,(HL)          ; fetch the channel identifier.
10389  220D FE 4B               CP      $4B             ; test for 'K'
10390  220F C9                  RET                     ; return with zero set if keyboard is use.
10391  2210             
10392  2210             ; --------------------
10393  2210             ; Colour Item Routines
10394  2210             ; --------------------
10395  2210             ;
10396  2210             ; These routines have 3 entry points -
10397  2210             ; 1) CO-TEMP-2 to handle a series of embedded Graphic colour items.
10398  2210             ; 2) CO-TEMP-3 to handle a single embedded print colour item.
10399  2210             ; 3) CO TEMP-4 to handle a colour command such as FLASH 1
10400  2210             ;
10401  2210             ; "Due to a bug, if you bring in a peripheral channel and later use a colour
10402  2210             ;  statement, colour controls will be sent to it by mistake." - Steven Vickers
10403  2210             ;  Pitman Pocket Guide, 1984.
10404  2210             ;
10405  2210             ; To be fair, this only applies if the last channel was other than 'K', 'S'
10406  2210             ; or 'P', which are all that are supported by this ROM, but if that last
10407  2210             ; channel was a microdrive file, network channel etc. then
10408  2210             ; PAPER 6; CLS will not turn the screen yellow and
10409  2210             ; CIRCLE INK 2; 128,88,50 will not draw a red circle.
10410  2210             ;
10411  2210             ; This bug does not apply to embedded PRINT items as it is quite permissible
10412  2210             ; to mix stream altering commands and colour items.
10413  2210             ; The fix therefore would be to ensure that CLASS-07 and CLASS-09 make
10414  2210             ; channel 'S' the current channel when not checking syntax.
10415  2210             ; -----------------------------------------------------------------
10416  2210             
10417  2210             ;; CO-TEMP-1
10418  2210 E7          L21E1:  RST     20H             ; NEXT-CHAR
10419  2211             
10420  2211             ; -> Entry point from CLASS-09. Embedded Graphic colour items.
10421  2211             ; e.g. PLOT INK 2; PAPER 8; 128,88
10422  2211             ; Loops till all colour items output, finally addressing the coordinates.
10423  2211             
10424  2211             ;; CO-TEMP-2
10425  2211 CD 21 22    L21E2:  CALL    L21F2           ; routine CO-TEMP-3 to output colour control.
10426  2214 D8                  RET     C               ; return if nothing more to output. ->
10427  2215             
10428  2215             
10429  2215 DF                  RST     18H             ; GET-CHAR
10430  2216 FE 2C               CP      $2C             ; is it ',' separator ?
10431  2218 28 F6               JR      Z,L21E1         ; back if so to CO-TEMP-1
10432  221A             
10433  221A FE 3B               CP      $3B             ; is it ';' separator ?
10434  221C 28 F2               JR      Z,L21E1         ; back to CO-TEMP-1 for more.
10435  221E             
10436  221E C3 B9 1C            JP      L1C8A           ; to REPORT-C (REPORT-Cb is within range)
10437  2221                                             ; 'Nonsense in BASIC'
10438  2221             
10439  2221             ; -------------------
10440  2221             ; CO-TEMP-3
10441  2221             ; -------------------
10442  2221             ; -> this routine evaluates and outputs a colour control and parameter.
10443  2221             ; It is called from above and also from PR-ITEM-3 to handle a single embedded
10444  2221             ; print item e.g. PRINT PAPER 6; "Hi". In the latter case, the looping for
10445  2221             ; multiple items is within the PR-ITEM routine.
10446  2221             ; It is quite permissible to send these to any stream.
10447  2221             
10448  2221             ;; CO-TEMP-3
10449  2221 FE D9       L21F2:  CP      $D9             ; is it 'INK' ?
10450  2223 D8                  RET     C               ; return if less.
10451  2224             
10452  2224 FE DF               CP      $DF             ; compare with 'OUT'
10453  2226 3F                  CCF                     ; Complement Carry Flag
10454  2227 D8                  RET     C               ; return if greater than 'OVER', $DE.
10455  2228             
10456  2228 F5                  PUSH    AF              ; save the colour token.
10457  2229             
10458  2229 E7                  RST     20H             ; address NEXT-CHAR
10459  222A F1                  POP     AF              ; restore token and continue.
10460  222B             
10461  222B             ; -> this entry point used by CLASS-07. e.g. the command PAPER 6.
10462  222B             
10463  222B             ;; CO-TEMP-4
10464  222B D6 C9       L21FC:  SUB     $C9             ; reduce to control character $10 (INK)
10465  222D                                             ; thru $15 (OVER).
10466  222D F5                  PUSH    AF              ; save control.
10467  222E CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM stacks addressed
10468  2231                                             ; parameter on calculator stack.
10469  2231 F1                  POP     AF              ; restore control.
10470  2232 A7                  AND     A               ; clear carry
10471  2233             
10472  2233 CD F2 1F            CALL    L1FC3           ; routine UNSTACK-Z returns if checking syntax.
10473  2236             
10474  2236 F5                  PUSH    AF              ; save again
10475  2237 CD C3 1E            CALL    L1E94           ; routine FIND-INT1 fetches parameter to A.
10476  223A 57                  LD      D,A             ; transfer now to D
10477  223B F1                  POP     AF              ; restore control.
10478  223C             
10479  223C D7                  RST     10H             ; PRINT-A outputs the control to current
10480  223D                                             ; channel.
10481  223D 7A                  LD      A,D             ; transfer parameter to A.
10482  223E             
10483  223E D7                  RST     10H             ; PRINT-A outputs parameter.
10484  223F C9                  RET                     ; return. ->
10485  2240             
10486  2240             ; -------------------------------------------------------------------------
10487  2240             ;
10488  2240             ;         {fl}{br}{   paper   }{  ink    }    The temporary colour attributes
10489  2240             ;          ___ ___ ___ ___ ___ ___ ___ ___    system variable.
10490  2240             ; ATTR_T  |   |   |   |   |   |   |   |   |
10491  2240             ;         |   |   |   |   |   |   |   |   |
10492  2240             ; 23695   |___|___|___|___|___|___|___|___|
10493  2240             ;           7   6   5   4   3   2   1   0
10494  2240             ;
10495  2240             ;
10496  2240             ;         {fl}{br}{   paper   }{  ink    }    The temporary mask used for
10497  2240             ;          ___ ___ ___ ___ ___ ___ ___ ___    transparent colours. Any bit
10498  2240             ; MASK_T  |   |   |   |   |   |   |   |   |   that is 1 shows that the
10499  2240             ;         |   |   |   |   |   |   |   |   |   corresponding attribute is
10500  2240             ; 23696   |___|___|___|___|___|___|___|___|   taken not from ATTR-T but from
10501  2240             ;           7   6   5   4   3   2   1   0     what is already on the screen.
10502  2240             ;
10503  2240             ;
10504  2240             ;         {paper9 }{ ink9 }{ inv1 }{ over1}   The print flags. Even bits are
10505  2240             ;          ___ ___ ___ ___ ___ ___ ___ ___    temporary flags. The odd bits
10506  2240             ; P_FLAG  |   |   |   |   |   |   |   |   |   are the permanent flags.
10507  2240             ;         | p | t | p | t | p | t | p | t |
10508  2240             ; 23697   |___|___|___|___|___|___|___|___|
10509  2240             ;           7   6   5   4   3   2   1   0
10510  2240             ;
10511  2240             ; -----------------------------------------------------------------------
10512  2240             
10513  2240             ; ------------------------------------
10514  2240             ;  The colour system variable handler.
10515  2240             ; ------------------------------------
10516  2240             ; This is an exit branch from PO-1-OPER, PO-2-OPER
10517  2240             ; A holds control $10 (INK) to $15 (OVER)
10518  2240             ; D holds parameter 0-9 for ink/paper 0,1 or 8 for bright/flash,
10519  2240             ; 0 or 1 for over/inverse.
10520  2240             
10521  2240             ;; CO-TEMP-5
10522  2240 D6 11       L2211:  SUB     $11             ; reduce range $FF-$04
10523  2242 CE 00               ADC     A,$00           ; add in carry if INK
10524  2244 28 1D               JR      Z,L2234         ; forward to CO-TEMP-7 with INK and PAPER.
10525  2246             
10526  2246 D6 02               SUB     $02             ; reduce range $FF-$02
10527  2248 CE 00               ADC     A,$00           ; add carry if FLASH
10528  224A 28 56               JR      Z,L2273         ; forward to CO-TEMP-C with FLASH and BRIGHT.
10529  224C             
10530  224C FE 01               CP      $01             ; is it 'INVERSE' ?
10531  224E 7A                  LD      A,D             ; fetch parameter for INVERSE/OVER
10532  224F 06 01               LD      B,$01           ; prepare OVER mask setting bit 0.
10533  2251 20 04               JR      NZ,L2228        ; forward to CO-TEMP-6 if OVER
10534  2253             
10535  2253 07                  RLCA                    ; shift bit 0
10536  2254 07                  RLCA                    ; to bit 2
10537  2255 06 04               LD      B,$04           ; set bit 2 of mask for inverse.
10538  2257             
10539  2257             ;; CO-TEMP-6
10540  2257 4F          L2228:  LD      C,A             ; save the A
10541  2258 7A                  LD      A,D             ; re-fetch parameter
10542  2259 FE 02               CP      $02             ; is it less than 2
10543  225B 30 16               JR      NC,L2244        ; to REPORT-K if not 0 or 1.
10544  225D                                             ; 'Invalid colour'.
10545  225D             
10546  225D 79                  LD      A,C             ; restore A
10547  225E 21 91 5C            LD      HL,$5C91        ; address system variable P_FLAG
10548  2261 18 38               JR      L226C           ; forward to exit via routine CO-CHANGE
10549  2263             
10550  2263             ; ---
10551  2263             
10552  2263             ; the branch was here with INK/PAPER and carry set for INK.
10553  2263             
10554  2263             ;; CO-TEMP-7
10555  2263 7A          L2234:  LD      A,D             ; fetch parameter
10556  2264 06 07               LD      B,$07           ; set ink mask 00000111
10557  2266 38 05               JR      C,L223E         ; forward to CO-TEMP-8 with INK
10558  2268             
10559  2268 07                  RLCA                    ; shift bits 0-2
10560  2269 07                  RLCA                    ; to
10561  226A 07                  RLCA                    ; bits 3-5
10562  226B 06 38               LD      B,$38           ; set paper mask 00111000
10563  226D             
10564  226D             ; both paper and ink rejoin here
10565  226D             
10566  226D             ;; CO-TEMP-8
10567  226D 4F          L223E:  LD      C,A             ; value to C
10568  226E 7A                  LD      A,D             ; fetch parameter
10569  226F FE 0A               CP      $0A             ; is it less than 10d ?
10570  2271 38 02               JR      C,L2246         ; forward to CO-TEMP-9 if so.
10571  2273             
10572  2273             ; ink 10 etc. is not allowed.
10573  2273             
10574  2273             ;; REPORT-K
10575  2273 CF          L2244:  RST     08H             ; ERROR-1
10576  2274 13                  DEFB    $13             ; Error Report: Invalid colour
10577  2275             
10578  2275             ;; CO-TEMP-9
10579  2275 21 8F 5C    L2246:  LD      HL,$5C8F        ; address system variable ATTR_T initially.
10580  2278 FE 08               CP      $08             ; compare with 8
10581  227A 38 0B               JR      C,L2258         ; forward to CO-TEMP-B with 0-7.
10582  227C             
10583  227C 7E                  LD      A,(HL)          ; fetch temporary attribute as no change.
10584  227D 28 07               JR      Z,L2257         ; forward to CO-TEMP-A with INK/PAPER 8
10585  227F             
10586  227F             ; it is either ink 9 or paper 9 (contrasting)
10587  227F             
10588  227F B0                  OR      B               ; or with mask to make white
10589  2280 2F                  CPL                     ; make black and change other to dark
10590  2281 E6 24               AND     $24             ; 00100100
10591  2283 28 01               JR      Z,L2257         ; forward to CO-TEMP-A if black and
10592  2285                                             ; originally light.
10593  2285             
10594  2285 78                  LD      A,B             ; else just use the mask (white)
10595  2286             
10596  2286             ;; CO-TEMP-A
10597  2286 4F          L2257:  LD      C,A             ; save A in C
10598  2287             
10599  2287             ;; CO-TEMP-B
10600  2287 79          L2258:  LD      A,C             ; load colour to A
10601  2288 CD 9B 22            CALL    L226C           ; routine CO-CHANGE addressing ATTR-T
10602  228B             
10603  228B 3E 07               LD      A,$07           ; put 7 in accumulator
10604  228D BA                  CP      D               ; compare with parameter
10605  228E 9F                  SBC     A,A             ; $00 if 0-7, $FF if 8
10606  228F CD 9B 22            CALL    L226C           ; routine CO-CHANGE addressing MASK-T
10607  2292                                             ; mask returned in A.
10608  2292             
10609  2292             ; now consider P-FLAG.
10610  2292             
10611  2292 07                  RLCA                    ; 01110000 or 00001110
10612  2293 07                  RLCA                    ; 11100000 or 00011100
10613  2294 E6 50               AND     $50             ; 01000000 or 00010000  (AND 01010000)
10614  2296 47                  LD      B,A             ; transfer to mask
10615  2297 3E 08               LD      A,$08           ; load A with 8
10616  2299 BA                  CP      D               ; compare with parameter
10617  229A 9F                  SBC     A,A             ; $FF if was 9,  $00 if 0-8
10618  229B                                             ; continue while addressing P-FLAG
10619  229B                                             ; setting bit 4 if ink 9
10620  229B                                             ; setting bit 6 if paper 9
10621  229B             
10622  229B             ; -----------------------
10623  229B             ; Handle change of colour
10624  229B             ; -----------------------
10625  229B             ; This routine addresses a system variable ATTR_T, MASK_T or P-FLAG in HL.
10626  229B             ; colour value in A, mask in B.
10627  229B             
10628  229B             ;; CO-CHANGE
10629  229B AE          L226C:  XOR     (HL)            ; impress bits specified
10630  229C A0                  AND     B               ; by mask
10631  229D AE                  XOR     (HL)            ; on system variable.
10632  229E 77                  LD      (HL),A          ; update system variable.
10633  229F 23                  INC     HL              ; address next location.
10634  22A0 78                  LD      A,B             ; put current value of mask in A
10635  22A1 C9                  RET                     ; return.
10636  22A2             
10637  22A2             ; ---
10638  22A2             
10639  22A2             ; the branch was here with flash and bright
10640  22A2             
10641  22A2             ;; CO-TEMP-C
10642  22A2 9F          L2273:  SBC     A,A             ; set zero flag for bright.
10643  22A3 7A                  LD      A,D             ; fetch original parameter 0,1 or 8
10644  22A4 0F                  RRCA                    ; rotate bit 0 to bit 7
10645  22A5 06 80               LD      B,$80           ; mask for flash 10000000
10646  22A7 20 03               JR      NZ,L227D        ; forward to CO-TEMP-D if flash
10647  22A9             
10648  22A9 0F                  RRCA                    ; rotate bit 7 to bit 6
10649  22AA 06 40               LD      B,$40           ; mask for bright 01000000
10650  22AC             
10651  22AC             ;; CO-TEMP-D
10652  22AC 4F          L227D:  LD      C,A             ; store value in C
10653  22AD 7A                  LD      A,D             ; fetch parameter
10654  22AE FE 08               CP      $08             ; compare with 8
10655  22B0 28 04               JR      Z,L2287         ; forward to CO-TEMP-E if 8
10656  22B2             
10657  22B2 FE 02               CP      $02             ; test if 0 or 1
10658  22B4 30 BD               JR      NC,L2244        ; back to REPORT-K if not
10659  22B6                                             ; 'Invalid colour'
10660  22B6             
10661  22B6             ;; CO-TEMP-E
10662  22B6 79          L2287:  LD      A,C             ; value to A
10663  22B7 21 8F 5C            LD      HL,$5C8F        ; address ATTR_T
10664  22BA CD 9B 22            CALL    L226C           ; routine CO-CHANGE addressing ATTR_T
10665  22BD 79                  LD      A,C             ; fetch value
10666  22BE 0F                  RRCA                    ; for flash8/bright8 complete
10667  22BF 0F                  RRCA                    ; rotations to put set bit in
10668  22C0 0F                  RRCA                    ; bit 7 (flash) bit 6 (bright)
10669  22C1 18 D8               JR      L226C           ; back to CO-CHANGE addressing MASK_T
10670  22C3                                             ; and indirect return.
10671  22C3             
10672  22C3             ; ---------------------
10673  22C3             ; Handle BORDER command
10674  22C3             ; ---------------------
10675  22C3             ; Command syntax example: BORDER 7
10676  22C3             ; This command routine sets the border to one of the eight colours.
10677  22C3             ; The colours used for the lower screen are based on this.
10678  22C3             
10679  22C3             ;; BORDER
10680  22C3 CD C3 1E    L2294:  CALL    L1E94           ; routine FIND-INT1
10681  22C6 FE 08               CP      $08             ; must be in range 0 (black) to 7 (white)
10682  22C8 30 A9               JR      NC,L2244        ; back to REPORT-K if not
10683  22CA                                             ; 'Invalid colour'.
10684  22CA             
10685  22CA D3 FE               OUT     ($FE),A         ; outputting to port effects an immediate
10686  22CC                                             ; change.
10687  22CC 07                  RLCA                    ; shift the colour to
10688  22CD 07                  RLCA                    ; the paper bits setting the
10689  22CE 07                  RLCA                    ; ink colour black.
10690  22CF CB 6F               BIT     5,A             ; is the number light coloured ?
10691  22D1                                             ; i.e. in the range green to white.
10692  22D1 20 02               JR      NZ,L22A6        ; skip to BORDER-1 if so
10693  22D3             
10694  22D3 EE 07               XOR     $07             ; make the ink white.
10695  22D5             
10696  22D5             ;; BORDER-1
10697  22D5 32 48 5C    L22A6:  LD      ($5C48),A       ; update BORDCR with new paper/ink
10698  22D8 C9                  RET                     ; return.
10699  22D9             
10700  22D9             ; -----------------
10701  22D9             ; Get pixel address
10702  22D9             ; -----------------
10703  22D9             ;
10704  22D9             ;
10705  22D9             
10706  22D9             ;; PIXEL-ADD
10707  22D9 3E AF       L22AA:  LD      A,$AF           ; load with 175 decimal.
10708  22DB 90                  SUB     B               ; subtract the y value.
10709  22DC DA 28 25            JP      C,L24F9         ; jump forward to REPORT-Bc if greater.
10710  22DF                                             ; 'Integer out of range'
10711  22DF             
10712  22DF             ; the high byte is derived from Y only.
10713  22DF             ; the first 3 bits are always 010
10714  22DF             ; the next 2 bits denote in which third of the screen the byte is.
10715  22DF             ; the last 3 bits denote in which of the 8 scan lines within a third
10716  22DF             ; the byte is located. There are 24 discrete values.
10717  22DF             
10718  22DF             
10719  22DF 47                  LD      B,A             ; the line number from top of screen to B.
10720  22E0 A7                  AND     A               ; clear carry (already clear)
10721  22E1 1F                  RRA                     ;                     0xxxxxxx
10722  22E2 37                  SCF                     ; set carry flag
10723  22E3 1F                  RRA                     ;                     10xxxxxx
10724  22E4 A7                  AND     A               ; clear carry flag
10725  22E5 1F                  RRA                     ;                     010xxxxx
10726  22E6             
10727  22E6 A8                  XOR     B               ;
10728  22E7 E6 F8               AND     $F8             ; keep the top 5 bits 11111000
10729  22E9 A8                  XOR     B               ;                     010xxbbb
10730  22EA 67                  LD      H,A             ; transfer high byte to H.
10731  22EB             
10732  22EB             ; the low byte is derived from both X and Y.
10733  22EB             
10734  22EB 79                  LD      A,C             ; the x value 0-255.
10735  22EC 07                  RLCA                    ;
10736  22ED 07                  RLCA                    ;
10737  22EE 07                  RLCA                    ;
10738  22EF A8                  XOR     B               ; the y value
10739  22F0 E6 C7               AND     $C7             ; apply mask             11000111
10740  22F2 A8                  XOR     B               ; restore unmasked bits  xxyyyxxx
10741  22F3 07                  RLCA                    ; rotate to              xyyyxxxx
10742  22F4 07                  RLCA                    ; required position.     yyyxxxxx
10743  22F5 6F                  LD      L,A             ; low byte to L.
10744  22F6             
10745  22F6             ; finally form the pixel position in A.
10746  22F6             
10747  22F6 79                  LD      A,C             ; x value to A
10748  22F7 E6 07               AND     $07             ; mod 8
10749  22F9 C9                  RET                     ; return
10750  22FA             
10751  22FA             ; ----------------
10752  22FA             ; Point Subroutine
10753  22FA             ; ----------------
10754  22FA             ; The point subroutine is called from s-point via the scanning functions
10755  22FA             ; table.
10756  22FA             
10757  22FA             ;; POINT-SUB
10758  22FA CD 36 23    L22CB:  CALL    L2307           ; routine STK-TO-BC
10759  22FD CD D9 22            CALL    L22AA           ; routine PIXEL-ADD finds address of pixel.
10760  2300 47                  LD      B,A             ; pixel position to B, 0-7.
10761  2301 04                  INC     B               ; increment to give rotation count 1-8.
10762  2302 7E                  LD      A,(HL)          ; fetch byte from screen.
10763  2303             
10764  2303             ;; POINT-LP
10765  2303 07          L22D4:  RLCA                    ; rotate and loop back
10766  2304 10 FD               DJNZ    L22D4           ; to POINT-LP until pixel at right.
10767  2306             
10768  2306 E6 01               AND      $01            ; test to give zero or one.
10769  2308 C3 57 2D            JP      L2D28           ; jump forward to STACK-A to save result.
10770  230B             
10771  230B             ; -------------------
10772  230B             ; Handle PLOT command
10773  230B             ; -------------------
10774  230B             ; Command Syntax example: PLOT 128,88
10775  230B             ;
10776  230B             
10777  230B             ;; PLOT
10778  230B CD 36 23    L22DC:  CALL    L2307           ; routine STK-TO-BC
10779  230E CD 14 23            CALL    L22E5           ; routine PLOT-SUB
10780  2311 C3 7C 0D            JP      L0D4D           ; to TEMPS
10781  2314             
10782  2314             ; -------------------
10783  2314             ; The Plot subroutine
10784  2314             ; -------------------
10785  2314             ; A screen byte holds 8 pixels so it is necessary to rotate a mask
10786  2314             ; into the correct position to leave the other 7 pixels unaffected.
10787  2314             ; However all 64 pixels in the character cell take any embedded colour
10788  2314             ; items.
10789  2314             ; A pixel can be reset (inverse 1), toggled (over 1), or set ( with inverse
10790  2314             ; and over switches off). With both switches on, the byte is simply put
10791  2314             ; back on the screen though the colours may change.
10792  2314             
10793  2314             ;; PLOT-SUB
10794  2314 ED 43 7D 5C L22E5:  LD      ($5C7D),BC      ; store new x/y values in COORDS
10795  2318 CD D9 22            CALL    L22AA           ; routine PIXEL-ADD gets address in HL,
10796  231B                                             ; count from left 0-7 in B.
10797  231B 47                  LD      B,A             ; transfer count to B.
10798  231C 04                  INC     B               ; increase 1-8.
10799  231D 3E FE               LD      A,$FE           ; 11111110 in A.
10800  231F             
10801  231F             ;; PLOT-LOOP
10802  231F 0F          L22F0:  RRCA                    ; rotate mask.
10803  2320 10 FD               DJNZ    L22F0           ; to PLOT-LOOP until B circular rotations.
10804  2322             
10805  2322 47                  LD      B,A             ; load mask to B
10806  2323 7E                  LD      A,(HL)          ; fetch screen byte to A
10807  2324             
10808  2324 FD 4E 57            LD      C,(IY+$57)      ; P_FLAG to C
10809  2327 CB 41               BIT     0,C             ; is it to be OVER 1 ?
10810  2329 20 01               JR      NZ,L22FD        ; forward to PL-TST-IN if so.
10811  232B             
10812  232B             ; was over 0
10813  232B             
10814  232B A0                  AND     B               ; combine with mask to blank pixel.
10815  232C             
10816  232C             ;; PL-TST-IN
10817  232C CB 51       L22FD:  BIT     2,C             ; is it inverse 1 ?
10818  232E 20 02               JR      NZ,L2303        ; to PLOT-END if so.
10819  2330             
10820  2330 A8                  XOR     B               ; switch the pixel
10821  2331 2F                  CPL                     ; restore other 7 bits
10822  2332             
10823  2332             ;; PLOT-END
10824  2332 77          L2303:  LD      (HL),A          ; load byte to the screen.
10825  2333 C3 0A 0C            JP      L0BDB           ; exit to PO-ATTR to set colours for cell.
10826  2336             
10827  2336             ; ------------------------------
10828  2336             ; Put two numbers in BC register
10829  2336             ; ------------------------------
10830  2336             ;
10831  2336             ;
10832  2336             
10833  2336             ;; STK-TO-BC
10834  2336 CD 43 23    L2307:  CALL    L2314           ; routine STK-TO-A
10835  2339 47                  LD      B,A             ;
10836  233A C5                  PUSH    BC              ;
10837  233B CD 43 23            CALL    L2314           ; routine STK-TO-A
10838  233E 59                  LD      E,C             ;
10839  233F C1                  POP     BC              ;
10840  2340 51                  LD      D,C             ;
10841  2341 4F                  LD      C,A             ;
10842  2342 C9                  RET                     ;
10843  2343             
10844  2343             ; -----------------------
10845  2343             ; Put stack in A register
10846  2343             ; -----------------------
10847  2343             ; This routine puts the last value on the calculator stack into the accumulator
10848  2343             ; deleting the last value.
10849  2343             
10850  2343             ;; STK-TO-A
10851  2343 CD 04 2E    L2314:  CALL    L2DD5           ; routine FP-TO-A compresses last value into
10852  2346                                             ; accumulator. e.g. PI would become 3. 
10853  2346                                             ; zero flag set if positive.
10854  2346 DA 28 25            JP      C,L24F9         ; jump forward to REPORT-Bc if >= 255.5.
10855  2349             
10856  2349 0E 01               LD      C,$01           ; prepare a positive sign byte.
10857  234B C8                  RET     Z               ; return if FP-TO-BC indicated positive.
10858  234C             
10859  234C 0E FF               LD      C,$FF           ; prepare negative sign byte and
10860  234E C9                  RET                     ; return.
10861  234F             
10862  234F             
10863  234F             ; --------------------
10864  234F             ; THE 'CIRCLE' COMMAND
10865  234F             ; --------------------
10866  234F             ;   "Goe not Thou about to Square eyther circle" -
10867  234F             ;   - John Donne, Cambridge educated theologian, 1624
10868  234F             ;
10869  234F             ;   The CIRCLE command draws a circle as a series of straight lines.
10870  234F             ;   In some ways it can be regarded as a polygon, but the first line is drawn 
10871  234F             ;   as a tangent, taking the radius as its distance from the centre.
10872  234F             ;
10873  234F             ;   Both the CIRCLE algorithm and the ARC drawing algorithm make use of the
10874  234F             ;   'ROTATION FORMULA' (see later).  It is only necessary to work out where 
10875  234F             ;   the first line will be drawn and how long it is and then the rotation 
10876  234F             ;   formula takes over and calculates all other rotated points.
10877  234F             ;
10878  234F             ;   All Spectrum circles consist of two vertical lines at each side and two 
10879  234F             ;   horizontal lines at the top and bottom. The number of lines is calculated
10880  234F             ;   from the radius of the circle and is always divisible by 4. For complete 
10881  234F             ;   circles it will range from 4 for a square circle to 32 for a circle of 
10882  234F             ;   radius 87. The Spectrum can attempt larger circles e.g. CIRCLE 0,14,255
10883  234F             ;   but these will error as they go off-screen after four lines are drawn.
10884  234F             ;   At the opposite end, CIRCLE 128,88,1.23 will draw a circle as a perfect 3x3
10885  234F             ;   square using 4 straight lines although very small circles are just drawn as 
10886  234F             ;   a dot on the screen.
10887  234F             ;
10888  234F             ;   The first chord drawn is the vertical chord on the right of the circle.
10889  234F             ;   The starting point is at the base of this chord which is drawn upwards and
10890  234F             ;   the circle continues in an anti-clockwise direction. As noted earlier the 
10891  234F             ;   x-coordinate of this point measured from the centre of the circle is the 
10892  234F             ;   radius. 
10893  234F             ;
10894  234F             ;   The CIRCLE command makes extensive use of the calculator and as part of
10895  234F             ;   process of drawing a large circle, free memory is checked 1315 times.
10896  234F             ;   When drawing a large arc, free memory is checked 928 times.
10897  234F             ;   A single call to 'sin' involves 63 memory checks and so values of sine 
10898  234F             ;   and cosine are pre-calculated and held in the mem locations. As a 
10899  234F             ;   clever trick 'cos' is derived from 'sin' using simple arithmetic operations
10900  234F             ;   instead of the more expensive 'cos' function.
10901  234F             ;
10902  234F             ;   Initially, the syntax has been partly checked using the class for the DRAW 
10903  234F             ;   command which stacks the origin of the circle (X,Y).
10904  234F             
10905  234F             ;; CIRCLE
10906  234F DF          L2320:  RST     18H             ; GET-CHAR              x, y.
10907  2350 FE 2C               CP      $2C             ; Is character the required comma ?
10908  2352 C2 B9 1C            JP      NZ,L1C8A        ; Jump, if not, to REPORT-C
10909  2355                                             ; 'Nonsense in basic'
10910  2355             
10911  2355 E7                  RST     20H             ; NEXT-CHAR advances the parsed character address.
10912  2356 CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM stacks radius in runtime.
10913  2359 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END will return here in runtime
10914  235C                                             ; if nothing follows the command.
10915  235C             
10916  235C             ;   Now make the radius positive and ensure that it is in floating point form 
10917  235C             ;   so that the exponent byte can be accessed for quick testing.
10918  235C             
10919  235C EF                  RST     28H             ;; FP-CALC              x, y, r.
10920  235D 2A                  DEFB    $2A             ;;abs                   x, y, r.
10921  235E 3D                  DEFB    $3D             ;;re-stack              x, y, r.
10922  235F 38                  DEFB    $38             ;;end-calc              x, y, r.
10923  2360             
10924  2360 7E                  LD      A,(HL)          ; Fetch first, floating-point, exponent byte.
10925  2361 FE 81               CP      $81             ; Compare to one.
10926  2363 30 05               JR      NC,L233B        ; Forward to C-R-GRE-1 
10927  2365                                             ; if circle radius is greater than one.
10928  2365             
10929  2365             ;    The circle is no larger than a single pixel so delete the radius from the
10930  2365             ;    calculator stack and plot a point at the centre.
10931  2365             
10932  2365 EF                  RST     28H             ;; FP-CALC              x, y, r.
10933  2366 02                  DEFB    $02             ;;delete                x, y.                  
10934  2367 38                  DEFB    $38             ;;end-calc              x, y.
10935  2368             
10936  2368 18 A1               JR      L22DC           ; back to PLOT routine to just plot x,y.
10937  236A             
10938  236A             ; ---
10939  236A             
10940  236A             ;   Continue when the circle's radius measures greater than one by forming 
10941  236A             ;   the angle 2 * PI radians which is 360 degrees.
10942  236A             
10943  236A             ;; C-R-GRE-1
10944  236A EF          L233B:  RST     28H             ;; FP-CALC      x, y, r
10945  236B A3                  DEFB    $A3             ;;stk-pi/2      x, y, r, pi/2.
10946  236C 38                  DEFB    $38             ;;end-calc      x, y, r, pi/2.
10947  236D             
10948  236D             ;   Change the exponent of pi/2 from $81 to $83 giving 2*PI the central angle.
10949  236D             ;   This is quicker than multiplying by four.
10950  236D             
10951  236D 36 83               LD      (HL),$83        ;               x, y, r, 2*PI.
10952  236F             
10953  236F             ;   Now store this important constant in mem-5 and delete so that other 
10954  236F             ;   parameters can be derived from it, by a routine shared with DRAW.
10955  236F             
10956  236F EF                  RST     28H             ;; FP-CALC      x, y, r, 2*PI.
10957  2370 C5                  DEFB    $C5             ;;st-mem-5      store 2*PI in mem-5
10958  2371 02                  DEFB    $02             ;;delete        x, y, r.
10959  2372 38                  DEFB    $38             ;;end-calc      x, y, r.
10960  2373             
10961  2373             ;   The parameters derived from mem-5 (A) and from the radius are set up in 
10962  2373             ;   four of the other mem locations by the CIRCLE DRAW PARAMETERS routine which 
10963  2373             ;   also returns the number of straight lines in the B register.
10964  2373             
10965  2373 CD AC 24            CALL    L247D           ; routine CD-PRMS1
10966  2376             
10967  2376                                             ; mem-0 ; A/No of lines (=a)            unused  
10968  2376                                             ; mem-1 ; sin(a/2)  will be moving x    var
10969  2376                                             ; mem-2 ; -         will be moving y    var
10970  2376                                             ; mem-3 ; cos(a)                        const
10971  2376                                             ; mem-4 ; sin(a)                        const
10972  2376                                             ; mem-5 ; Angle of rotation (A) (2*PI)  const
10973  2376                                             ; B     ; Number of straight lines.
10974  2376             
10975  2376 C5                  PUSH    BC              ; Preserve the number of lines in B.
10976  2377             
10977  2377             ;   Next calculate the length of half a chord by multiplying the sine of half 
10978  2377             ;   the central angle by the radius of the circle.
10979  2377             
10980  2377 EF                  RST     28H             ;; FP-CALC      x, y, r.
10981  2378 31                  DEFB    $31             ;;duplicate     x, y, r, r.
10982  2379 E1                  DEFB    $E1             ;;get-mem-1     x, y, r, r, sin(a/2).
10983  237A 04                  DEFB    $04             ;;multiply      x, y, r, half-chord.
10984  237B 38                  DEFB    $38             ;;end-calc      x, y, r, half-chord.
10985  237C             
10986  237C 7E                  LD      A,(HL)          ; fetch exponent  of the half arc to A.
10987  237D FE 80               CP      $80             ; compare to a half pixel
10988  237F 30 08               JR      NC,L235A        ; forward, if greater than .5, to C-ARC-GE1
10989  2381             
10990  2381             ;   If the first line is less than .5 then 4 'lines' would be drawn on the same 
10991  2381             ;   spot so tidy the calculator stack and machine stack and plot the centre.
10992  2381             
10993  2381 EF                  RST     28H             ;; FP-CALC      x, y, r, hc.
10994  2382 02                  DEFB    $02             ;;delete        x, y, r.
10995  2383 02                  DEFB    $02             ;;delete        x, y.
10996  2384 38                  DEFB    $38             ;;end-calc      x, y.
10997  2385             
10998  2385 C1                  POP     BC              ; Balance machine stack by taking chord-count.
10999  2386             
11000  2386 C3 0B 23            JP      L22DC           ; JUMP to PLOT
11001  2389             
11002  2389             ; ---
11003  2389             
11004  2389             ;   The arc is greater than 0.5 so the circle can be drawn.
11005  2389             
11006  2389             ;; C-ARC-GE1
11007  2389 EF          L235A:  RST     28H             ;; FP-CALC      x, y, r, hc.
11008  238A C2                  DEFB    $C2             ;;st-mem-2      x, y, r, half chord to mem-2.
11009  238B 01                  DEFB    $01             ;;exchange      x, y, hc, r.
11010  238C C0                  DEFB    $C0             ;;st-mem-0      x, y, hc, r.
11011  238D 02                  DEFB    $02             ;;delete        x, y, hc.
11012  238E             
11013  238E             ;   Subtract the length of the half-chord from the absolute y coordinate to
11014  238E             ;   give the starting y coordinate sy. 
11015  238E             ;   Note that for a circle this is also the end coordinate.
11016  238E             
11017  238E 03                  DEFB    $03             ;;subtract      x, y-hc.  (The start y-coord)
11018  238F 01                  DEFB    $01             ;;exchange      sy, x.
11019  2390             
11020  2390             ;   Next simply add the radius to the x coordinate to give a fuzzy x-coordinate.
11021  2390             ;   Strictly speaking, the radius should be multiplied by cos(a/2) first but
11022  2390             ;   doing it this way makes the circle slightly larger.
11023  2390             
11024  2390 E0                  DEFB    $E0             ;;get-mem-0     sy, x, r.
11025  2391 0F                  DEFB    $0F             ;;addition      sy, x+r.  (The start x-coord)
11026  2392             
11027  2392             ;   We now want three copies of this pair of values on the calculator stack.
11028  2392             ;   The first pair remain on the stack throughout the circle routine and are 
11029  2392             ;   the end points. The next pair will be the moving absolute values of x and y
11030  2392             ;   that are updated after each line is drawn. The final pair will be loaded 
11031  2392             ;   into the COORDS system variable so that the first vertical line starts at 
11032  2392             ;   the right place.
11033  2392             
11034  2392 C0                  DEFB    $C0             ;;st-mem-0      sy, sx.
11035  2393 01                  DEFB    $01             ;;exchange      sx, sy.
11036  2394 31                  DEFB    $31             ;;duplicate     sx, sy, sy.
11037  2395 E0                  DEFB    $E0             ;;get-mem-0     sx, sy, sy, sx.
11038  2396 01                  DEFB    $01             ;;exchange      sx, sy, sx, sy.
11039  2397 31                  DEFB    $31             ;;duplicate     sx, sy, sx, sy, sy.
11040  2398 E0                  DEFB    $E0             ;;get-mem-0     sx, sy, sx, sy, sy, sx.
11041  2399             
11042  2399             ;   Locations mem-1 and mem-2 are the relative x and y values which are updated
11043  2399             ;   after each line is drawn. Since we are drawing a vertical line then the rx
11044  2399             ;   value in mem-1 is zero and the ry value in mem-2 is the full chord.
11045  2399             
11046  2399 A0                  DEFB    $A0             ;;stk-zero      sx, sy, sx, sy, sy, sx, 0.
11047  239A C1                  DEFB    $C1             ;;st-mem-1      sx, sy, sx, sy, sy, sx, 0.
11048  239B 02                  DEFB    $02             ;;delete        sx, sy, sx, sy, sy, sx.
11049  239C             
11050  239C             ;   Although the three pairs of x/y values are the same for a circle, they 
11051  239C             ;   will be labelled terminating, absolute and start coordinates.
11052  239C             
11053  239C 38                  DEFB    $38             ;;end-calc      tx, ty, ax, ay, sy, sx.
11054  239D             
11055  239D             ;   Use the exponent manipulating trick again to double the value of mem-2.
11056  239D             
11057  239D FD 34 62            INC     (IY+$62)        ; Increment MEM-2-1st doubling half chord.
11058  23A0             
11059  23A0             ;   Note. this first vertical chord is drawn at the radius so circles are
11060  23A0             ;   slightly displaced to the right.
11061  23A0             ;   It is only necessary to place the values (sx) and (sy) in the system 
11062  23A0             ;   variable COORDS to ensure that drawing commences at the correct pixel.
11063  23A0             ;   Note. a couple of LD (COORDS),A instructions would have been quicker, and 
11064  23A0             ;   simpler, than using LD (COORDS),HL.
11065  23A0             
11066  23A0 CD C3 1E            CALL    L1E94           ; routine FIND-INT1 fetches sx from stack to A.
11067  23A3             
11068  23A3 6F                  LD      L,A             ; place X value in L.
11069  23A4 E5                  PUSH    HL              ; save the holding register.
11070  23A5             
11071  23A5 CD C3 1E            CALL    L1E94           ; routine FIND-INT1 fetches sy to A
11072  23A8             
11073  23A8 E1                  POP     HL              ; restore the holding register.
11074  23A9 67                  LD      H,A             ; and place y value in high byte.
11075  23AA             
11076  23AA 22 7D 5C            LD      ($5C7D),HL      ; Update the COORDS system variable.
11077  23AD                                             ;
11078  23AD                                             ;               tx, ty, ax, ay.
11079  23AD             
11080  23AD C1                  POP     BC              ; restore the chord count  
11081  23AE                                             ; values 4,8,12,16,20,24,28 or 32.
11082  23AE             
11083  23AE C3 4F 24            JP      L2420           ; forward to DRW-STEPS
11084  23B1                                             ;               tx, ty, ax, ay.
11085  23B1             
11086  23B1             ;   Note. the jump to DRW-STEPS is just to decrement B and jump into the 
11087  23B1             ;   middle of the arc-drawing loop. The arc count which includes the first 
11088  23B1             ;   vertical arc draws one less than the perceived number of arcs. 
11089  23B1             ;   The final arc offsets are obtained by subtracting the final COORDS value
11090  23B1             ;   from the initial sx and sy values which are kept at the base of the
11091  23B1             ;   calculator stack throughout the arc loop. 
11092  23B1             ;   This ensures that the final line finishes exactly at the starting pixel 
11093  23B1             ;   removing the possibility of any inaccuracy.
11094  23B1             ;   Since the initial sx and sy values are not required until the final arc
11095  23B1             ;   is drawn, they are not shown until then.
11096  23B1             ;   As the calculator stack is quite busy, only the active parts are shown in 
11097  23B1             ;   each section.
11098  23B1             
11099  23B1             
11100  23B1             ; ------------------
11101  23B1             ; THE 'DRAW' COMMAND
11102  23B1             ; ------------------
11103  23B1             ;   The Spectrum's DRAW command is overloaded and can take two parameters sets.
11104  23B1             ;
11105  23B1             ;   With two parameters, it simply draws an approximation to a straight line
11106  23B1             ;   at offset x,y using the LINE-DRAW routine.
11107  23B1             ;
11108  23B1             ;   With three parameters, an arc is drawn to the point at offset x,y turning 
11109  23B1             ;   through an angle, in radians, supplied by the third parameter.
11110  23B1             ;   The arc will consist of 4 to 252 straight lines each one of which is drawn 
11111  23B1             ;   by calls to the DRAW-LINE routine.
11112  23B1             
11113  23B1             ;; DRAW
11114  23B1 DF          L2382:  RST     18H             ; GET-CHAR
11115  23B2 FE 2C               CP      $2C             ; is it the comma character ?
11116  23B4 28 06               JR      Z,L238D         ; forward, if so, to DR-3-PRMS
11117  23B6             
11118  23B6             ;   There are two parameters e.g. DRAW 255,175
11119  23B6             
11120  23B6 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END
11121  23B9             
11122  23B9 C3 A6 24            JP      L2477           ; jump forward to LINE-DRAW
11123  23BC             
11124  23BC             ; ---
11125  23BC             
11126  23BC             ;    There are three parameters e.g. DRAW 255, 175, .5
11127  23BC             ;    The first two are relative coordinates and the third is the angle of 
11128  23BC             ;    rotation in radians (A).
11129  23BC             
11130  23BC             ;; DR-3-PRMS
11131  23BC E7          L238D:  RST     20H             ; NEXT-CHAR skips over the 'comma'.
11132  23BD             
11133  23BD CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM stacks the rotation angle.
11134  23C0             
11135  23C0 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END
11136  23C3             
11137  23C3             ;   Now enter the calculator and store the complete rotation angle in mem-5 
11138  23C3             
11139  23C3 EF                  RST     28H             ;; FP-CALC      x, y, A.
11140  23C4 C5                  DEFB    $C5             ;;st-mem-5      x, y, A.
11141  23C5             
11142  23C5             ;   Test the angle for the special case of 360 degrees.
11143  23C5             
11144  23C5 A2                  DEFB    $A2             ;;stk-half      x, y, A, 1/2.
11145  23C6 04                  DEFB    $04             ;;multiply      x, y, A/2.
11146  23C7 1F                  DEFB    $1F             ;;sin           x, y, sin(A/2).
11147  23C8 31                  DEFB    $31             ;;duplicate     x, y, sin(A/2),sin(A/2)
11148  23C9 30                  DEFB    $30             ;;not           x, y, sin(A/2), (0/1).
11149  23CA 30                  DEFB    $30             ;;not           x, y, sin(A/2), (1/0).
11150  23CB 00                  DEFB    $00             ;;jump-true     x, y, sin(A/2).
11151  23CC             
11152  23CC 06                  DEFB    $06             ;;forward to L23A3, DR-SIN-NZ
11153  23CD                                             ; if sin(r/2) is not zero.
11154  23CD             
11155  23CD             ;   The third parameter is 2*PI (or a multiple of 2*PI) so a 360 degrees turn
11156  23CD             ;   would just be a straight line.  Eliminating this case here prevents 
11157  23CD             ;   division by zero at later stage.
11158  23CD             
11159  23CD 02                  DEFB    $02             ;;delete        x, y.
11160  23CE 38                  DEFB    $38             ;;end-calc      x, y.
11161  23CF             
11162  23CF C3 A6 24            JP      L2477           ; forward to LINE-DRAW
11163  23D2             
11164  23D2             ; ---
11165  23D2             
11166  23D2             ;   An arc can be drawn.
11167  23D2             
11168  23D2             ;; DR-SIN-NZ
11169  23D2 C0          L23A3:  DEFB    $C0             ;;st-mem-0      x, y, sin(A/2).   store mem-0
11170  23D3 02                  DEFB    $02             ;;delete        x, y.
11171  23D4             
11172  23D4             ;   The next step calculates (roughly) the diameter of the circle of which the 
11173  23D4             ;   arc will form part.  This value does not have to be too accurate as it is
11174  23D4             ;   only used to evaluate the number of straight lines and then discarded.
11175  23D4             ;   After all for a circle, the radius is used. Consequently, a circle of 
11176  23D4             ;   radius 50 will have 24 straight lines but an arc of radius 50 will have 20
11177  23D4             ;   straight lines - when drawn in any direction.
11178  23D4             ;   So that simple arithmetic can be used, the length of the chord can be 
11179  23D4             ;   calculated as X+Y rather than by Pythagoras Theorem and the sine of the
11180  23D4             ;   nearest angle within reach is used.
11181  23D4             
11182  23D4 C1                  DEFB    $C1             ;;st-mem-1      x, y.             store mem-1
11183  23D5 02                  DEFB    $02             ;;delete        x.
11184  23D6             
11185  23D6 31                  DEFB    $31             ;;duplicate     x, x.
11186  23D7 2A                  DEFB    $2A             ;;abs           x, x (+ve).
11187  23D8 E1                  DEFB    $E1             ;;get-mem-1     x, X, y.
11188  23D9 01                  DEFB    $01             ;;exchange      x, y, X.
11189  23DA E1                  DEFB    $E1             ;;get-mem-1     x, y, X, y.
11190  23DB 2A                  DEFB    $2A             ;;abs           x, y, X, Y (+ve).
11191  23DC 0F                  DEFB    $0F             ;;addition      x, y, X+Y.
11192  23DD E0                  DEFB    $E0             ;;get-mem-0     x, y, X+Y, sin(A/2).
11193  23DE 05                  DEFB    $05             ;;division      x, y, X+Y/sin(A/2).
11194  23DF 2A                  DEFB    $2A             ;;abs           x, y, X+Y/sin(A/2) = D.
11195  23E0             
11196  23E0             ;    Bring back sin(A/2) from mem-0 which will shortly get trashed.
11197  23E0             ;    Then bring D to the top of the stack again.
11198  23E0             
11199  23E0 E0                  DEFB    $E0             ;;get-mem-0     x, y, D, sin(A/2).
11200  23E1 01                  DEFB    $01             ;;exchange      x, y, sin(A/2), D.
11201  23E2             
11202  23E2             ;   Note. that since the value at the top of the stack has arisen as a result
11203  23E2             ;   of division then it can no longer be in integer form and the next re-stack
11204  23E2             ;   is unnecessary. Only the Sinclair ZX80 had integer division.
11205  23E2             
11206  23E2 3D                  DEFB    $3D             ;;re-stack      (unnecessary)
11207  23E3             
11208  23E3 38                  DEFB    $38             ;;end-calc      x, y, sin(A/2), D.
11209  23E4             
11210  23E4             ;   The next test avoids drawing 4 straight lines when the start and end pixels
11211  23E4             ;   are adjacent (or the same) but is probably best dispensed with.
11212  23E4             
11213  23E4 7E                  LD      A,(HL)          ; fetch exponent byte of D.
11214  23E5 FE 81               CP      $81             ; compare to 1
11215  23E7 30 07               JR      NC,L23C1        ; forward, if > 1,  to DR-PRMS
11216  23E9             
11217  23E9             ;   else delete the top two stack values and draw a simple straight line.
11218  23E9             
11219  23E9 EF                  RST     28H             ;; FP-CALC
11220  23EA 02                  DEFB    $02             ;;delete
11221  23EB 02                  DEFB    $02             ;;delete
11222  23EC 38                  DEFB    $38             ;;end-calc      x, y.
11223  23ED             
11224  23ED C3 A6 24            JP      L2477           ; to LINE-DRAW
11225  23F0             
11226  23F0             ; ---
11227  23F0             
11228  23F0             ;   The ARC will consist of multiple straight lines so call the CIRCLE-DRAW
11229  23F0             ;   PARAMETERS ROUTINE to pre-calculate sine values from the angle (in mem-5)
11230  23F0             ;   and determine also the number of straight lines from that value and the
11231  23F0             ;   'diameter' which is at the top of the calculator stack.
11232  23F0             
11233  23F0             ;; DR-PRMS
11234  23F0 CD AC 24    L23C1:  CALL    L247D           ; routine CD-PRMS1
11235  23F3             
11236  23F3                                             ; mem-0 ; (A)/No. of lines (=a) (step angle)
11237  23F3                                             ; mem-1 ; sin(a/2) 
11238  23F3                                             ; mem-2 ; -
11239  23F3                                             ; mem-3 ; cos(a)                        const
11240  23F3                                             ; mem-4 ; sin(a)                        const
11241  23F3                                             ; mem-5 ; Angle of rotation (A)         in
11242  23F3                                             ; B     ; Count of straight lines - max 252.
11243  23F3             
11244  23F3 C5                  PUSH    BC              ; Save the line count on the machine stack.
11245  23F4             
11246  23F4             ;   Remove the now redundant diameter value D.
11247  23F4             
11248  23F4 EF                  RST     28H             ;; FP-CALC      x, y, sin(A/2), D.
11249  23F5 02                  DEFB    $02             ;;delete        x, y, sin(A/2).
11250  23F6             
11251  23F6             ;   Dividing the sine of the step angle by the sine of the total angle gives
11252  23F6             ;   the length of the initial chord on a unary circle. This factor f is used
11253  23F6             ;   to scale the coordinates of the first line which still points in the 
11254  23F6             ;   direction of the end point and may be larger.
11255  23F6             
11256  23F6 E1                  DEFB    $E1             ;;get-mem-1     x, y, sin(A/2), sin(a/2)
11257  23F7 01                  DEFB    $01             ;;exchange      x, y, sin(a/2), sin(A/2)
11258  23F8 05                  DEFB    $05             ;;division      x, y, sin(a/2)/sin(A/2)
11259  23F9 C1                  DEFB    $C1             ;;st-mem-1      x, y. f.
11260  23FA 02                  DEFB    $02             ;;delete        x, y.
11261  23FB             
11262  23FB             ;   With the factor stored, scale the x coordinate first.
11263  23FB             
11264  23FB 01                  DEFB    $01             ;;exchange      y, x.
11265  23FC 31                  DEFB    $31             ;;duplicate     y, x, x.
11266  23FD E1                  DEFB    $E1             ;;get-mem-1     y, x, x, f.
11267  23FE 04                  DEFB    $04             ;;multiply      y, x, x*f    (=xx)
11268  23FF C2                  DEFB    $C2             ;;st-mem-2      y, x, xx.
11269  2400 02                  DEFB    $02             ;;delete        y. x.
11270  2401             
11271  2401             ;   Now scale the y coordinate.
11272  2401             
11273  2401 01                  DEFB    $01             ;;exchange      x, y.
11274  2402 31                  DEFB    $31             ;;duplicate     x, y, y.
11275  2403 E1                  DEFB    $E1             ;;get-mem-1     x, y, y, f
11276  2404 04                  DEFB    $04             ;;multiply      x, y, y*f    (=yy)
11277  2405             
11278  2405             ;   Note. 'sin' and 'cos' trash locations mem-0 to mem-2 so fetch mem-2 to the 
11279  2405             ;   calculator stack for safe keeping.
11280  2405             
11281  2405 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy, xx.
11282  2406             
11283  2406             ;   Once we get the coordinates of the first straight line then the 'ROTATION
11284  2406             ;   FORMULA' used in the arc loop will take care of all other points, but we
11285  2406             ;   now use a variation of that formula to rotate the first arc through (A-a)/2
11286  2406             ;   radians. 
11287  2406             ;   
11288  2406             ;       xRotated = y * sin(angle) + x * cos(angle)
11289  2406             ;       yRotated = y * cos(angle) - x * sin(angle)
11290  2406             ;
11291  2406              
11292  2406 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy, xx, A.
11293  2407 E0                  DEFB    $E0             ;;get-mem-0     x, y, yy, xx, A, a.
11294  2408 03                  DEFB    $03             ;;subtract      x, y, yy, xx, A-a.
11295  2409 A2                  DEFB    $A2             ;;stk-half      x, y, yy, xx, A-a, 1/2.
11296  240A 04                  DEFB    $04             ;;multiply      x, y, yy, xx, (A-a)/2. (=angle)
11297  240B 31                  DEFB    $31             ;;duplicate     x, y, yy, xx, angle, angle.
11298  240C 1F                  DEFB    $1F             ;;sin           x, y, yy, xx, angle, sin(angle)
11299  240D C5                  DEFB    $C5             ;;st-mem-5      x, y, yy, xx, angle, sin(angle)
11300  240E 02                  DEFB    $02             ;;delete        x, y, yy, xx, angle
11301  240F             
11302  240F 20                  DEFB    $20             ;;cos           x, y, yy, xx, cos(angle).
11303  2410             
11304  2410             ;   Note. mem-0, mem-1 and mem-2 can be used again now...
11305  2410             
11306  2410 C0                  DEFB    $C0             ;;st-mem-0      x, y, yy, xx, cos(angle).
11307  2411 02                  DEFB    $02             ;;delete        x, y, yy, xx.
11308  2412             
11309  2412 C2                  DEFB    $C2             ;;st-mem-2      x, y, yy, xx.
11310  2413 02                  DEFB    $02             ;;delete        x, y, yy.
11311  2414             
11312  2414 C1                  DEFB    $C1             ;;st-mem-1      x, y, yy.
11313  2415 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy, sin(angle)
11314  2416 04                  DEFB    $04             ;;multiply      x, y, yy*sin(angle).
11315  2417 E0                  DEFB    $E0             ;;get-mem-0     x, y, yy*sin(angle), cos(angle)
11316  2418 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy*sin(angle), cos(angle), xx.
11317  2419 04                  DEFB    $04             ;;multiply      x, y, yy*sin(angle), xx*cos(angle).
11318  241A 0F                  DEFB    $0F             ;;addition      x, y, xRotated.
11319  241B E1                  DEFB    $E1             ;;get-mem-1     x, y, xRotated, yy.
11320  241C 01                  DEFB    $01             ;;exchange      x, y, yy, xRotated.
11321  241D C1                  DEFB    $C1             ;;st-mem-1      x, y, yy, xRotated.
11322  241E 02                  DEFB    $02             ;;delete        x, y, yy.
11323  241F             
11324  241F E0                  DEFB    $E0             ;;get-mem-0     x, y, yy, cos(angle).
11325  2420 04                  DEFB    $04             ;;multiply      x, y, yy*cos(angle).
11326  2421 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy*cos(angle), xx.
11327  2422 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy*cos(angle), xx, sin(angle).
11328  2423 04                  DEFB    $04             ;;multiply      x, y, yy*cos(angle), xx*sin(angle).
11329  2424 03                  DEFB    $03             ;;subtract      x, y, yRotated.
11330  2425 C2                  DEFB    $C2             ;;st-mem-2      x, y, yRotated.
11331  2426             
11332  2426             ;   Now the initial x and y coordinates are made positive and summed to see 
11333  2426             ;   if they measure up to anything significant.
11334  2426             
11335  2426 2A                  DEFB    $2A             ;;abs           x, y, yRotated'.
11336  2427 E1                  DEFB    $E1             ;;get-mem-1     x, y, yRotated', xRotated.
11337  2428 2A                  DEFB    $2A             ;;abs           x, y, yRotated', xRotated'.
11338  2429 0F                  DEFB    $0F             ;;addition      x, y, yRotated+xRotated.
11339  242A 02                  DEFB    $02             ;;delete        x, y. 
11340  242B             
11341  242B 38                  DEFB    $38             ;;end-calc      x, y. 
11342  242C             
11343  242C             ;   Although the test value has been deleted it is still above the calculator
11344  242C             ;   stack in memory and conveniently DE which points to the first free byte
11345  242C             ;   addresses the exponent of the test value.
11346  242C             
11347  242C 1A                  LD      A,(DE)          ; Fetch exponent of the length indicator.
11348  242D FE 81               CP      $81             ; Compare to that for 1
11349  242F             
11350  242F C1                  POP     BC              ; Balance the machine stack
11351  2430             
11352  2430 DA A6 24            JP      C,L2477         ; forward, if the coordinates of first line
11353  2433                                             ; don't add up to more than 1, to LINE-DRAW 
11354  2433             
11355  2433             ;   Continue when the arc will have a discernable shape.
11356  2433             
11357  2433 C5                  PUSH    BC              ; Restore line counter to the machine stack.
11358  2434             
11359  2434             ;   The parameters of the DRAW command were relative and they are now converted 
11360  2434             ;   to absolute coordinates by adding to the coordinates of the last point 
11361  2434             ;   plotted. The first two values on the stack are the terminal tx and ty 
11362  2434             ;   coordinates.  The x-coordinate is converted first but first the last point 
11363  2434             ;   plotted is saved as it will initialize the moving ax, value. 
11364  2434             
11365  2434 EF                  RST     28H             ;; FP-CALC      x, y.
11366  2435 01                  DEFB    $01             ;;exchange      y, x.
11367  2436 38                  DEFB    $38             ;;end-calc      y, x.
11368  2437             
11369  2437 3A 7D 5C            LD      A,($5C7D)       ; Fetch System Variable COORDS-x
11370  243A CD 57 2D            CALL    L2D28           ; routine STACK-A
11371  243D             
11372  243D EF                  RST     28H             ;; FP-CALC      y, x, last-x.
11373  243E             
11374  243E             ;   Store the last point plotted to initialize the moving ax value.
11375  243E             
11376  243E C0                  DEFB    $C0             ;;st-mem-0      y, x, last-x.
11377  243F 0F                  DEFB    $0F             ;;addition      y, absolute x.
11378  2440 01                  DEFB    $01             ;;exchange      tx, y.
11379  2441 38                  DEFB    $38             ;;end-calc      tx, y.
11380  2442             
11381  2442 3A 7E 5C            LD      A,($5C7E)       ; Fetch System Variable COORDS-y
11382  2445 CD 57 2D            CALL    L2D28           ; routine STACK-A
11383  2448             
11384  2448 EF                  RST     28H             ;; FP-CALC      tx, y, last-y.
11385  2449             
11386  2449             ;   Store the last point plotted to initialize the moving ay value.
11387  2449             
11388  2449 C5                  DEFB    $C5             ;;st-mem-5      tx, y, last-y.
11389  244A 0F                  DEFB    $0F             ;;addition      tx, ty.
11390  244B             
11391  244B             ;   Fetch the moving ax and ay to the calculator stack.
11392  244B             
11393  244B E0                  DEFB    $E0             ;;get-mem-0     tx, ty, ax.
11394  244C E5                  DEFB    $E5             ;;get-mem-5     tx, ty, ax, ay.
11395  244D 38                  DEFB    $38             ;;end-calc      tx, ty, ax, ay.
11396  244E             
11397  244E C1                  POP     BC              ; Restore the straight line count.
11398  244F             
11399  244F             ; -----------------------------------
11400  244F             ; THE 'CIRCLE/DRAW CONVERGENCE POINT'
11401  244F             ; -----------------------------------
11402  244F             ;   The CIRCLE and ARC-DRAW commands converge here. 
11403  244F             ;
11404  244F             ;   Note. for both the CIRCLE and ARC commands the minimum initial line count 
11405  244F             ;   is 4 (as set up by the CD_PARAMS routine) and so the zero flag will never 
11406  244F             ;   be set and the loop is always entered.  The first test is superfluous and
11407  244F             ;   the jump will always be made to ARC-START.
11408  244F             
11409  244F             ;; DRW-STEPS
11410  244F 05          L2420:  DEC     B               ; decrement the arc count (4,8,12,16...).            
11411  2450             
11412  2450 28 3C               JR      Z,L245F         ; forward, if zero (not possible), to ARC-END
11413  2452             
11414  2452 18 14               JR      L2439           ; forward to ARC-START
11415  2454             
11416  2454             ; --------------
11417  2454             ; THE 'ARC LOOP'
11418  2454             ; --------------
11419  2454             ;
11420  2454             ;   The arc drawing loop will draw up to 31 straight lines for a circle and up 
11421  2454             ;   251 straight lines for an arc between two points. In both cases the final
11422  2454             ;   closing straight line is drawn at ARC_END, but it otherwise loops back to 
11423  2454             ;   here to calculate the next coordinate using the ROTATION FORMULA where (a)
11424  2454             ;   is the previously calculated, constant CENTRAL ANGLE of the arcs.
11425  2454             ;
11426  2454             ;       Xrotated = x * cos(a) - y * sin(a)
11427  2454             ;       Yrotated = x * sin(a) + y * cos(a)
11428  2454             ;
11429  2454             ;   The values cos(a) and sin(a) are pre-calculated and held in mem-3 and mem-4 
11430  2454             ;   for the duration of the routine.
11431  2454             ;   Memory location mem-1 holds the last relative x value (rx) and mem-2 holds
11432  2454             ;   the last relative y value (ry) used by DRAW.
11433  2454             ;
11434  2454             ;   Note. that this is a very clever twist on what is after all a very clever,
11435  2454             ;   well-used formula.  Normally the rotation formula is used with the x and y
11436  2454             ;   coordinates from the centre of the circle (or arc) and a supplied angle to 
11437  2454             ;   produce two new x and y coordinates in an anticlockwise direction on the 
11438  2454             ;   circumference of the circle.
11439  2454             ;   What is being used here, instead, is the relative X and Y parameters from
11440  2454             ;   the last point plotted that are required to get to the current point and 
11441  2454             ;   the formula returns the next relative coordinates to use. 
11442  2454             
11443  2454             ;; ARC-LOOP
11444  2454 EF          L2425:  RST     28H             ;; FP-CALC      
11445  2455 E1                  DEFB    $E1             ;;get-mem-1     rx.
11446  2456 31                  DEFB    $31             ;;duplicate     rx, rx.
11447  2457 E3                  DEFB    $E3             ;;get-mem-3     cos(a)
11448  2458 04                  DEFB    $04             ;;multiply      rx, rx*cos(a).
11449  2459 E2                  DEFB    $E2             ;;get-mem-2     rx, rx*cos(a), ry.
11450  245A E4                  DEFB    $E4             ;;get-mem-4     rx, rx*cos(a), ry, sin(a). 
11451  245B 04                  DEFB    $04             ;;multiply      rx, rx*cos(a), ry*sin(a).
11452  245C 03                  DEFB    $03             ;;subtract      rx, rx*cos(a) - ry*sin(a)
11453  245D C1                  DEFB    $C1             ;;st-mem-1      rx, new relative x rotated.
11454  245E 02                  DEFB    $02             ;;delete        rx.
11455  245F             
11456  245F E4                  DEFB    $E4             ;;get-mem-4     rx, sin(a).
11457  2460 04                  DEFB    $04             ;;multiply      rx*sin(a)
11458  2461 E2                  DEFB    $E2             ;;get-mem-2     rx*sin(a), ry.
11459  2462 E3                  DEFB    $E3             ;;get-mem-3     rx*sin(a), ry, cos(a).
11460  2463 04                  DEFB    $04             ;;multiply      rx*sin(a), ry*cos(a).
11461  2464 0F                  DEFB    $0F             ;;addition      rx*sin(a) + ry*cos(a).
11462  2465 C2                  DEFB    $C2             ;;st-mem-2      new relative y rotated.
11463  2466 02                  DEFB    $02             ;;delete        .
11464  2467 38                  DEFB    $38             ;;end-calc      .  
11465  2468             
11466  2468             ;   Note. the calculator stack actually holds   tx, ty, ax, ay
11467  2468             ;   and the last absolute values of x and y 
11468  2468             ;   are now brought into play.
11469  2468             ;
11470  2468             ;   Magically, the two new rotated coordinates rx and ry are all that we would
11471  2468             ;   require to draw a circle or arc - on paper!
11472  2468             ;   The Spectrum DRAW routine draws to the rounded x and y coordinate and so 
11473  2468             ;   repetitions of values like 3.49 would mean that the fractional parts 
11474  2468             ;   would be lost until eventually the draw coordinates might differ from the 
11475  2468             ;   floating point values used above by several pixels.
11476  2468             ;   For this reason the accurate offsets calculated above are added to the 
11477  2468             ;   accurate, absolute coordinates maintained in ax and ay and these new 
11478  2468             ;   coordinates have the integer coordinates of the last plot position 
11479  2468             ;   ( from System Variable COORDS ) subtracted from them to give the relative 
11480  2468             ;   coordinates required by the DRAW routine.
11481  2468             
11482  2468             ;   The mid entry point.
11483  2468             
11484  2468             ;; ARC-START
11485  2468 C5          L2439:  PUSH    BC              ; Preserve the arc counter on the machine stack.
11486  2469             
11487  2469             ;   Store the absolute ay in temporary variable mem-0 for the moment.
11488  2469             
11489  2469 EF                  RST     28H             ;; FP-CALC      ax, ay.
11490  246A C0                  DEFB    $C0             ;;st-mem-0      ax, ay.
11491  246B 02                  DEFB    $02             ;;delete        ax.
11492  246C             
11493  246C             ;   Now add the fractional relative x coordinate to the fractional absolute
11494  246C             ;   x coordinate to obtain a new fractional x-coordinate.
11495  246C             
11496  246C E1                  DEFB    $E1             ;;get-mem-1     ax, xr.
11497  246D 0F                  DEFB    $0F             ;;addition      ax+xr (= new ax).  
11498  246E 31                  DEFB    $31             ;;duplicate     ax, ax.
11499  246F 38                  DEFB    $38             ;;end-calc      ax, ax. 
11500  2470             
11501  2470 3A 7D 5C            LD      A,($5C7D)       ; COORDS-x      last x    (integer ix 0-255)
11502  2473 CD 57 2D            CALL    L2D28           ; routine STACK-A
11503  2476             
11504  2476 EF                  RST     28H             ;; FP-CALC      ax, ax, ix.
11505  2477 03                  DEFB    $03             ;;subtract      ax, ax-ix  = relative DRAW Dx.
11506  2478             
11507  2478             ;   Having calculated the x value for DRAW do the same for the y value.
11508  2478             
11509  2478 E0                  DEFB    $E0             ;;get-mem-0     ax, Dx, ay.
11510  2479 E2                  DEFB    $E2             ;;get-mem-2     ax, Dx, ay, ry.
11511  247A 0F                  DEFB    $0F             ;;addition      ax, Dx, ay+ry (= new ay).
11512  247B C0                  DEFB    $C0             ;;st-mem-0      ax, Dx, ay.
11513  247C 01                  DEFB    $01             ;;exchange      ax, ay, Dx,
11514  247D E0                  DEFB    $E0             ;;get-mem-0     ax, ay, Dx, ay.
11515  247E 38                  DEFB    $38             ;;end-calc      ax, ay, Dx, ay.
11516  247F             
11517  247F 3A 7E 5C            LD      A,($5C7E)       ; COORDS-y      last y (integer iy 0-175)
11518  2482 CD 57 2D            CALL    L2D28           ; routine STACK-A
11519  2485             
11520  2485 EF                  RST     28H             ;; FP-CALC      ax, ay, Dx, ay, iy.
11521  2486 03                  DEFB    $03             ;;subtract      ax, ay, Dx, ay-iy ( = Dy).
11522  2487 38                  DEFB    $38             ;;end-calc      ax, ay, Dx, Dy.
11523  2488             
11524  2488 CD E6 24            CALL    L24B7           ; Routine DRAW-LINE draws (Dx,Dy) relative to
11525  248B                                             ; the last pixel plotted leaving absolute x 
11526  248B                                             ; and y on the calculator stack.
11527  248B                                             ;               ax, ay.
11528  248B             
11529  248B C1                  POP     BC              ; Restore the arc counter from the machine stack.
11530  248C             
11531  248C 10 C6               DJNZ    L2425           ; Decrement and loop while > 0 to ARC-LOOP
11532  248E             
11533  248E             ; -------------
11534  248E             ; THE 'ARC END'
11535  248E             ; -------------
11536  248E             
11537  248E             ;   To recap the full calculator stack is       tx, ty, ax, ay.
11538  248E             
11539  248E             ;   Just as one would do if drawing the curve on paper, the final line would
11540  248E             ;   be drawn by joining the last point plotted to the initial start point 
11541  248E             ;   in the case of a CIRCLE or to the calculated end point in the case of 
11542  248E             ;   an ARC.
11543  248E             ;   The moving absolute values of x and y are no longer required and they
11544  248E             ;   can be deleted to expose the closing coordinates.
11545  248E             
11546  248E             ;; ARC-END
11547  248E EF          L245F:  RST     28H             ;; FP-CALC      tx, ty, ax, ay.
11548  248F 02                  DEFB    $02             ;;delete        tx, ty, ax.
11549  2490 02                  DEFB    $02             ;;delete        tx, ty.
11550  2491 01                  DEFB    $01             ;;exchange      ty, tx.
11551  2492 38                  DEFB    $38             ;;end-calc      ty, tx.
11552  2493             
11553  2493             ;   First calculate the relative x coordinate to the end-point.
11554  2493             
11555  2493 3A 7D 5C            LD      A,($5C7D)       ; COORDS-x
11556  2496 CD 57 2D            CALL    L2D28           ; routine STACK-A
11557  2499             
11558  2499 EF                  RST     28H             ;; FP-CALC      ty, tx, coords_x.
11559  249A 03                  DEFB    $03             ;;subtract      ty, rx.
11560  249B             
11561  249B             ;   Next calculate the relative y coordinate to the end-point.
11562  249B             
11563  249B 01                  DEFB    $01             ;;exchange      rx, ty.
11564  249C 38                  DEFB    $38             ;;end-calc      rx, ty.
11565  249D             
11566  249D 3A 7E 5C            LD      A,($5C7E)       ; COORDS-y
11567  24A0 CD 57 2D            CALL    L2D28           ; routine STACK-A
11568  24A3             
11569  24A3 EF                  RST     28H             ;; FP-CALC      rx, ty, coords_y
11570  24A4 03                  DEFB    $03             ;;subtract      rx, ry.
11571  24A5 38                  DEFB    $38             ;;end-calc      rx, ry.
11572  24A6             
11573  24A6             ;   Finally draw the last straight line.
11574  24A6             
11575  24A6             ;; LINE-DRAW
11576  24A6 CD E6 24    L2477:  CALL    L24B7           ; routine DRAW-LINE draws to the relative 
11577  24A9                                             ; coordinates (rx, ry).
11578  24A9             
11579  24A9 C3 7C 0D            JP      L0D4D           ; jump back and exit via TEMPS          >>>
11580  24AC             
11581  24AC             
11582  24AC             ; --------------------------------------------
11583  24AC             ; THE 'INITIAL CIRCLE/DRAW PARAMETERS' ROUTINE
11584  24AC             ; --------------------------------------------
11585  24AC             ;   Begin by calculating the number of chords which will be returned in B.
11586  24AC             ;   A rule of thumb is employed that uses a value z which for a circle is the
11587  24AC             ;   radius and for an arc is the diameter with, as it happens, a pinch more if 
11588  24AC             ;   the arc is on a slope.
11589  24AC             ;
11590  24AC             ;   NUMBER OF STRAIGHT LINES = ANGLE OF ROTATION * SQUARE ROOT ( Z ) / 2
11591  24AC             
11592  24AC             ;; CD-PRMS1
11593  24AC EF          L247D:  RST     28H             ;; FP-CALC      z.
11594  24AD 31                  DEFB    $31             ;;duplicate     z, z.
11595  24AE 28                  DEFB    $28             ;;sqr           z, sqr(z).
11596  24AF 34                  DEFB    $34             ;;stk-data      z, sqr(z), 2.
11597  24B0 32                  DEFB    $32             ;;Exponent: $82, Bytes: 1
11598  24B1 00                  DEFB    $00             ;;(+00,+00,+00)
11599  24B2 01                  DEFB    $01             ;;exchange      z, 2, sqr(z).
11600  24B3 05                  DEFB    $05             ;;division      z, 2/sqr(z).
11601  24B4 E5                  DEFB    $E5             ;;get-mem-5     z, 2/sqr(z), ANGLE.
11602  24B5 01                  DEFB    $01             ;;exchange      z, ANGLE, 2/sqr (z)
11603  24B6 05                  DEFB    $05             ;;division      z, ANGLE*sqr(z)/2 (= No. of lines)
11604  24B7 2A                  DEFB    $2A             ;;abs           (for arc only)
11605  24B8 38                  DEFB    $38             ;;end-calc      z, number of lines.
11606  24B9             
11607  24B9             ;    As an example for a circle of radius 87 the number of lines will be 29.
11608  24B9             
11609  24B9 CD 04 2E            CALL    L2DD5           ; routine FP-TO-A
11610  24BC             
11611  24BC             ;    The value is compressed into A register, no carry with valid circle.
11612  24BC             
11613  24BC 38 06               JR      C,L2495         ; forward, if over 256, to USE-252
11614  24BE             
11615  24BE             ;    now make a multiple of 4 e.g. 29 becomes 28
11616  24BE             
11617  24BE E6 FC               AND     $FC             ; AND 252
11618  24C0             
11619  24C0             ;    Adding 4 could set carry for arc, for the circle example, 28 becomes 32.
11620  24C0             
11621  24C0 C6 04               ADD     A,$04           ; adding 4 could set carry if result is 256.
11622  24C2                     
11623  24C2 30 02               JR      NC,L2497        ; forward if less than 256 to DRAW-SAVE
11624  24C4             
11625  24C4             ;    For an arc, a limit of 252 is imposed.
11626  24C4             
11627  24C4             ;; USE-252
11628  24C4 3E FC       L2495:  LD      A,$FC           ; Use a value of 252 (for arc).
11629  24C6             
11630  24C6             
11631  24C6             ;   For both arcs and circles, constants derived from the central angle are
11632  24C6             ;   stored in the 'mem' locations.  Some are not relevant for the circle.
11633  24C6             
11634  24C6             ;; DRAW-SAVE
11635  24C6 F5          L2497:  PUSH    AF              ; Save the line count (A) on the machine stack.
11636  24C7             
11637  24C7 CD 57 2D            CALL    L2D28           ; Routine STACK-A stacks the modified count(A).
11638  24CA             
11639  24CA EF                  RST     28H             ;; FP-CALC      z, A.
11640  24CB E5                  DEFB    $E5             ;;get-mem-5     z, A, ANGLE.
11641  24CC 01                  DEFB    $01             ;;exchange      z, ANGLE, A.
11642  24CD 05                  DEFB    $05             ;;division      z, ANGLE/A. (Angle/count = a)
11643  24CE 31                  DEFB    $31             ;;duplicate     z, a, a. 
11644  24CF             
11645  24CF             ;  Note. that cos (a) could be formed here directly using 'cos' and stored in 
11646  24CF             ;  mem-3 but that would spoil a good story and be slightly slower, as also 
11647  24CF             ;  would using square roots to form cos (a) from sin (a).
11648  24CF             
11649  24CF 1F                  DEFB    $1F             ;;sin           z, a, sin(a)
11650  24D0 C4                  DEFB    $C4             ;;st-mem-4      z, a, sin(a)
11651  24D1 02                  DEFB    $02             ;;delete        z, a.
11652  24D2 31                  DEFB    $31             ;;duplicate     z, a, a.            
11653  24D3 A2                  DEFB    $A2             ;;stk-half      z, a, a, 1/2.
11654  24D4 04                  DEFB    $04             ;;multiply      z, a, a/2.
11655  24D5 1F                  DEFB    $1F             ;;sin           z, a, sin(a/2).
11656  24D6             
11657  24D6             ;   Note. after second sin, mem-0 and mem-1 become free.
11658  24D6             
11659  24D6 C1                  DEFB    $C1             ;;st-mem-1      z, a, sin(a/2).
11660  24D7 01                  DEFB    $01             ;;exchange      z, sin(a/2), a.
11661  24D8 C0                  DEFB    $C0             ;;st-mem-0      z, sin(a/2), a.  (for arc only)
11662  24D9             
11663  24D9             ;   Now form cos(a) from sin(a/2) using the 'DOUBLE ANGLE FORMULA'.
11664  24D9             
11665  24D9 02                  DEFB    $02             ;;delete        z, sin(a/2).
11666  24DA 31                  DEFB    $31             ;;duplicate     z, sin(a/2), sin(a/2).
11667  24DB 04                  DEFB    $04             ;;multiply      z, sin(a/2)*sin(a/2).
11668  24DC 31                  DEFB    $31             ;;duplicate     z, sin(a/2)*sin(a/2),
11669  24DD                                             ;;                           sin(a/2)*sin(a/2).
11670  24DD 0F                  DEFB    $0F             ;;addition      z, 2*sin(a/2)*sin(a/2).
11671  24DE A1                  DEFB    $A1             ;;stk-one       z, 2*sin(a/2)*sin(a/2), 1.
11672  24DF 03                  DEFB    $03             ;;subtract      z, 2*sin(a/2)*sin(a/2)-1.
11673  24E0             
11674  24E0 1B                  DEFB    $1B             ;;negate        z, 1-2*sin(a/2)*sin(a/2).  
11675  24E1             
11676  24E1 C3                  DEFB    $C3             ;;st-mem-3      z, cos(a).
11677  24E2 02                  DEFB    $02             ;;delete        z.
11678  24E3 38                  DEFB    $38             ;;end-calc      z.
11679  24E4             
11680  24E4             ;   The radius/diameter is left on the calculator stack.
11681  24E4             
11682  24E4 C1                  POP     BC              ; Restore the line count to the B register.
11683  24E5             
11684  24E5 C9                  RET                     ; Return.
11685  24E6             
11686  24E6             ; --------------------------
11687  24E6             ; THE 'DOUBLE ANGLE FORMULA'
11688  24E6             ; --------------------------
11689  24E6             ;   This formula forms cos(a) from sin(a/2) using simple arithmetic.
11690  24E6             ;
11691  24E6             ;   THE GEOMETRIC PROOF OF FORMULA   cos (a) = 1 - 2 * sin(a/2) * sin(a/2)
11692  24E6             ;                                                                    
11693  24E6             ;                                                                   
11694  24E6             ;                                            A                     
11695  24E6             ;                                                                 
11696  24E6             ;                                         . /|\                      
11697  24E6             ;                                     .    / | \                     
11698  24E6             ;                                  .      /  |  \                    
11699  24E6             ;                               .        /   |a/2\                   
11700  24E6             ;                            .          /    |    \                  
11701  24E6             ;                         .          1 /     |     \                 
11702  24E6             ;                      .              /      |      \                
11703  24E6             ;                   .                /       |       \               
11704  24E6             ;                .                  /        |        \              
11705  24E6             ;             .  a/2             D / a      E|-+       \             
11706  24E6             ;          B ---------------------/----------+-+--------\ C
11707  24E6             ;            <-         1       -><-       1           ->           
11708  24E6             ;
11709  24E6             ;   cos a = 1 - 2 * sin(a/2) * sin(a/2)
11710  24E6             ;
11711  24E6             ;   The figure shows a right triangle that inscribes a circle of radius 1 with
11712  24E6             ;   centre, or origin, D.  Line BC is the diameter of length 2 and A is a point 
11713  24E6             ;   on the circle. The periphery angle BAC is therefore a right angle by the 
11714  24E6             ;   Rule of Thales.
11715  24E6             ;   Line AC is a chord touching two points on the circle and the angle at the 
11716  24E6             ;   centre is (a).
11717  24E6             ;   Since the vertex of the largest triangle B touches the circle, the 
11718  24E6             ;   inscribed angle (a/2) is half the central angle (a).
11719  24E6             ;   The cosine of (a) is the length DE as the hypotenuse is of length 1.
11720  24E6             ;   This can also be expressed as 1-length CE.  Examining the triangle at the
11721  24E6             ;   right, the top angle is also (a/2) as angle BAE and EBA add to give a right
11722  24E6             ;   angle as do BAE and EAC.
11723  24E6             ;   So cos (a) = 1 - AC * sin(a/2) 
11724  24E6             ;   Looking at the largest triangle, side AC can be expressed as 
11725  24E6             ;   AC = 2 * sin(a/2)   and so combining these we get 
11726  24E6             ;   cos (a) = 1 - 2 * sin(a/2) * sin(a/2).
11727  24E6             ;
11728  24E6             ;   "I will be sufficiently rewarded if when telling it to others, you will 
11729  24E6             ;    not claim the discovery as your own, but will say it is mine."
11730  24E6             ;   - Thales, 640 - 546 B.C.
11731  24E6             ;
11732  24E6             ; --------------------------
11733  24E6             ; THE 'LINE DRAWING' ROUTINE
11734  24E6             ; --------------------------
11735  24E6             ;
11736  24E6             ;
11737  24E6             
11738  24E6             ;; DRAW-LINE
11739  24E6 CD 36 23    L24B7:  CALL    L2307           ; routine STK-TO-BC
11740  24E9 79                  LD      A,C             ;
11741  24EA B8                  CP      B               ;
11742  24EB 30 06               JR      NC,L24C4        ; to DL-X-GE-Y
11743  24ED             
11744  24ED 69                  LD      L,C             ;
11745  24EE D5                  PUSH    DE              ;
11746  24EF AF                  XOR     A               ;
11747  24F0 5F                  LD      E,A             ;
11748  24F1 18 07               JR      L24CB           ; to DL-LARGER
11749  24F3             
11750  24F3             ; ---
11751  24F3             
11752  24F3             ;; DL-X-GE-Y
11753  24F3 B1          L24C4:  OR      C               ;
11754  24F4 C8                  RET     Z               ;
11755  24F5             
11756  24F5 68                  LD      L,B             ;
11757  24F6 41                  LD      B,C             ;
11758  24F7 D5                  PUSH    DE              ;
11759  24F8 16 00               LD      D,$00           ;
11760  24FA             
11761  24FA             ;; DL-LARGER
11762  24FA 60          L24CB:  LD      H,B             ;
11763  24FB 78                  LD      A,B             ;
11764  24FC 1F                  RRA                     ;
11765  24FD             
11766  24FD             ;; D-L-LOOP
11767  24FD 85          L24CE:  ADD     A,L             ;
11768  24FE 38 03               JR      C,L24D4         ; to D-L-DIAG
11769  2500             
11770  2500 BC                  CP      H               ;
11771  2501 38 07               JR      C,L24DB         ; to D-L-HR-VT
11772  2503             
11773  2503             ;; D-L-DIAG
11774  2503 94          L24D4:  SUB     H               ;
11775  2504 4F                  LD      C,A             ;
11776  2505 D9                  EXX                     ;
11777  2506 C1                  POP     BC              ;
11778  2507 C5                  PUSH    BC              ;
11779  2508 18 04               JR      L24DF           ; to D-L-STEP
11780  250A             
11781  250A             ; ---
11782  250A             
11783  250A             ;; D-L-HR-VT
11784  250A 4F          L24DB:  LD      C,A             ;
11785  250B D5                  PUSH    DE              ;
11786  250C D9                  EXX                     ;
11787  250D C1                  POP     BC              ;
11788  250E             
11789  250E             ;; D-L-STEP
11790  250E 2A 7D 5C    L24DF:  LD      HL,($5C7D)      ; COORDS
11791  2511 78                  LD      A,B             ;
11792  2512 84                  ADD     A,H             ;
11793  2513 47                  LD      B,A             ;
11794  2514 79                  LD      A,C             ;
11795  2515 3C                  INC     A               ;
11796  2516 85                  ADD     A,L             ;
11797  2517 38 0D               JR      C,L24F7         ; to D-L-RANGE
11798  2519             
11799  2519 28 0D               JR      Z,L24F9         ; to REPORT-Bc
11800  251B             
11801  251B             ;; D-L-PLOT
11802  251B 3D          L24EC:  DEC     A               ;
11803  251C 4F                  LD      C,A             ;
11804  251D CD 14 23            CALL    L22E5           ; routine PLOT-SUB
11805  2520 D9                  EXX                     ;
11806  2521 79                  LD      A,C             ;
11807  2522 10 D9               DJNZ    L24CE           ; to D-L-LOOP
11808  2524             
11809  2524 D1                  POP     DE              ;
11810  2525 C9                  RET                     ;
11811  2526             
11812  2526             ; ---
11813  2526             
11814  2526             ;; D-L-RANGE
11815  2526 28 F3       L24F7:  JR      Z,L24EC         ; to D-L-PLOT
11816  2528             
11817  2528             
11818  2528             ;; REPORT-Bc
11819  2528 CF          L24F9:  RST     08H             ; ERROR-1
11820  2529 0A                  DEFB    $0A             ; Error Report: Integer out of range
11821  252A             
11822  252A             
11823  252A             
11824  252A             ;***********************************
11825  252A             ;** Part 8. EXPRESSION EVALUATION **
11826  252A             ;***********************************
11827  252A             ;
11828  252A             ; It is a this stage of the ROM that the Spectrum ceases altogether to be
11829  252A             ; just a colourful novelty. One remarkable feature is that in all previous
11830  252A             ; commands when the Spectrum is expecting a number or a string then an
11831  252A             ; expression of the same type can be substituted ad infinitum.
11832  252A             ; This is the routine that evaluates that expression.
11833  252A             ; This is what causes 2 + 2 to give the answer 4.
11834  252A             ; That is quite easy to understand. However you don't have to make it much
11835  252A             ; more complex to start a remarkable juggling act.
11836  252A             ; e.g. PRINT 2 * (VAL "2+2" + TAN 3)
11837  252A             ; In fact, provided there is enough free RAM, the Spectrum can evaluate
11838  252A             ; an expression of unlimited complexity.
11839  252A             ; Apart from a couple of minor glitches, which you can now correct, the
11840  252A             ; system is remarkably robust.
11841  252A             
11842  252A             
11843  252A             ; ---------------------------------
11844  252A             ; Scan expression or sub-expression
11845  252A             ; ---------------------------------
11846  252A             ;
11847  252A             ;
11848  252A             
11849  252A             ;; SCANNING
11850  252A DF          L24FB:  RST     18H             ; GET-CHAR
11851  252B 06 00               LD      B,$00           ; priority marker zero is pushed on stack
11852  252D                                             ; to signify end of expression when it is
11853  252D                                             ; popped off again.
11854  252D C5                  PUSH    BC              ; put in on stack.
11855  252E                                             ; and proceed to consider the first character
11856  252E                                             ; of the expression.
11857  252E             
11858  252E             ;; S-LOOP-1
11859  252E 4F          L24FF:  LD      C,A             ; store the character while a look up is done.
11860  252F 21 C5 25            LD      HL,L2596        ; Address: scan-func
11861  2532 CD 0B 17            CALL    L16DC           ; routine INDEXER is called to see if it is
11862  2535                                             ; part of a limited range '+', '(', 'ATTR' etc.
11863  2535             
11864  2535 79                  LD      A,C             ; fetch the character back
11865  2536 D2 B3 26            JP      NC,L2684        ; jump forward to S-ALPHNUM if not in primary
11866  2539                                             ; operators and functions to consider in the
11867  2539                                             ; first instance a digit or a variable and
11868  2539                                             ; then anything else.                >>>
11869  2539             
11870  2539 06 00               LD      B,$00           ; but here if it was found in table so
11871  253B 4E                  LD      C,(HL)          ; fetch offset from table and make B zero.
11872  253C 09                  ADD     HL,BC           ; add the offset to position found
11873  253D E9                  JP      (HL)            ; and jump to the routine e.g. S-BIN
11874  253E                                             ; making an indirect exit from there.
11875  253E             
11876  253E             ; -------------------------------------------------------------------------
11877  253E             ; The four service subroutines for routines in the scanning function table
11878  253E             ; -------------------------------------------------------------------------
11879  253E             
11880  253E             ; PRINT """Hooray!"" he cried."
11881  253E             
11882  253E             ;; S-QUOTE-S
11883  253E CD 74 00    L250F:  CALL    L0074           ; routine CH-ADD+1 points to next character
11884  2541                                             ; and fetches that character.
11885  2541 03                  INC     BC              ; increase length counter.
11886  2542 FE 0D               CP      $0D             ; is it carriage return ?
11887  2544                                             ; inside a quote.
11888  2544 CA B9 1C            JP      Z,L1C8A         ; jump back to REPORT-C if so.
11889  2547                                             ; 'Nonsense in BASIC'.
11890  2547             
11891  2547 FE 22               CP      $22             ; is it a quote '"' ?
11892  2549 20 F3               JR      NZ,L250F        ; back to S-QUOTE-S if not for more.
11893  254B             
11894  254B CD 74 00            CALL    L0074           ; routine CH-ADD+1
11895  254E FE 22               CP      $22             ; compare with possible adjacent quote
11896  2550 C9                  RET                     ; return. with zero set if two together.
11897  2551             
11898  2551             ; ---
11899  2551             
11900  2551             ; This subroutine is used to get two coordinate expressions for the three
11901  2551             ; functions SCREEN$, ATTR and POINT that have two fixed parameters and
11902  2551             ; therefore require surrounding braces.
11903  2551             
11904  2551             ;; S-2-COORD
11905  2551 E7          L2522:  RST     20H             ; NEXT-CHAR
11906  2552 FE 28               CP      $28             ; is it the opening '(' ?
11907  2554 20 06               JR      NZ,L252D        ; forward to S-RPORT-C if not
11908  2556                                             ; 'Nonsense in BASIC'.
11909  2556             
11910  2556 CD A8 1C            CALL    L1C79           ; routine NEXT-2NUM gets two comma-separated
11911  2559                                             ; numeric expressions. Note. this could cause
11912  2559                                             ; many more recursive calls to SCANNING but
11913  2559                                             ; the parent function will be evaluated fully
11914  2559                                             ; before rejoining the main juggling act.
11915  2559             
11916  2559 DF                  RST     18H             ; GET-CHAR
11917  255A FE 29               CP      $29             ; is it the closing ')' ?
11918  255C             
11919  255C             ;; S-RPORT-C
11920  255C C2 B9 1C    L252D:  JP      NZ,L1C8A        ; jump back to REPORT-C if not.
11921  255F                                             ; 'Nonsense in BASIC'.
11922  255F             
11923  255F             ; ------------
11924  255F             ; Check syntax
11925  255F             ; ------------
11926  255F             ; This routine is called on a number of occasions to check if syntax is being
11927  255F             ; checked or if the program is being run. To test the flag inline would use
11928  255F             ; four bytes of code, but a call instruction only uses 3 bytes of code.
11929  255F             
11930  255F             ;; SYNTAX-Z
11931  255F FD CB 01 7E L2530:  BIT     7,(IY+$01)      ; test FLAGS  - checking syntax only ?
11932  2563 C9                  RET                     ; return.
11933  2564             
11934  2564             ; ----------------
11935  2564             ; Scanning SCREEN$
11936  2564             ; ----------------
11937  2564             ; This function returns the code of a bit-mapped character at screen
11938  2564             ; position at line C, column B. It is unable to detect the mosaic characters
11939  2564             ; which are not bit-mapped but detects the ASCII 32 - 127 range.
11940  2564             ; The bit-mapped UDGs are ignored which is curious as it requires only a
11941  2564             ; few extra bytes of code. As usual, anything to do with CHARS is weird.
11942  2564             ; If no match is found a null string is returned.
11943  2564             ; No actual check on ranges is performed - that's up to the BASIC programmer.
11944  2564             ; No real harm can come from SCREEN$(255,255) although the BASIC manual
11945  2564             ; says that invalid values will be trapped.
11946  2564             ; Interestingly, in the Pitman pocket guide, 1984, Vickers says that the
11947  2564             ; range checking will be performed. 
11948  2564             
11949  2564             ;; S-SCRN$-S
11950  2564 CD 36 23    L2535:  CALL    L2307           ; routine STK-TO-BC.
11951  2567 2A 36 5C            LD      HL,($5C36)      ; fetch address of CHARS.
11952  256A 11 00 01            LD      DE,$0100        ; fetch offset to chr$ 32
11953  256D 19                  ADD     HL,DE           ; and find start of bitmaps.
11954  256E                                             ; Note. not inc h. ??
11955  256E 79                  LD      A,C             ; transfer line to A.
11956  256F 0F                  RRCA                    ; multiply
11957  2570 0F                  RRCA                    ; by
11958  2571 0F                  RRCA                    ; thirty-two.
11959  2572 E6 E0               AND     $E0             ; and with 11100000
11960  2574 A8                  XOR     B               ; combine with column $00 - $1F
11961  2575 5F                  LD      E,A             ; to give the low byte of top line
11962  2576 79                  LD      A,C             ; column to A range 00000000 to 00011111
11963  2577 E6 18               AND     $18             ; and with 00011000
11964  2579 EE 40               XOR     $40             ; xor with 01000000 (high byte screen start)
11965  257B 57                  LD      D,A             ; register DE now holds start address of cell.
11966  257C 06 60               LD      B,$60           ; there are 96 characters in ASCII set.
11967  257E             
11968  257E             ;; S-SCRN-LP
11969  257E C5          L254F:  PUSH    BC              ; save count
11970  257F D5                  PUSH    DE              ; save screen start address
11971  2580 E5                  PUSH    HL              ; save bitmap start
11972  2581 1A                  LD      A,(DE)          ; first byte of screen to A
11973  2582 AE                  XOR     (HL)            ; xor with corresponding character byte
11974  2583 28 04               JR      Z,L255A         ; forward to S-SC-MTCH if they match
11975  2585                                             ; if inverse result would be $FF
11976  2585                                             ; if any other then mismatch
11977  2585             
11978  2585 3C                  INC     A               ; set to $00 if inverse
11979  2586 20 1A               JR      NZ,L2573        ; forward to S-SCR-NXT if a mismatch
11980  2588             
11981  2588 3D                  DEC     A               ; restore $FF
11982  2589             
11983  2589             ; a match has been found so seven more to test.
11984  2589             
11985  2589             ;; S-SC-MTCH
11986  2589 4F          L255A:  LD      C,A             ; load C with inverse mask $00 or $FF
11987  258A 06 07               LD      B,$07           ; count seven more bytes
11988  258C             
11989  258C             ;; S-SC-ROWS
11990  258C 14          L255D:  INC     D               ; increment screen address.
11991  258D 23                  INC     HL              ; increment bitmap address.
11992  258E 1A                  LD      A,(DE)          ; byte to A
11993  258F AE                  XOR     (HL)            ; will give $00 or $FF (inverse)
11994  2590 A9                  XOR     C               ; xor with inverse mask
11995  2591 20 0F               JR      NZ,L2573        ; forward to S-SCR-NXT if no match.
11996  2593             
11997  2593 10 F7               DJNZ    L255D           ; back to S-SC-ROWS until all eight matched.
11998  2595             
11999  2595             ; continue if a match of all eight bytes was found
12000  2595             
12001  2595 C1                  POP     BC              ; discard the
12002  2596 C1                  POP     BC              ; saved
12003  2597 C1                  POP     BC              ; pointers
12004  2598 3E 80               LD      A,$80           ; the endpoint of character set
12005  259A 90                  SUB     B               ; subtract the counter
12006  259B                                             ; to give the code 32-127
12007  259B 01 01 00            LD      BC,$0001        ; make one space in workspace.
12008  259E             
12009  259E F7                  RST     30H             ; BC-SPACES creates the space sliding
12010  259F                                             ; the calculator stack upwards.
12011  259F 12                  LD      (DE),A          ; start is addressed by DE, so insert code
12012  25A0 18 0A               JR      L257D           ; forward to S-SCR-STO
12013  25A2             
12014  25A2             ; ---
12015  25A2             
12016  25A2             ; the jump was here if no match and more bitmaps to test.
12017  25A2             
12018  25A2             ;; S-SCR-NXT
12019  25A2 E1          L2573:  POP     HL              ; restore the last bitmap start
12020  25A3 11 08 00            LD      DE,$0008        ; and prepare to add 8.
12021  25A6 19                  ADD     HL,DE           ; now addresses next character bitmap.
12022  25A7 D1                  POP     DE              ; restore screen address
12023  25A8 C1                  POP     BC              ; and character counter in B
12024  25A9 10 D3               DJNZ    L254F           ; back to S-SCRN-LP if more characters.
12025  25AB             
12026  25AB 48                  LD      C,B             ; B is now zero, so BC now zero.
12027  25AC             
12028  25AC             ;; S-SCR-STO
12029  25AC C3 E1 2A    L257D:  JP      L2AB2           ; to STK-STO-$ to store the string in
12030  25AF                                             ; workspace or a string with zero length.
12031  25AF                                             ; (value of DE doesn't matter in last case)
12032  25AF             
12033  25AF             ; Note. this exit seems correct but the general-purpose routine S-STRING
12034  25AF             ; that calls this one will also stack any of its string results so this
12035  25AF             ; leads to a double storing of the result in this case.
12036  25AF             ; The instruction at L257D should just be a RET.
12037  25AF             ; credit Stephen Kelly and others, 1982.
12038  25AF             
12039  25AF             ; -------------
12040  25AF             ; Scanning ATTR
12041  25AF             ; -------------
12042  25AF             ; This function subroutine returns the attributes of a screen location -
12043  25AF             ; a numeric result.
12044  25AF             ; Again it's up to the BASIC programmer to supply valid values of line/column.
12045  25AF             
12046  25AF             ;; S-ATTR-S
12047  25AF CD 36 23    L2580:  CALL    L2307           ; routine STK-TO-BC fetches line to C,
12048  25B2                                             ; and column to B.
12049  25B2 79                  LD      A,C             ; line to A $00 - $17   (max 00010111)
12050  25B3 0F                  RRCA                    ; rotate
12051  25B4 0F                  RRCA                    ; bits
12052  25B5 0F                  RRCA                    ; left.
12053  25B6 4F                  LD      C,A             ; store in C as an intermediate value.
12054  25B7             
12055  25B7 E6 E0               AND     $E0             ; pick up bits 11100000 ( was 00011100 )
12056  25B9 A8                  XOR     B               ; combine with column $00 - $1F
12057  25BA 6F                  LD      L,A             ; low byte now correct.
12058  25BB             
12059  25BB 79                  LD      A,C             ; bring back intermediate result from C
12060  25BC E6 03               AND     $03             ; mask to give correct third of
12061  25BE                                             ; screen $00 - $02
12062  25BE EE 58               XOR     $58             ; combine with base address.
12063  25C0 67                  LD      H,A             ; high byte correct.
12064  25C1 7E                  LD      A,(HL)          ; pick up the colour attribute.
12065  25C2 C3 57 2D            JP      L2D28           ; forward to STACK-A to store result
12066  25C5                                             ; and make an indirect exit.
12067  25C5             
12068  25C5             ; -----------------------
12069  25C5             ; Scanning function table
12070  25C5             ; -----------------------
12071  25C5             ; This table is used by INDEXER routine to find the offsets to
12072  25C5             ; four operators and eight functions. e.g. $A8 is the token 'FN'.
12073  25C5             ; This table is used in the first instance for the first character of an
12074  25C5             ; expression or by a recursive call to SCANNING for the first character of
12075  25C5             ; any sub-expression. It eliminates functions that have no argument or
12076  25C5             ; functions that can have more than one argument and therefore require
12077  25C5             ; braces. By eliminating and dealing with these now it can later take a
12078  25C5             ; simplistic approach to all other functions and assume that they have
12079  25C5             ; one argument.
12080  25C5             ; Similarly by eliminating BIN and '.' now it is later able to assume that
12081  25C5             ; all numbers begin with a digit and that the presence of a number or
12082  25C5             ; variable can be detected by a call to ALPHANUM.
12083  25C5             ; By default all expressions are positive and the spurious '+' is eliminated
12084  25C5             ; now as in print +2. This should not be confused with the operator '+'.
12085  25C5             ; Note. this does allow a degree of nonsense to be accepted as in
12086  25C5             ; PRINT +"3 is the greatest.".
12087  25C5             ; An acquired programming skill is the ability to include brackets where
12088  25C5             ; they are not necessary.
12089  25C5             ; A bracket at the start of a sub-expression may be spurious or necessary
12090  25C5             ; to denote that the contained expression is to be evaluated as an entity.
12091  25C5             ; In either case this is dealt with by recursive calls to SCANNING.
12092  25C5             ; An expression that begins with a quote requires special treatment.
12093  25C5             
12094  25C5             ;; scan-func
12095  25C5 22 1C       L2596:  DEFB    $22, L25B3-$-1  ; $1C offset to S-QUOTE
12096  25C7 28 4F               DEFB    '(', L25E8-$-1  ; $4F offset to S-BRACKET
12097  25C9 2E F2               DEFB    '.', L268D-$-1  ; $F2 offset to S-DECIMAL
12098  25CB 2B 12               DEFB    '+', L25AF-$-1  ; $12 offset to S-U-PLUS
12099  25CD             
12100  25CD A8 56               DEFB    $A8, L25F5-$-1  ; $56 offset to S-FN
12101  25CF A5 57               DEFB    $A5, L25F8-$-1  ; $57 offset to S-RND
12102  25D1 A7 84               DEFB    $A7, L2627-$-1  ; $84 offset to S-PI
12103  25D3 A6 8F               DEFB    $A6, L2634-$-1  ; $8F offset to S-INKEY$
12104  25D5 C4 E6               DEFB    $C4, L268D-$-1  ; $E6 offset to S-BIN
12105  25D7 AA BF               DEFB    $AA, L2668-$-1  ; $BF offset to S-SCREEN$
12106  25D9 AB C7               DEFB    $AB, L2672-$-1  ; $C7 offset to S-ATTR
12107  25DB A9 CE               DEFB    $A9, L267B-$-1  ; $CE offset to S-POINT
12108  25DD             
12109  25DD 00                  DEFB    $00             ; zero end marker
12110  25DE             
12111  25DE             ; --------------------------
12112  25DE             ; Scanning function routines
12113  25DE             ; --------------------------
12114  25DE             ; These are the 11 subroutines accessed by the above table.
12115  25DE             ; S-BIN and S-DECIMAL are the same
12116  25DE             ; The 1-byte offset limits their location to within 255 bytes of their
12117  25DE             ; entry in the table.
12118  25DE             
12119  25DE             ; ->
12120  25DE             ;; S-U-PLUS
12121  25DE E7          L25AF:  RST     20H             ; NEXT-CHAR just ignore
12122  25DF C3 2E 25            JP      L24FF           ; to S-LOOP-1
12123  25E2             
12124  25E2             ; ---
12125  25E2             
12126  25E2             ; ->
12127  25E2             ;; S-QUOTE
12128  25E2 DF          L25B3:  RST     18H             ; GET-CHAR
12129  25E3 23                  INC     HL              ; address next character (first in quotes)
12130  25E4 E5                  PUSH    HL              ; save start of quoted text.
12131  25E5 01 00 00            LD      BC,$0000        ; initialize length of string to zero.
12132  25E8 CD 3E 25            CALL    L250F           ; routine S-QUOTE-S
12133  25EB 20 1B               JR      NZ,L25D9        ; forward to S-Q-PRMS if
12134  25ED             
12135  25ED             ;; S-Q-AGAIN
12136  25ED CD 3E 25    L25BE:  CALL    L250F           ; routine S-QUOTE-S copies string until a
12137  25F0                                             ; quote is encountered
12138  25F0 28 FB               JR      Z,L25BE         ; back to S-Q-AGAIN if two quotes WERE
12139  25F2                                             ; together.
12140  25F2             
12141  25F2             ; but if just an isolated quote then that terminates the string.
12142  25F2             
12143  25F2 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
12144  25F5 28 11               JR      Z,L25D9         ; forward to S-Q-PRMS if checking syntax.
12145  25F7             
12146  25F7             
12147  25F7 F7                  RST     30H             ; BC-SPACES creates the space for true
12148  25F8                                             ; copy of string in workspace.
12149  25F8 E1                  POP     HL              ; re-fetch start of quoted text.
12150  25F9 D5                  PUSH    DE              ; save start in workspace.
12151  25FA             
12152  25FA             ;; S-Q-COPY
12153  25FA 7E          L25CB:  LD      A,(HL)          ; fetch a character from source.
12154  25FB 23                  INC     HL              ; advance source address.
12155  25FC 12                  LD      (DE),A          ; place in destination.
12156  25FD 13                  INC     DE              ; advance destination address.
12157  25FE FE 22               CP      $22             ; was it a '"' just copied ?
12158  2600 20 F8               JR      NZ,L25CB        ; back to S-Q-COPY to copy more if not
12159  2602             
12160  2602 7E                  LD      A,(HL)          ; fetch adjacent character from source.
12161  2603 23                  INC     HL              ; advance source address.
12162  2604 FE 22               CP      $22             ; is this '"' ? - i.e. two quotes together ?
12163  2606 28 F2               JR      Z,L25CB         ; to S-Q-COPY if so including just one of the
12164  2608                                             ; pair of quotes.
12165  2608             
12166  2608             ; proceed when terminating quote encountered.
12167  2608             
12168  2608             ;; S-Q-PRMS
12169  2608 0B          L25D9:  DEC     BC              ; decrease count by 1.
12170  2609 D1                  POP     DE              ; restore start of string in workspace.
12171  260A             
12172  260A             ;; S-STRING
12173  260A 21 3B 5C    L25DB:  LD      HL,$5C3B        ; Address FLAGS system variable.
12174  260D CB B6               RES     6,(HL)          ; signal string result.
12175  260F CB 7E               BIT     7,(HL)          ; is syntax being checked.
12176  2611 C4 E1 2A            CALL    NZ,L2AB2        ; routine STK-STO-$ is called in runtime.
12177  2614 C3 41 27            JP      L2712           ; jump forward to S-CONT-2          ===>
12178  2617             
12179  2617             ; ---
12180  2617             
12181  2617             ; ->
12182  2617             ;; S-BRACKET
12183  2617 E7          L25E8:  RST     20H             ; NEXT-CHAR
12184  2618 CD 2A 25            CALL    L24FB           ; routine SCANNING is called recursively.
12185  261B FE 29               CP      $29             ; is it the closing ')' ?
12186  261D C2 B9 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not
12187  2620                                             ; 'Nonsense in BASIC'
12188  2620             
12189  2620 E7                  RST     20H             ; NEXT-CHAR
12190  2621 C3 41 27            JP      L2712           ; jump forward to S-CONT-2          ===>
12191  2624             
12192  2624             ; ---
12193  2624             
12194  2624             ; ->
12195  2624             ;; S-FN
12196  2624 C3 EC 27    L25F5:  JP      L27BD           ; jump forward to S-FN-SBRN.
12197  2627             
12198  2627             ; --------------------------------------------------------------------
12199  2627             ;
12200  2627             ;   RANDOM THEORY from the ZX81 manual by Steven Vickers
12201  2627             ;
12202  2627             ;   (same algorithm as the ZX Spectrum).
12203  2627             ; 
12204  2627             ;   Chapter 5. Exercise 6. (For mathematicians only.)
12205  2627             ;
12206  2627             ;   Let p be a [large] prime, & let a be a primitive root modulo p.
12207  2627             ;   Then if b_i is the residue of a^i modulo p (1<=b_i<p-1), the 
12208  2627             ;   sequence             
12209  2627             ;   
12210  2627             ;                           (b_i-1)/(p-1)
12211  2627             ;               
12212  2627             ;   is a cyclical sequence of p-1 distinct numbers in the range 0 to 1
12213  2627             ;   (excluding 1). By choosing a suitably, these can be made to look 
12214  2627             ;   fairly random.
12215  2627             ;
12216  2627             ;     65537 is a Mersenne prime 2^16-1. Note.
12217  2627             ;
12218  2627             ;   Use this, & Gauss' law of quadratic reciprocity, to show that 75 
12219  2627             ;   is a primitive root modulo 65537.
12220  2627             ;
12221  2627             ;     The ZX81 uses p=65537 & a=75, & stores some b_i-1 in memory. 
12222  2627             ;   The function RND involves replacing b_i-1 in memory by b_(i+1)-1, 
12223  2627             ;   & yielding the result (b_(i+1)-1)/(p-1). RAND n (with 1<=n<=65535)
12224  2627             ;   makes b_i equal to n+1.
12225  2627             ;
12226  2627             ; --------------------------------------------------------------------
12227  2627             ;
12228  2627             ; Steven Vickers writing in comp.sys.sinclair on 20-DEC-1993
12229  2627             ; 
12230  2627             ;   Note. (Of course, 65537 is 2^16 + 1, not -1.)
12231  2627             ;
12232  2627             ;   Consider arithmetic modulo a prime p. There are p residue classes, and the
12233  2627             ;   non-zero ones are all invertible. Hence under multiplication they form a
12234  2627             ;   group (Fp*, say) of order p-1; moreover (and not so obvious) Fp* is cyclic.
12235  2627             ;   Its generators are the "primitive roots". The "quadratic residues modulo p"
12236  2627             ;   are the squares in Fp*, and the "Legendre symbol" (d/p) is defined (when p
12237  2627             ;   does not divide d) as +1 or -1, according as d is or is not a quadratic
12238  2627             ;   residue mod p.
12239  2627             ;
12240  2627             ;   In the case when p = 65537, we can show that d is a primitive root if and
12241  2627             ;   only if it's not a quadratic residue. For let w be a primitive root, d
12242  2627             ;   congruent to w^r (mod p). If d is not primitive, then its order is a proper
12243  2627             ;   factor of 65536: hence w^{32768*r} = 1 (mod p), so 65536 divides 32768*r,
12244  2627             ;   and hence r is even and d is a square (mod p). Conversely, the squares in
12245  2627             ;   Fp* form a subgroup of (Fp*)^2 of index 2, and so cannot be generators.
12246  2627             ;
12247  2627             ;   Hence to check whether 75 is primitive mod 65537, we want to calculate that
12248  2627             ;   (75/65537) = -1. There is a multiplicative formula (ab/p) = (a/p)(b/p) (mod
12249  2627             ;   p), so (75/65537) = (5/65537)^2 * (3/65537) = (3/65537). Now the law of
12250  2627             ;   quadratic reciprocity says that if p and q are distinct odd primes, then
12251  2627             ;
12252  2627             ;    (p/q)(q/p) = (-1)^{(p-1)(q-1)/4}
12253  2627             ;
12254  2627             ;   Hence (3/65537) = (65537/3) * (-1)^{65536*2/4} = (65537/3)
12255  2627             ;            = (2/3)  (because 65537 = 2 mod 3)
12256  2627             ;            = -1
12257  2627             ;
12258  2627             ;   (I referred to Pierre Samuel's "Algebraic Theory of Numbers".)
12259  2627             ;
12260  2627             ; ->
12261  2627             
12262  2627             ;; S-RND
12263  2627 CD 5F 25    L25F8:  CALL    L2530           ; routine SYNTAX-Z
12264  262A 28 28               JR      Z,L2625         ; forward to S-RND-END if checking syntax.
12265  262C             
12266  262C ED 4B 76 5C         LD      BC,($5C76)      ; fetch system variable SEED
12267  2630 CD 5A 2D            CALL    L2D2B           ; routine STACK-BC places on calculator stack
12268  2633             
12269  2633 EF                  RST     28H             ;; FP-CALC           ;s.
12270  2634 A1                  DEFB    $A1             ;;stk-one            ;s,1.
12271  2635 0F                  DEFB    $0F             ;;addition           ;s+1.
12272  2636 34                  DEFB    $34             ;;stk-data           ;
12273  2637 37                  DEFB    $37             ;;Exponent: $87,
12274  2638                                             ;;Bytes: 1
12275  2638 16                  DEFB    $16             ;;(+00,+00,+00)      ;s+1,75.
12276  2639 04                  DEFB    $04             ;;multiply           ;(s+1)*75 = v
12277  263A 34                  DEFB    $34             ;;stk-data           ;v.
12278  263B 80                  DEFB    $80             ;;Bytes: 3
12279  263C 41                  DEFB    $41             ;;Exponent $91
12280  263D 00 00 80            DEFB    $00,$00,$80     ;;(+00)              ;v,65537.
12281  2640 32                  DEFB    $32             ;;n-mod-m            ;remainder, result.
12282  2641 02                  DEFB    $02             ;;delete             ;remainder.
12283  2642 A1                  DEFB    $A1             ;;stk-one            ;remainder, 1.
12284  2643 03                  DEFB    $03             ;;subtract           ;remainder - 1. = rnd
12285  2644 31                  DEFB    $31             ;;duplicate          ;rnd,rnd.
12286  2645 38                  DEFB    $38             ;;end-calc
12287  2646             
12288  2646 CD D1 2D            CALL    L2DA2           ; routine FP-TO-BC
12289  2649 ED 43 76 5C         LD      ($5C76),BC      ; store in SEED for next starting point.
12290  264D 7E                  LD      A,(HL)          ; fetch exponent
12291  264E A7                  AND     A               ; is it zero ?
12292  264F 28 03               JR      Z,L2625         ; forward if so to S-RND-END
12293  2651             
12294  2651 D6 10               SUB     $10             ; reduce exponent by 2^16
12295  2653 77                  LD      (HL),A          ; place back
12296  2654             
12297  2654             ;; S-RND-END
12298  2654 18 09       L2625:  JR      L2630           ; forward to S-PI-END
12299  2656             
12300  2656             ; ---
12301  2656             
12302  2656             ; the number PI 3.14159...
12303  2656             
12304  2656             ; ->
12305  2656             ;; S-PI
12306  2656 CD 5F 25    L2627:  CALL    L2530           ; routine SYNTAX-Z
12307  2659 28 04               JR      Z,L2630         ; to S-PI-END if checking syntax.
12308  265B             
12309  265B EF                  RST     28H             ;; FP-CALC
12310  265C A3                  DEFB    $A3             ;;stk-pi/2                          pi/2.
12311  265D 38                  DEFB    $38             ;;end-calc
12312  265E             
12313  265E 34                  INC     (HL)            ; increment the exponent leaving pi
12314  265F                                             ; on the calculator stack.
12315  265F             
12316  265F             ;; S-PI-END
12317  265F E7          L2630:  RST     20H             ; NEXT-CHAR
12318  2660 C3 F2 26            JP      L26C3           ; jump forward to S-NUMERIC
12319  2663             
12320  2663             ; ---
12321  2663             
12322  2663             ; ->
12323  2663             ;; S-INKEY$
12324  2663 01 5A 10    L2634:  LD      BC,$105A        ; priority $10, operation code $1A ('read-in')
12325  2666                                             ; +$40 for string result, numeric operand.
12326  2666                                             ; set this up now in case we need to use the
12327  2666                                             ; calculator.
12328  2666 E7                  RST     20H             ; NEXT-CHAR
12329  2667 FE 23               CP      $23             ; '#' ?
12330  2669 CA 3C 27            JP      Z,L270D         ; to S-PUSH-PO if so to use the calculator
12331  266C                                             ; single operation
12332  266C                                             ; to read from network/RS232 etc. .
12333  266C             
12334  266C             ; else read a key from the keyboard.
12335  266C             
12336  266C 21 3B 5C            LD      HL,$5C3B        ; fetch FLAGS
12337  266F CB B6               RES     6,(HL)          ; signal string result.
12338  2671 CB 7E               BIT     7,(HL)          ; checking syntax ?
12339  2673 28 1F               JR      Z,L2665         ; forward to S-INK$-EN if so
12340  2675             
12341  2675 CD 8E 02            CALL    L028E           ; routine KEY-SCAN key in E, shift in D.
12342  2678 0E 00               LD      C,$00           ; the length of an empty string
12343  267A 20 13               JR      NZ,L2660        ; to S-IK$-STK to store empty string if
12344  267C                                             ; no key returned.
12345  267C             
12346  267C CD 42 03            CALL    L031E           ; routine K-TEST get main code in A
12347  267F 30 0E               JR      NC,L2660        ; to S-IK$-STK to stack null string if
12348  2681                                             ; invalid
12349  2681             
12350  2681 15                  DEC     D               ; D is expected to be FLAGS so set bit 3 $FF
12351  2682                                             ; 'L' Mode so no keywords.
12352  2682 5F                  LD      E,A             ; main key to A
12353  2683                                             ; C is MODE 0 'KLC' from above still.
12354  2683 CD 57 03            CALL    L0333           ; routine K-DECODE
12355  2686 F5                  PUSH    AF              ; save the code
12356  2687 01 01 00            LD      BC,$0001        ; make room for one character
12357  268A             
12358  268A F7                  RST     30H             ; BC-SPACES
12359  268B F1                  POP     AF              ; bring the code back
12360  268C 12                  LD      (DE),A          ; put the key in workspace
12361  268D 0E 01               LD      C,$01           ; set C length to one
12362  268F             
12363  268F             ;; S-IK$-STK
12364  268F 06 00       L2660:  LD      B,$00           ; set high byte of length to zero
12365  2691 CD E1 2A            CALL    L2AB2           ; routine STK-STO-$
12366  2694             
12367  2694             ;; S-INK$-EN
12368  2694 C3 41 27    L2665:  JP      L2712           ; to S-CONT-2            ===>
12369  2697             
12370  2697             ; ---
12371  2697             
12372  2697             ; ->
12373  2697             ;; S-SCREEN$
12374  2697 CD 51 25    L2668:  CALL    L2522           ; routine S-2-COORD
12375  269A C4 64 25            CALL    NZ,L2535        ; routine S-SCRN$-S
12376  269D             
12377  269D E7                  RST     20H             ; NEXT-CHAR
12378  269E C3 0A 26            JP      L25DB           ; forward to S-STRING to stack result
12379  26A1             
12380  26A1             ; ---
12381  26A1             
12382  26A1             ; ->
12383  26A1             ;; S-ATTR
12384  26A1 CD 51 25    L2672:  CALL    L2522           ; routine S-2-COORD
12385  26A4 C4 AF 25            CALL    NZ,L2580        ; routine S-ATTR-S
12386  26A7             
12387  26A7 E7                  RST     20H             ; NEXT-CHAR
12388  26A8 18 48               JR      L26C3           ; forward to S-NUMERIC
12389  26AA             
12390  26AA             ; ---
12391  26AA             
12392  26AA             ; ->
12393  26AA             ;; S-POINT
12394  26AA CD 51 25    L267B:  CALL    L2522           ; routine S-2-COORD
12395  26AD C4 FA 22            CALL    NZ,L22CB        ; routine POINT-SUB
12396  26B0             
12397  26B0 E7                  RST     20H             ; NEXT-CHAR
12398  26B1 18 3F               JR      L26C3           ; forward to S-NUMERIC
12399  26B3             
12400  26B3             ; -----------------------------
12401  26B3             
12402  26B3             ; ==> The branch was here if not in table.
12403  26B3             
12404  26B3             ;; S-ALPHNUM
12405  26B3 CD B7 2C    L2684:  CALL    L2C88           ; routine ALPHANUM checks if variable or
12406  26B6                                             ; a digit.
12407  26B6 30 56               JR      NC,L26DF        ; forward to S-NEGATE if not to consider
12408  26B8                                             ; a '-' character then functions.
12409  26B8             
12410  26B8 FE 41               CP      $41             ; compare 'A'
12411  26BA 30 3C               JR      NC,L26C9        ; forward to S-LETTER if alpha       ->
12412  26BC                                             ; else must have been numeric so continue
12413  26BC                                             ; into that routine.
12414  26BC             
12415  26BC             ; This important routine is called during runtime and from LINE-SCAN
12416  26BC             ; when a BASIC line is checked for syntax. It is this routine that
12417  26BC             ; inserts, during syntax checking, the invisible floating point numbers
12418  26BC             ; after the numeric expression. During runtime it just picks these
12419  26BC             ; numbers up. It also handles BIN format numbers.
12420  26BC             
12421  26BC             ; ->
12422  26BC             ;; S-BIN
12423  26BC             ;; S-DECIMAL
12424  26BC CD 5F 25    L268D:  CALL    L2530           ; routine SYNTAX-Z
12425  26BF 20 23               JR      NZ,L26B5        ; to S-STK-DEC in runtime
12426  26C1             
12427  26C1             ; this route is taken when checking syntax.
12428  26C1             
12429  26C1 CD CA 2C            CALL    L2C9B           ; routine DEC-TO-FP to evaluate number
12430  26C4             
12431  26C4 DF                  RST     18H             ; GET-CHAR to fetch HL
12432  26C5 01 06 00            LD      BC,$0006        ; six locations required
12433  26C8 CD 84 16            CALL    L1655           ; routine MAKE-ROOM
12434  26CB 23                  INC     HL              ; to first new location
12435  26CC 36 0E               LD      (HL),$0E        ; insert number marker
12436  26CE 23                  INC     HL              ; address next
12437  26CF EB                  EX      DE,HL           ; make DE destination.
12438  26D0 2A 65 5C            LD      HL,($5C65)      ; STKEND points to end of stack.
12439  26D3 0E 05               LD      C,$05           ; result is five locations lower
12440  26D5 A7                  AND     A               ; prepare for true subtraction
12441  26D6 ED 42               SBC     HL,BC           ; point to start of value.
12442  26D8 22 65 5C            LD      ($5C65),HL      ; update STKEND as we are taking number.
12443  26DB ED B0               LDIR                    ; Copy five bytes to program location
12444  26DD EB                  EX      DE,HL           ; transfer pointer to HL
12445  26DE 2B                  DEC     HL              ; adjust
12446  26DF CD 77 00            CALL    L0077           ; routine TEMP-PTR1 sets CH-ADD
12447  26E2 18 0E               JR      L26C3           ; to S-NUMERIC to record nature of result
12448  26E4             
12449  26E4             ; ---
12450  26E4             
12451  26E4             ; branch here in runtime.
12452  26E4             
12453  26E4             ;; S-STK-DEC
12454  26E4 DF          L26B5:  RST     18H             ; GET-CHAR positions HL at digit.
12455  26E5             
12456  26E5             ;; S-SD-SKIP
12457  26E5 23          L26B6:  INC     HL              ; advance pointer
12458  26E6 7E                  LD      A,(HL)          ; until we find
12459  26E7 FE 0E               CP      $0E             ; chr 14d - the number indicator
12460  26E9 20 FA               JR      NZ,L26B6        ; to S-SD-SKIP until a match
12461  26EB                                             ; it has to be here.
12462  26EB             
12463  26EB 23                  INC     HL              ; point to first byte of number
12464  26EC CD E3 33            CALL    L33B4           ; routine STACK-NUM stacks it
12465  26EF 22 5D 5C            LD      ($5C5D),HL      ; update system variable CH_ADD
12466  26F2             
12467  26F2             ;; S-NUMERIC
12468  26F2 FD CB 01 F6 L26C3:  SET     6,(IY+$01)      ; update FLAGS  - Signal numeric result
12469  26F6 18 14               JR      L26DD           ; forward to S-CONT-1               ===>
12470  26F8                                             ; actually S-CONT-2 is destination but why
12471  26F8                                             ; waste a byte on a jump when a JR will do.
12472  26F8                                             ; Actually a JR L2712 can be used. Rats.
12473  26F8             
12474  26F8             ; end of functions accessed from scanning functions table.
12475  26F8             
12476  26F8             ; --------------------------
12477  26F8             ; Scanning variable routines
12478  26F8             ; --------------------------
12479  26F8             ;
12480  26F8             ;
12481  26F8             
12482  26F8             ;; S-LETTER
12483  26F8 CD E1 28    L26C9:  CALL    L28B2           ; routine LOOK-VARS
12484  26FB             
12485  26FB DA 5D 1C            JP      C,L1C2E         ; jump back to REPORT-2 if variable not found
12486  26FE                                             ; 'Variable not found'
12487  26FE                                             ; but a variable is always 'found' if syntax
12488  26FE                                             ; is being checked.
12489  26FE             
12490  26FE CC C5 29            CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
12491  2701 3A 3B 5C            LD      A,($5C3B)       ; fetch FLAGS value
12492  2704 FE C0               CP      $C0             ; compare 11000000
12493  2706 38 04               JR      C,L26DD         ; step forward to S-CONT-1 if string  ===>
12494  2708             
12495  2708 23                  INC     HL              ; advance pointer
12496  2709 CD E3 33            CALL    L33B4           ; routine STACK-NUM
12497  270C             
12498  270C             ;; S-CONT-1
12499  270C 18 33       L26DD:  JR      L2712           ; forward to S-CONT-2                 ===>
12500  270E             
12501  270E             ; ----------------------------------------
12502  270E             ; -> the scanning branch was here if not alphanumeric.
12503  270E             ; All the remaining functions will be evaluated by a single call to the
12504  270E             ; calculator. The correct priority for the operation has to be placed in
12505  270E             ; the B register and the operation code, calculator literal in the C register.
12506  270E             ; the operation code has bit 7 set if result is numeric and bit 6 is
12507  270E             ; set if operand is numeric. so
12508  270E             ; $C0 = numeric result, numeric operand.            e.g. 'sin'
12509  270E             ; $80 = numeric result, string operand.             e.g. 'code'
12510  270E             ; $40 = string result, numeric operand.             e.g. 'str$'
12511  270E             ; $00 = string result, string operand.              e.g. 'val$'
12512  270E             
12513  270E             ;; S-NEGATE
12514  270E 01 DB 09    L26DF:  LD      BC,$09DB        ; prepare priority 09, operation code $C0 + 
12515  2711                                             ; 'negate' ($1B) - bits 6 and 7 set for numeric
12516  2711                                             ; result and numeric operand.
12517  2711             
12518  2711 FE 2D               CP      $2D             ; is it '-' ?
12519  2713 28 27               JR      Z,L270D         ; forward if so to S-PUSH-PO
12520  2715             
12521  2715 01 18 10            LD      BC,$1018        ; prepare priority $10, operation code 'val$' -
12522  2718                                             ; bits 6 and 7 reset for string result and
12523  2718                                             ; string operand.
12524  2718                     
12525  2718 FE AE               CP      $AE             ; is it 'VAL$' ?
12526  271A 28 20               JR      Z,L270D         ; forward if so to S-PUSH-PO
12527  271C             
12528  271C D6 AF               SUB     $AF             ; subtract token 'CODE' value to reduce
12529  271E                                             ; functions 'CODE' to 'NOT' although the
12530  271E                                             ; upper range is, as yet, unchecked.
12531  271E                                             ; valid range would be $00 - $14.
12532  271E             
12533  271E DA B9 1C            JP      C,L1C8A         ; jump back to REPORT-C with anything else
12534  2721                                             ; 'Nonsense in BASIC'
12535  2721             
12536  2721 01 F0 04            LD      BC,$04F0        ; prepare priority $04, operation $C0 + 
12537  2724                                             ; 'not' ($30)
12538  2724             
12539  2724 FE 14               CP      $14             ; is it 'NOT'
12540  2726 28 14               JR      Z,L270D         ; forward to S-PUSH-PO if so
12541  2728             
12542  2728 D2 B9 1C            JP      NC,L1C8A        ; to REPORT-C if higher
12543  272B                                             ; 'Nonsense in BASIC'
12544  272B             
12545  272B 06 10               LD      B,$10           ; priority $10 for all the rest
12546  272D C6 DC               ADD     A,$DC           ; make range $DC - $EF
12547  272F                                             ; $C0 + 'code'($1C) thru 'chr$' ($2F)
12548  272F             
12549  272F 4F                  LD      C,A             ; transfer 'function' to C
12550  2730 FE DF               CP      $DF             ; is it 'sin' ?
12551  2732 30 02               JR      NC,L2707        ; forward to S-NO-TO-$  with 'sin' through
12552  2734                                             ; 'chr$' as operand is numeric.
12553  2734             
12554  2734             ; all the rest 'cos' through 'chr$' give a numeric result except 'str$'
12555  2734             ; and 'chr$'.
12556  2734             
12557  2734 CB B1               RES     6,C             ; signal string operand for 'code', 'val' and
12558  2736                                             ; 'len'.
12559  2736             
12560  2736             ;; S-NO-TO-$
12561  2736 FE EE       L2707:  CP      $EE             ; compare 'str$'
12562  2738 38 02               JR      C,L270D         ; forward to S-PUSH-PO if lower as result
12563  273A                                             ; is numeric.
12564  273A             
12565  273A CB B9               RES     7,C             ; reset bit 7 of op code for 'str$', 'chr$'
12566  273C                                             ; as result is string.
12567  273C             
12568  273C             ; >> This is where they were all headed for.
12569  273C             
12570  273C             ;; S-PUSH-PO
12571  273C C5          L270D:  PUSH    BC              ; push the priority and calculator operation
12572  273D                                             ; code.
12573  273D             
12574  273D E7                  RST     20H             ; NEXT-CHAR
12575  273E C3 2E 25            JP      L24FF           ; jump back to S-LOOP-1 to go round the loop
12576  2741                                             ; again with the next character.
12577  2741             
12578  2741             ; --------------------------------
12579  2741             
12580  2741             ; ===>  there were many branches forward to here
12581  2741             
12582  2741             ;   An important step after the evaluation of an expression is to test for
12583  2741             ;   a string expression and allow it to be sliced.  If a numeric expression is 
12584  2741             ;   followed by a '(' then the numeric expression is complete.
12585  2741             ;   Since a string slice can itself be sliced then loop repeatedly 
12586  2741             ;   e.g. (STR$ PI) (3 TO) (TO 2)    or "nonsense" (4 TO )
12587  2741             
12588  2741             ;; S-CONT-2
12589  2741 DF          L2712:  RST     18H             ; GET-CHAR
12590  2742             
12591  2742             ;; S-CONT-3
12592  2742 FE 28       L2713:  CP      $28             ; is it '(' ?
12593  2744 20 0C               JR      NZ,L2723        ; forward, if not, to S-OPERTR 
12594  2746             
12595  2746 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
12596  274A 20 17               JR      NZ,L2734        ; forward, if numeric, to S-LOOP
12597  274C             
12598  274C             ;   if a string expression preceded the '(' then slice it.
12599  274C             
12600  274C CD 81 2A            CALL    L2A52           ; routine SLICING
12601  274F             
12602  274F E7                  RST     20H             ; NEXT-CHAR
12603  2750 18 F0               JR      L2713           ; loop back to S-CONT-3
12604  2752             
12605  2752             ; ---------------------------
12606  2752             
12607  2752             ;   the branch was here when possibility of a '(' has been excluded.
12608  2752             
12609  2752             ;; S-OPERTR
12610  2752 06 00       L2723:  LD      B,$00           ; prepare to add
12611  2754 4F                  LD      C,A             ; possible operator to C
12612  2755 21 C4 27            LD      HL,L2795        ; Address: $2795 - tbl-of-ops
12613  2758 CD 0B 17            CALL    L16DC           ; routine INDEXER
12614  275B 30 06               JR      NC,L2734        ; forward to S-LOOP if not in table
12615  275D             
12616  275D             ;   but if found in table the priority has to be looked up.
12617  275D             
12618  275D 4E                  LD      C,(HL)          ; operation code to C ( B is still zero )
12619  275E 21 1C 27            LD      HL,L27B0 - $C3  ; $26ED is base of table
12620  2761 09                  ADD     HL,BC           ; index into table.
12621  2762 46                  LD      B,(HL)          ; priority to B.
12622  2763             
12623  2763             ; ------------------
12624  2763             ; Scanning main loop
12625  2763             ; ------------------
12626  2763             ; the juggling act
12627  2763             
12628  2763             ;; S-LOOP
12629  2763 D1          L2734:  POP     DE              ; fetch last priority and operation
12630  2764 7A                  LD      A,D             ; priority to A
12631  2765 B8                  CP      B               ; compare with this one
12632  2766 38 3A               JR      C,L2773         ; forward to S-TIGHTER to execute the
12633  2768                                             ; last operation before this one as it has
12634  2768                                             ; higher priority.
12635  2768             
12636  2768             ; the last priority was greater or equal this one.
12637  2768             
12638  2768 A7                  AND     A               ; if it is zero then so is this
12639  2769 CA 18 00            JP      Z,L0018         ; jump to exit via get-char pointing at
12640  276C                                             ; next character.
12641  276C                                             ; This may be the character after the
12642  276C                                             ; expression or, if exiting a recursive call,
12643  276C                                             ; the next part of the expression to be
12644  276C                                             ; evaluated.
12645  276C             
12646  276C C5                  PUSH    BC              ; save current priority/operation
12647  276D                                             ; as it has lower precedence than the one
12648  276D                                             ; now in DE.
12649  276D             
12650  276D             ; the 'USR' function is special in that it is overloaded to give two types
12651  276D             ; of result.
12652  276D             
12653  276D 21 3B 5C            LD      HL,$5C3B        ; address FLAGS
12654  2770 7B                  LD      A,E             ; new operation to A register
12655  2771 FE ED               CP      $ED             ; is it $C0 + 'usr-no' ($2D)  ?
12656  2773 20 06               JR      NZ,L274C        ; forward to S-STK-LST if not
12657  2775             
12658  2775 CB 76               BIT     6,(HL)          ; string result expected ?
12659  2777                                             ; (from the lower priority operand we've
12660  2777                                             ; just pushed on stack )
12661  2777 20 02               JR      NZ,L274C        ; forward to S-STK-LST if numeric
12662  2779                                             ; as operand bits match.
12663  2779             
12664  2779 1E 99               LD      E,$99           ; reset bit 6 and substitute $19 'usr-$'
12665  277B                                             ; for string operand.
12666  277B             
12667  277B             ;; S-STK-LST
12668  277B D5          L274C:  PUSH    DE              ; now stack this priority/operation
12669  277C CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
12670  277F 28 09               JR      Z,L275B         ; forward to S-SYNTEST if checking syntax.
12671  2781             
12672  2781 7B                  LD      A,E             ; fetch the operation code
12673  2782 E6 3F               AND     $3F             ; mask off the result/operand bits to leave
12674  2784                                             ; a calculator literal.
12675  2784 47                  LD      B,A             ; transfer to B register
12676  2785             
12677  2785             ; now use the calculator to perform the single operation - operand is on
12678  2785             ; the calculator stack.
12679  2785             ; Note. although the calculator is performing a single operation most
12680  2785             ; functions e.g. TAN are written using other functions and literals and
12681  2785             ; these in turn are written using further strings of calculator literals so
12682  2785             ; another level of magical recursion joins the juggling act for a while
12683  2785             ; as the calculator too is calling itself.
12684  2785             
12685  2785 EF                  RST     28H             ;; FP-CALC
12686  2786 3B                  DEFB    $3B             ;;fp-calc-2
12687  2787 38          L2758:  DEFB    $38             ;;end-calc
12688  2788             
12689  2788 18 09               JR      L2764           ; forward to S-RUNTEST
12690  278A             
12691  278A             ; ---
12692  278A             
12693  278A             ; the branch was here if checking syntax only. 
12694  278A             
12695  278A             ;; S-SYNTEST
12696  278A 7B          L275B:  LD      A,E             ; fetch the operation code to accumulator
12697  278B FD AE 01            XOR     (IY+$01)        ; compare with bits of FLAGS
12698  278E E6 40               AND     $40             ; bit 6 will be zero now if operand
12699  2790                                             ; matched expected result.
12700  2790             
12701  2790             ;; S-RPORT-C2
12702  2790 C2 B9 1C    L2761:  JP      NZ,L1C8A        ; to REPORT-C if mismatch
12703  2793                                             ; 'Nonsense in BASIC'
12704  2793                                             ; else continue to set flags for next
12705  2793             
12706  2793             ; the branch is to here in runtime after a successful operation.
12707  2793             
12708  2793             ;; S-RUNTEST
12709  2793 D1          L2764:  POP     DE              ; fetch the last operation from stack
12710  2794 21 3B 5C            LD      HL,$5C3B        ; address FLAGS
12711  2797 CB F6               SET     6,(HL)          ; set default to numeric result in FLAGS
12712  2799 CB 7B               BIT     7,E             ; test the operational result
12713  279B 20 02               JR      NZ,L2770        ; forward to S-LOOPEND if numeric
12714  279D             
12715  279D CB B6               RES     6,(HL)          ; reset bit 6 of FLAGS to show string result.
12716  279F             
12717  279F             ;; S-LOOPEND
12718  279F C1          L2770:  POP     BC              ; fetch the previous priority/operation
12719  27A0 18 C1               JR      L2734           ; back to S-LOOP to perform these
12720  27A2             
12721  27A2             ; ---
12722  27A2             
12723  27A2             ; the branch was here when a stacked priority/operator had higher priority
12724  27A2             ; than the current one.
12725  27A2             
12726  27A2             ;; S-TIGHTER
12727  27A2 D5          L2773:  PUSH    DE              ; save high priority op on stack again
12728  27A3 79                  LD      A,C             ; fetch lower priority operation code
12729  27A4 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS - Numeric or string result ?
12730  27A8 20 15               JR      NZ,L2790        ; forward to S-NEXT if numeric result
12731  27AA             
12732  27AA             ; if this is lower priority yet has string then must be a comparison.
12733  27AA             ; Since these can only be evaluated in context and were defaulted to
12734  27AA             ; numeric in operator look up they must be changed to string equivalents.
12735  27AA             
12736  27AA E6 3F               AND     $3F             ; mask to give true calculator literal
12737  27AC C6 08               ADD     A,$08           ; augment numeric literals to string
12738  27AE                                             ; equivalents.
12739  27AE                                             ; 'no-&-no'  => 'str-&-no'
12740  27AE                                             ; 'no-l-eql' => 'str-l-eql'
12741  27AE                                             ; 'no-gr-eq' => 'str-gr-eq'
12742  27AE                                             ; 'nos-neql' => 'strs-neql'
12743  27AE                                             ; 'no-grtr'  => 'str-grtr'
12744  27AE                                             ; 'no-less'  => 'str-less'
12745  27AE                                             ; 'nos-eql'  => 'strs-eql'
12746  27AE                                             ; 'addition' => 'strs-add'
12747  27AE 4F                  LD      C,A             ; put modified comparison operator back
12748  27AF FE 10               CP      $10             ; is it now 'str-&-no' ?
12749  27B1 20 04               JR      NZ,L2788        ; forward to S-NOT-AND  if not.
12750  27B3             
12751  27B3 CB F1               SET     6,C             ; set numeric operand bit
12752  27B5 18 08               JR      L2790           ; forward to S-NEXT
12753  27B7             
12754  27B7             ; ---
12755  27B7             
12756  27B7             ;; S-NOT-AND
12757  27B7 38 D7       L2788:  JR      C,L2761         ; back to S-RPORT-C2 if less
12758  27B9                                             ; 'Nonsense in BASIC'.
12759  27B9                                             ; e.g. a$ * b$
12760  27B9             
12761  27B9 FE 17               CP      $17             ; is it 'strs-add' ?
12762  27BB 28 02               JR      Z,L2790         ; forward to S-NEXT if so
12763  27BD                                             ; (bit 6 and 7 are reset)
12764  27BD             
12765  27BD CB F9               SET     7,C             ; set numeric (Boolean) result for all others
12766  27BF             
12767  27BF             ;; S-NEXT
12768  27BF C5          L2790:  PUSH    BC              ; now save this priority/operation on stack
12769  27C0             
12770  27C0 E7                  RST     20H             ; NEXT-CHAR
12771  27C1 C3 2E 25            JP      L24FF           ; jump back to S-LOOP-1
12772  27C4             
12773  27C4             ; ------------------
12774  27C4             ; Table of operators
12775  27C4             ; ------------------
12776  27C4             ; This table is used to look up the calculator literals associated with
12777  27C4             ; the operator character. The thirteen calculator operations $03 - $0F
12778  27C4             ; have bits 6 and 7 set to signify a numeric result.
12779  27C4             ; Some of these codes and bits may be altered later if the context suggests
12780  27C4             ; a string comparison or operation.
12781  27C4             ; that is '+', '=', '>', '<', '<=', '>=' or '<>'.
12782  27C4             
12783  27C4             ;; tbl-of-ops
12784  27C4 2B CF       L2795:  DEFB    '+', $CF        ;        $C0 + 'addition'
12785  27C6 2D C3               DEFB    '-', $C3        ;        $C0 + 'subtract'
12786  27C8 2A C4               DEFB    '*', $C4        ;        $C0 + 'multiply'
12787  27CA 2F C5               DEFB    '/', $C5        ;        $C0 + 'division'
12788  27CC 5E C6               DEFB    '^', $C6        ;        $C0 + 'to-power'
12789  27CE 3D CE               DEFB    '=', $CE        ;        $C0 + 'nos-eql'
12790  27D0 3E CC               DEFB    '>', $CC        ;        $C0 + 'no-grtr'
12791  27D2 3C CD               DEFB    '<', $CD        ;        $C0 + 'no-less'
12792  27D4             
12793  27D4 C7 C9               DEFB    $C7, $C9        ; '<='   $C0 + 'no-l-eql'
12794  27D6 C8 CA               DEFB    $C8, $CA        ; '>='   $C0 + 'no-gr-eql'
12795  27D8 C9 CB               DEFB    $C9, $CB        ; '<>'   $C0 + 'nos-neql'
12796  27DA C5 C7               DEFB    $C5, $C7        ; 'OR'   $C0 + 'or'
12797  27DC C6 C8               DEFB    $C6, $C8        ; 'AND'  $C0 + 'no-&-no'
12798  27DE             
12799  27DE 00                  DEFB    $00             ; zero end-marker.
12800  27DF             
12801  27DF             
12802  27DF             ; -------------------
12803  27DF             ; Table of priorities
12804  27DF             ; -------------------
12805  27DF             ; This table is indexed with the operation code obtained from the above
12806  27DF             ; table $C3 - $CF to obtain the priority for the respective operation.
12807  27DF             
12808  27DF             ;; tbl-priors
12809  27DF 06          L27B0:  DEFB    $06             ; '-'   opcode $C3
12810  27E0 08                  DEFB    $08             ; '*'   opcode $C4
12811  27E1 08                  DEFB    $08             ; '/'   opcode $C5
12812  27E2 0A                  DEFB    $0A             ; '^'   opcode $C6
12813  27E3 02                  DEFB    $02             ; 'OR'  opcode $C7
12814  27E4 03                  DEFB    $03             ; 'AND' opcode $C8
12815  27E5 05                  DEFB    $05             ; '<='  opcode $C9
12816  27E6 05                  DEFB    $05             ; '>='  opcode $CA
12817  27E7 05                  DEFB    $05             ; '<>'  opcode $CB
12818  27E8 05                  DEFB    $05             ; '>'   opcode $CC
12819  27E9 05                  DEFB    $05             ; '<'   opcode $CD
12820  27EA 05                  DEFB    $05             ; '='   opcode $CE
12821  27EB 06                  DEFB    $06             ; '+'   opcode $CF
12822  27EC             
12823  27EC             ; ----------------------
12824  27EC             ; Scanning function (FN)
12825  27EC             ; ----------------------
12826  27EC             ; This routine deals with user-defined functions.
12827  27EC             ; The definition can be anywhere in the program area but these are best
12828  27EC             ; placed near the start of the program as we shall see.
12829  27EC             ; The evaluation process is quite complex as the Spectrum has to parse two
12830  27EC             ; statements at the same time. Syntax of both has been checked previously
12831  27EC             ; and hidden locations have been created immediately after each argument
12832  27EC             ; of the DEF FN statement. Each of the arguments of the FN function is
12833  27EC             ; evaluated by SCANNING and placed in the hidden locations. Then the
12834  27EC             ; expression to the right of the DEF FN '=' is evaluated by SCANNING and for
12835  27EC             ; any variables encountered, a search is made in the DEF FN variable list
12836  27EC             ; in the program area before searching in the normal variables area.
12837  27EC             ;
12838  27EC             ; Recursion is not allowed: i.e. the definition of a function should not use
12839  27EC             ; the same function, either directly or indirectly ( through another function).
12840  27EC             ; You'll normally get error 4, ('Out of memory'), although sometimes the system
12841  27EC             ; will crash. - Vickers, Pitman 1984.
12842  27EC             ;
12843  27EC             ; As the definition is just an expression, there would seem to be no means
12844  27EC             ; of breaking out of such recursion.
12845  27EC             ; However, by the clever use of string expressions and VAL, such recursion is
12846  27EC             ; possible.
12847  27EC             ; e.g. DEF FN a(n) = VAL "n+FN a(n-1)+0" ((n<1) * 10 + 1 TO )
12848  27EC             ; will evaluate the full 11-character expression for all values where n is
12849  27EC             ; greater than zero but just the 11th character, "0", when n drops to zero
12850  27EC             ; thereby ending the recursion producing the correct result.
12851  27EC             ; Recursive string functions are possible using VAL$ instead of VAL and the
12852  27EC             ; null string as the final addend.
12853  27EC             ; - from a turn of the century newsgroup discussion initiated by Mike Wynne.
12854  27EC             
12855  27EC             ;; S-FN-SBRN
12856  27EC CD 5F 25    L27BD:  CALL    L2530           ; routine SYNTAX-Z
12857  27EF 20 35               JR      NZ,L27F7        ; forward to SF-RUN in runtime
12858  27F1             
12859  27F1             
12860  27F1 E7                  RST     20H             ; NEXT-CHAR
12861  27F2 CD BC 2C            CALL    L2C8D           ; routine ALPHA check for letters A-Z a-z
12862  27F5 D2 B9 1C            JP      NC,L1C8A        ; jump back to REPORT-C if not
12863  27F8                                             ; 'Nonsense in BASIC'
12864  27F8             
12865  27F8             
12866  27F8 E7                  RST     20H             ; NEXT-CHAR
12867  27F9 FE 24               CP      $24             ; is it '$' ?
12868  27FB F5                  PUSH    AF              ; save character and flags
12869  27FC 20 01               JR      NZ,L27D0        ; forward to SF-BRKT-1 with numeric function
12870  27FE             
12871  27FE             
12872  27FE E7                  RST     20H             ; NEXT-CHAR
12873  27FF             
12874  27FF             ;; SF-BRKT-1
12875  27FF FE 28       L27D0:  CP      $28             ; is '(' ?
12876  2801 20 12               JR      NZ,L27E6        ; forward to SF-RPRT-C if not
12877  2803                                             ; 'Nonsense in BASIC'
12878  2803             
12879  2803             
12880  2803 E7                  RST     20H             ; NEXT-CHAR
12881  2804 FE 29               CP      $29             ; is it ')' ?
12882  2806 28 10               JR      Z,L27E9         ; forward to SF-FLAG-6 if no arguments.
12883  2808             
12884  2808             ;; SF-ARGMTS
12885  2808 CD 2A 25    L27D9:  CALL    L24FB           ; routine SCANNING checks each argument
12886  280B                                             ; which may be an expression.
12887  280B             
12888  280B DF                  RST     18H             ; GET-CHAR
12889  280C FE 2C               CP      $2C             ; is it a ',' ?
12890  280E 20 03               JR      NZ,L27E4        ; forward if not to SF-BRKT-2 to test bracket
12891  2810             
12892  2810             
12893  2810 E7                  RST     20H             ; NEXT-CHAR if a comma was found
12894  2811 18 F5               JR      L27D9           ; back to SF-ARGMTS to parse all arguments.
12895  2813             
12896  2813             ; ---
12897  2813             
12898  2813             ;; SF-BRKT-2
12899  2813 FE 29       L27E4:  CP      $29             ; is character the closing ')' ?
12900  2815             
12901  2815             ;; SF-RPRT-C
12902  2815 C2 B9 1C    L27E6:  JP      NZ,L1C8A        ; jump to REPORT-C
12903  2818                                             ; 'Nonsense in BASIC'
12904  2818             
12905  2818             ; at this point any optional arguments have had their syntax checked.
12906  2818             
12907  2818             ;; SF-FLAG-6
12908  2818 E7          L27E9:  RST     20H             ; NEXT-CHAR
12909  2819 21 3B 5C            LD      HL,$5C3B        ; address system variable FLAGS
12910  281C CB B6               RES     6,(HL)          ; signal string result
12911  281E F1                  POP     AF              ; restore test against '$'.
12912  281F 28 02               JR      Z,L27F4         ; forward to SF-SYN-EN if string function.
12913  2821             
12914  2821 CB F6               SET     6,(HL)          ; signal numeric result
12915  2823             
12916  2823             ;; SF-SYN-EN
12917  2823 C3 41 27    L27F4:  JP      L2712           ; jump back to S-CONT-2 to continue scanning.
12918  2826             
12919  2826             ; ---
12920  2826             
12921  2826             ; the branch was here in runtime.
12922  2826             
12923  2826             ;; SF-RUN
12924  2826 E7          L27F7:  RST     20H             ; NEXT-CHAR fetches name
12925  2827 E6 DF               AND     $DF             ; AND 11101111 - reset bit 5 - upper-case.
12926  2829 47                  LD      B,A             ; save in B
12927  282A             
12928  282A E7                  RST     20H             ; NEXT-CHAR
12929  282B D6 24               SUB     $24             ; subtract '$'
12930  282D 4F                  LD      C,A             ; save result in C
12931  282E 20 01               JR      NZ,L2802        ; forward if not '$' to SF-ARGMT1
12932  2830             
12933  2830 E7                  RST     20H             ; NEXT-CHAR advances to bracket
12934  2831             
12935  2831             ;; SF-ARGMT1
12936  2831 E7          L2802:  RST     20H             ; NEXT-CHAR advances to start of argument
12937  2832 E5                  PUSH    HL              ; save address
12938  2833 2A 53 5C            LD      HL,($5C53)      ; fetch start of program area from PROG
12939  2836 2B                  DEC     HL              ; the search starting point is the previous
12940  2837                                             ; location.
12941  2837             
12942  2837             ;; SF-FND-DF
12943  2837 11 CE 00    L2808:  LD      DE,$00CE        ; search is for token 'DEF FN' in E,
12944  283A                                             ; statement count in D.
12945  283A C5                  PUSH    BC              ; save C the string test, and B the letter.
12946  283B CD B5 1D            CALL    L1D86           ; routine LOOK-PROG will search for token.
12947  283E C1                  POP     BC              ; restore BC.
12948  283F 30 02               JR      NC,L2814        ; forward to SF-CP-DEF if a match was found.
12949  2841             
12950  2841             
12951  2841             ;; REPORT-P
12952  2841 CF          L2812:  RST     08H             ; ERROR-1
12953  2842 18                  DEFB    $18             ; Error Report: FN without DEF
12954  2843             
12955  2843             ;; SF-CP-DEF
12956  2843 E5          L2814:  PUSH    HL              ; save address of DEF FN
12957  2844 CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips over white-space etc.
12958  2847                                             ; without disturbing CH-ADD.
12959  2847 E6 DF               AND     $DF             ; make fetched character upper-case.
12960  2849 B8                  CP      B               ; compare with FN name
12961  284A 20 08               JR      NZ,L2825        ; forward to SF-NOT-FD if no match.
12962  284C             
12963  284C             ; the letters match so test the type.
12964  284C             
12965  284C CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips white-space
12966  284F D6 24               SUB     $24             ; subtract '$' from fetched character
12967  2851 B9                  CP      C               ; compare with saved result of same operation
12968  2852                                             ; on FN name.
12969  2852 28 0C               JR      Z,L2831         ; forward to SF-VALUES with a match.
12970  2854             
12971  2854             ; the letters matched but one was string and the other numeric.
12972  2854             
12973  2854             ;; SF-NOT-FD
12974  2854 E1          L2825:  POP     HL              ; restore search point.
12975  2855 2B                  DEC     HL              ; make location before
12976  2856 11 00 02            LD      DE,$0200        ; the search is to be for the end of the
12977  2859                                             ; current definition - 2 statements forward.
12978  2859 C5                  PUSH    BC              ; save the letter/type
12979  285A CD BA 19            CALL    L198B           ; routine EACH-STMT steps past rejected
12980  285D                                             ; definition.
12981  285D C1                  POP     BC              ; restore letter/type
12982  285E 18 D7               JR      L2808           ; back to SF-FND-DF to continue search
12983  2860             
12984  2860             ; ---
12985  2860             
12986  2860             ; Success!
12987  2860             ; the branch was here with matching letter and numeric/string type.
12988  2860             
12989  2860             ;; SF-VALUES
12990  2860 A7          L2831:  AND     A               ; test A ( will be zero if string '$' - '$' )
12991  2861             
12992  2861 CC DA 28            CALL    Z,L28AB         ; routine FN-SKPOVR advances HL past '$'.
12993  2864             
12994  2864 D1                  POP     DE              ; discard pointer to 'DEF FN'.
12995  2865 D1                  POP     DE              ; restore pointer to first FN argument.
12996  2866 ED 53 5D 5C         LD      ($5C5D),DE      ; save in CH_ADD
12997  286A             
12998  286A CD DA 28            CALL    L28AB           ; routine FN-SKPOVR advances HL past '('
12999  286D E5                  PUSH    HL              ; save start address in DEF FN  ***
13000  286E FE 29               CP      $29             ; is character a ')' ?
13001  2870 28 42               JR      Z,L2885         ; forward to SF-R-BR-2 if no arguments.
13002  2872             
13003  2872             ;; SF-ARG-LP
13004  2872 23          L2843:  INC     HL              ; point to next character.
13005  2873 7E                  LD      A,(HL)          ; fetch it.
13006  2874 FE 0E               CP      $0E             ; is it the number marker
13007  2876 16 40               LD      D,$40           ; signal numeric in D.
13008  2878 28 07               JR      Z,L2852         ; forward to SF-ARG-VL if numeric.
13009  287A             
13010  287A 2B                  DEC     HL              ; back to letter
13011  287B CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips any white-space
13012  287E 23                  INC     HL              ; advance past the expected '$' to 
13013  287F                                             ; the 'hidden' marker.
13014  287F 16 00               LD      D,$00           ; signal string.
13015  2881             
13016  2881             ;; SF-ARG-VL
13017  2881 23          L2852:  INC     HL              ; now address first of 5-byte location.
13018  2882 E5                  PUSH    HL              ; save address in DEF FN statement
13019  2883 D5                  PUSH    DE              ; save D - result type
13020  2884             
13021  2884 CD 2A 25            CALL    L24FB           ; routine SCANNING evaluates expression in
13022  2887                                             ; the FN statement setting FLAGS and leaving
13023  2887                                             ; result as last value on calculator stack.
13024  2887             
13025  2887 F1                  POP     AF              ; restore saved result type to A
13026  2888             
13027  2888 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS
13028  288B E6 40               AND     $40             ; and with 01000000 to test bit 6
13029  288D 20 2B               JR      NZ,L288B        ; forward to REPORT-Q if type mismatch.
13030  288F                                             ; 'Parameter error'
13031  288F             
13032  288F E1                  POP     HL              ; pop the start address in DEF FN statement
13033  2890 EB                  EX      DE,HL           ; transfer to DE ?? pop straight into de ?
13034  2891             
13035  2891 2A 65 5C            LD      HL,($5C65)      ; set HL to STKEND location after value
13036  2894 01 05 00            LD      BC,$0005        ; five bytes to move
13037  2897 ED 42               SBC     HL,BC           ; decrease HL by 5 to point to start.
13038  2899 22 65 5C            LD      ($5C65),HL      ; set STKEND 'removing' value from stack.
13039  289C             
13040  289C ED B0               LDIR                    ; copy value into DEF FN statement
13041  289E EB                  EX      DE,HL           ; set HL to location after value in DEF FN
13042  289F 2B                  DEC     HL              ; step back one
13043  28A0 CD DA 28            CALL    L28AB           ; routine FN-SKPOVR gets next valid character
13044  28A3 FE 29               CP      $29             ; is it ')' end of arguments ?
13045  28A5 28 0D               JR      Z,L2885         ; forward to SF-R-BR-2 if so.
13046  28A7             
13047  28A7             ; a comma separator has been encountered in the DEF FN argument list.
13048  28A7             
13049  28A7 E5                  PUSH    HL              ; save position in DEF FN statement
13050  28A8             
13051  28A8 DF                  RST     18H             ; GET-CHAR from FN statement
13052  28A9 FE 2C               CP      $2C             ; is it ',' ?
13053  28AB 20 0D               JR      NZ,L288B        ; forward to REPORT-Q if not
13054  28AD                                             ; 'Parameter error'
13055  28AD             
13056  28AD E7                  RST     20H             ; NEXT-CHAR in FN statement advances to next
13057  28AE                                             ; argument.
13058  28AE             
13059  28AE E1                  POP     HL              ; restore DEF FN pointer
13060  28AF CD DA 28            CALL    L28AB           ; routine FN-SKPOVR advances to corresponding
13061  28B2                                             ; argument.
13062  28B2             
13063  28B2 18 BE               JR      L2843           ; back to SF-ARG-LP looping until all
13064  28B4                                             ; arguments are passed into the DEF FN
13065  28B4                                             ; hidden locations.
13066  28B4             
13067  28B4             ; ---
13068  28B4             
13069  28B4             ; the branch was here when all arguments passed.
13070  28B4             
13071  28B4             ;; SF-R-BR-2
13072  28B4 E5          L2885:  PUSH    HL              ; save location of ')' in DEF FN
13073  28B5             
13074  28B5 DF                  RST     18H             ; GET-CHAR gets next character in FN
13075  28B6 FE 29               CP      $29             ; is it a ')' also ?
13076  28B8 28 02               JR      Z,L288D         ; forward to SF-VALUE if so.
13077  28BA             
13078  28BA             
13079  28BA             ;; REPORT-Q
13080  28BA CF          L288B:  RST     08H             ; ERROR-1
13081  28BB 19                  DEFB    $19             ; Error Report: Parameter error
13082  28BC             
13083  28BC             ;; SF-VALUE
13084  28BC D1          L288D:  POP     DE              ; location of ')' in DEF FN to DE.
13085  28BD EB                  EX      DE,HL           ; now to HL, FN ')' pointer to DE.
13086  28BE 22 5D 5C            LD      ($5C5D),HL      ; initialize CH_ADD to this value.
13087  28C1             
13088  28C1             ; At this point the start of the DEF FN argument list is on the machine stack.
13089  28C1             ; We also have to consider that this defined function may form part of the
13090  28C1             ; definition of another defined function (though not itself).
13091  28C1             ; As this defined function may be part of a hierarchy of defined functions
13092  28C1             ; currently being evaluated by recursive calls to SCANNING, then we have to
13093  28C1             ; preserve the original value of DEFADD and not assume that it is zero.
13094  28C1             
13095  28C1 2A 0B 5C            LD      HL,($5C0B)      ; get original DEFADD address
13096  28C4 E3                  EX      (SP),HL         ; swap with DEF FN address on stack ***
13097  28C5 22 0B 5C            LD      ($5C0B),HL      ; set DEFADD to point to this argument list
13098  28C8                                             ; during scanning.
13099  28C8             
13100  28C8 D5                  PUSH    DE              ; save FN ')' pointer.
13101  28C9             
13102  28C9 E7                  RST     20H             ; NEXT-CHAR advances past ')' in define
13103  28CA             
13104  28CA E7                  RST     20H             ; NEXT-CHAR advances past '=' to expression
13105  28CB             
13106  28CB CD 2A 25            CALL    L24FB           ; routine SCANNING evaluates but searches
13107  28CE                                             ; initially for variables at DEFADD
13108  28CE             
13109  28CE E1                  POP     HL              ; pop the FN ')' pointer
13110  28CF 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to this
13111  28D2 E1                  POP     HL              ; pop the original DEFADD value
13112  28D3 22 0B 5C            LD      ($5C0B),HL      ; and re-insert into DEFADD system variable.
13113  28D6             
13114  28D6 E7                  RST     20H             ; NEXT-CHAR advances to character after ')'
13115  28D7 C3 41 27            JP      L2712           ; to S-CONT-2 - to continue current
13116  28DA                                             ; invocation of scanning
13117  28DA             
13118  28DA             ; --------------------
13119  28DA             ; Used to parse DEF FN
13120  28DA             ; --------------------
13121  28DA             ; e.g. DEF FN     s $ ( x )     =  b     $ (  TO  x  ) : REM exaggerated
13122  28DA             ;
13123  28DA             ; This routine is used 10 times to advance along a DEF FN statement
13124  28DA             ; skipping spaces and colour control codes. It is similar to NEXT-CHAR
13125  28DA             ; which is, at the same time, used to skip along the corresponding FN function
13126  28DA             ; except the latter has to deal with AT and TAB characters in string
13127  28DA             ; expressions. These cannot occur in a program area so this routine is
13128  28DA             ; simpler as both colour controls and their parameters are less than space.
13129  28DA             
13130  28DA             ;; FN-SKPOVR
13131  28DA 23          L28AB:  INC     HL              ; increase pointer
13132  28DB 7E                  LD      A,(HL)          ; fetch addressed character
13133  28DC FE 21               CP      $21             ; compare with space + 1
13134  28DE 38 FA               JR      C,L28AB         ; back to FN-SKPOVR if less
13135  28E0             
13136  28E0 C9                  RET                     ; return pointing to a valid character.
13137  28E1             
13138  28E1             ; ---------
13139  28E1             ; LOOK-VARS
13140  28E1             ; ---------
13141  28E1             ;
13142  28E1             ;
13143  28E1             
13144  28E1             ;; LOOK-VARS
13145  28E1 FD CB 01 F6 L28B2:  SET     6,(IY+$01)      ; update FLAGS - presume numeric result
13146  28E5             
13147  28E5 DF                  RST     18H             ; GET-CHAR
13148  28E6 CD BC 2C            CALL    L2C8D           ; routine ALPHA tests for A-Za-z
13149  28E9 D2 B9 1C            JP      NC,L1C8A        ; jump to REPORT-C if not.
13150  28EC                                             ; 'Nonsense in BASIC'
13151  28EC             
13152  28EC E5                  PUSH    HL              ; save pointer to first letter       ^1
13153  28ED E6 1F               AND     $1F             ; mask lower bits, 1 - 26 decimal     000xxxxx
13154  28EF 4F                  LD      C,A             ; store in C.
13155  28F0             
13156  28F0 E7                  RST     20H             ; NEXT-CHAR
13157  28F1 E5                  PUSH    HL              ; save pointer to second character   ^2
13158  28F2 FE 28               CP      $28             ; is it '(' - an array ?
13159  28F4 28 28               JR      Z,L28EF         ; forward to V-RUN/SYN if so.
13160  28F6             
13161  28F6 CB F1               SET     6,C             ; set 6 signaling string if solitary  010
13162  28F8 FE 24               CP      $24             ; is character a '$' ?
13163  28FA 28 11               JR      Z,L28DE         ; forward to V-STR-VAR
13164  28FC             
13165  28FC CB E9               SET     5,C             ; signal numeric                       011
13166  28FE CD B7 2C            CALL    L2C88           ; routine ALPHANUM sets carry if second
13167  2901                                             ; character is alphanumeric.
13168  2901 30 0F               JR      NC,L28E3        ; forward to V-TEST-FN if just one character
13169  2903             
13170  2903             ; It is more than one character but re-test current character so that 6 reset
13171  2903             ; This loop renders the similar loop at V-PASS redundant.
13172  2903             
13173  2903             ;; V-CHAR
13174  2903 CD B7 2C    L28D4:  CALL    L2C88           ; routine ALPHANUM
13175  2906 30 16               JR      NC,L28EF        ; to V-RUN/SYN when no more
13176  2908             
13177  2908 CB B1               RES     6,C             ; make long named type                 001
13178  290A             
13179  290A E7                  RST     20H             ; NEXT-CHAR
13180  290B 18 F6               JR      L28D4           ; loop back to V-CHAR
13181  290D             
13182  290D             ; ---
13183  290D             
13184  290D             
13185  290D             ;; V-STR-VAR
13186  290D E7          L28DE:  RST     20H             ; NEXT-CHAR advances past '$'
13187  290E FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS - signal string result.
13188  2912             
13189  2912             ;; V-TEST-FN
13190  2912 3A 0C 5C    L28E3:  LD      A,($5C0C)       ; load A with DEFADD_hi
13191  2915 A7                  AND     A               ; and test for zero.
13192  2916 28 06               JR      Z,L28EF         ; forward to V-RUN/SYN if a defined function
13193  2918                                             ; is not being evaluated.
13194  2918             
13195  2918             ; Note.
13196  2918             
13197  2918 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
13198  291B C2 80 29            JP      NZ,L2951        ; JUMP to STK-F-ARG in runtime and then
13199  291E                                             ; back to this point if no variable found.
13200  291E             
13201  291E             ;; V-RUN/SYN
13202  291E 41          L28EF:  LD      B,C             ; save flags in B
13203  291F CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
13204  2922 20 08               JR      NZ,L28FD        ; to V-RUN to look for the variable in runtime
13205  2924             
13206  2924             ; if checking syntax the letter is not returned
13207  2924             
13208  2924 79                  LD      A,C             ; copy letter/flags to A
13209  2925 E6 E0               AND     $E0             ; and with 11100000 to get rid of the letter
13210  2927 CB FF               SET     7,A             ; use spare bit to signal checking syntax.
13211  2929 4F                  LD      C,A             ; and transfer to C.
13212  292A 18 37               JR      L2934           ; forward to V-SYNTAX
13213  292C             
13214  292C             ; ---
13215  292C             
13216  292C             ; but in runtime search for the variable.
13217  292C             
13218  292C             ;; V-RUN
13219  292C 2A 4B 5C    L28FD:  LD      HL,($5C4B)      ; set HL to start of variables from VARS
13220  292F             
13221  292F             ;; V-EACH
13222  292F 7E          L2900:  LD      A,(HL)          ; get first character
13223  2930 E6 7F               AND     $7F             ; and with 01111111
13224  2932                                             ; ignoring bit 7 which distinguishes
13225  2932                                             ; arrays or for/next variables.
13226  2932             
13227  2932 28 2D               JR      Z,L2932         ; to V-80-BYTE if zero as must be 10000000
13228  2934                                             ; the variables end-marker.
13229  2934             
13230  2934 B9                  CP      C               ; compare with supplied value.
13231  2935 20 22               JR      NZ,L292A        ; forward to V-NEXT if no match.
13232  2937             
13233  2937 17                  RLA                     ; destructively test
13234  2938 87                  ADD     A,A             ; bits 5 and 6 of A
13235  2939                                             ; jumping if bit 5 reset or 6 set
13236  2939             
13237  2939 F2 6E 29            JP      P,L293F         ; to V-FOUND-2  strings and arrays
13238  293C             
13239  293C 38 30               JR      C,L293F         ; to V-FOUND-2  simple and for next
13240  293E             
13241  293E             ; leaving long name variables.
13242  293E             
13243  293E D1                  POP     DE              ; pop pointer to 2nd. char
13244  293F D5                  PUSH    DE              ; save it again
13245  2940 E5                  PUSH    HL              ; save variable first character pointer
13246  2941             
13247  2941             ;; V-MATCHES
13248  2941 23          L2912:  INC     HL              ; address next character in vars area
13249  2942             
13250  2942             ;; V-SPACES
13251  2942 1A          L2913:  LD      A,(DE)          ; pick up letter from prog area
13252  2943 13                  INC     DE              ; and advance address
13253  2944 FE 20               CP      $20             ; is it a space
13254  2946 28 FA               JR      Z,L2913         ; back to V-SPACES until non-space
13255  2948             
13256  2948 F6 20               OR      $20             ; convert to range 1 - 26.
13257  294A BE                  CP      (HL)            ; compare with addressed variables character
13258  294B 28 F4               JR      Z,L2912         ; loop back to V-MATCHES if a match on an
13259  294D                                             ; intermediate letter.
13260  294D             
13261  294D F6 80               OR      $80             ; now set bit 7 as last character of long
13262  294F                                             ; names are inverted.
13263  294F BE                  CP      (HL)            ; compare again
13264  2950 20 06               JR      NZ,L2929        ; forward to V-GET-PTR if no match
13265  2952             
13266  2952             ; but if they match check that this is also last letter in prog area
13267  2952             
13268  2952 1A                  LD      A,(DE)          ; fetch next character
13269  2953 CD B7 2C            CALL    L2C88           ; routine ALPHANUM sets carry if not alphanum
13270  2956 30 15               JR      NC,L293E        ; forward to V-FOUND-1 with a full match.
13271  2958             
13272  2958             ;; V-GET-PTR
13273  2958 E1          L2929:  POP     HL              ; pop saved pointer to char 1
13274  2959             
13275  2959             ;; V-NEXT
13276  2959 C5          L292A:  PUSH    BC              ; save flags
13277  295A CD E7 19            CALL    L19B8           ; routine NEXT-ONE gets next variable in DE
13278  295D EB                  EX      DE,HL           ; transfer to HL.
13279  295E C1                  POP     BC              ; restore the flags
13280  295F 18 CE               JR      L2900           ; loop back to V-EACH
13281  2961                                             ; to compare each variable
13282  2961             
13283  2961             ; ---
13284  2961             
13285  2961             ;; V-80-BYTE
13286  2961 CB F8       L2932:  SET     7,B             ; will signal not found
13287  2963             
13288  2963             ; the branch was here when checking syntax
13289  2963             
13290  2963             ;; V-SYNTAX
13291  2963 D1          L2934:  POP     DE              ; discard the pointer to 2nd. character  v2
13292  2964                                             ; in BASIC line/workspace.
13293  2964             
13294  2964 DF                  RST     18H             ; GET-CHAR gets character after variable name.
13295  2965 FE 28               CP      $28             ; is it '(' ?
13296  2967 28 09               JR      Z,L2943         ; forward to V-PASS
13297  2969                                             ; Note. could go straight to V-END ?
13298  2969             
13299  2969 CB E8               SET     5,B             ; signal not an array
13300  296B 18 0D               JR      L294B           ; forward to V-END
13301  296D             
13302  296D             ; ---------------------------
13303  296D             
13304  296D             ; the jump was here when a long name matched and HL pointing to last character
13305  296D             ; in variables area.
13306  296D             
13307  296D             ;; V-FOUND-1
13308  296D D1          L293E:  POP     DE              ; discard pointer to first var letter
13309  296E             
13310  296E             ; the jump was here with all other matches HL points to first var char.
13311  296E             
13312  296E             ;; V-FOUND-2
13313  296E D1          L293F:  POP     DE              ; discard pointer to 2nd prog char       v2
13314  296F D1                  POP     DE              ; drop pointer to 1st prog char          v1
13315  2970 E5                  PUSH    HL              ; save pointer to last char in vars
13316  2971             
13317  2971 DF                  RST     18H             ; GET-CHAR
13318  2972             
13319  2972             ;; V-PASS
13320  2972 CD B7 2C    L2943:  CALL    L2C88           ; routine ALPHANUM
13321  2975 30 03               JR      NC,L294B        ; forward to V-END if not
13322  2977             
13323  2977             ; but it never will be as we advanced past long-named variables earlier.
13324  2977             
13325  2977 E7                  RST     20H             ; NEXT-CHAR
13326  2978 18 F8               JR      L2943           ; back to V-PASS
13327  297A             
13328  297A             ; ---
13329  297A             
13330  297A             ;; V-END
13331  297A E1          L294B:  POP     HL              ; pop the pointer to first character in
13332  297B                                             ; BASIC line/workspace.
13333  297B CB 10               RL      B               ; rotate the B register left
13334  297D                                             ; bit 7 to carry
13335  297D CB 70               BIT     6,B             ; test the array indicator bit.
13336  297F C9                  RET                     ; return
13337  2980             
13338  2980             ; -----------------------
13339  2980             ; Stack function argument
13340  2980             ; -----------------------
13341  2980             ; This branch is taken from LOOK-VARS when a defined function is currently
13342  2980             ; being evaluated.
13343  2980             ; Scanning is evaluating the expression after the '=' and the variable
13344  2980             ; found could be in the argument list to the left of the '=' or in the
13345  2980             ; normal place after the program. Preference will be given to the former.
13346  2980             ; The variable name to be matched is in C.
13347  2980             
13348  2980             ;; STK-F-ARG
13349  2980 2A 0B 5C    L2951:  LD      HL,($5C0B)      ; set HL to DEFADD
13350  2983 7E                  LD      A,(HL)          ; load the first character
13351  2984 FE 29               CP      $29             ; is it ')' ?
13352  2986 CA 1E 29            JP      Z,L28EF         ; JUMP back to V-RUN/SYN, if so, as there are
13353  2989                                             ; no arguments.
13354  2989             
13355  2989             ; but proceed to search argument list of defined function first if not empty.
13356  2989             
13357  2989             ;; SFA-LOOP
13358  2989 7E          L295A:  LD      A,(HL)          ; fetch character again.
13359  298A F6 60               OR      $60             ; or with 01100000 presume a simple variable.
13360  298C 47                  LD      B,A             ; save result in B.
13361  298D 23                  INC     HL              ; address next location.
13362  298E 7E                  LD      A,(HL)          ; pick up byte.
13363  298F FE 0E               CP      $0E             ; is it the number marker ?
13364  2991 28 07               JR      Z,L296B         ; forward to SFA-CP-VR if so.
13365  2993             
13366  2993             ; it was a string. White-space may be present but syntax has been checked.
13367  2993             
13368  2993 2B                  DEC     HL              ; point back to letter.
13369  2994 CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips to the '$'
13370  2997 23                  INC     HL              ; now address the hidden marker.
13371  2998 CB A8               RES     5,B             ; signal a string variable.
13372  299A             
13373  299A             ;; SFA-CP-VR
13374  299A 78          L296B:  LD      A,B             ; transfer found variable letter to A.
13375  299B B9                  CP      C               ; compare with expected.
13376  299C 28 12               JR      Z,L2981         ; forward to SFA-MATCH with a match.
13377  299E             
13378  299E 23                  INC     HL              ; step
13379  299F 23                  INC     HL              ; past
13380  29A0 23                  INC     HL              ; the
13381  29A1 23                  INC     HL              ; five
13382  29A2 23                  INC     HL              ; bytes.
13383  29A3             
13384  29A3 CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips to next character
13385  29A6 FE 29               CP      $29             ; is it ')' ?
13386  29A8 CA 1E 29            JP      Z,L28EF         ; jump back if so to V-RUN/SYN to look in
13387  29AB                                             ; normal variables area.
13388  29AB             
13389  29AB CD DA 28            CALL    L28AB           ; routine FN-SKPOVR skips past the ','
13390  29AE                                             ; all syntax has been checked and these
13391  29AE                                             ; things can be taken as read.
13392  29AE 18 D9               JR      L295A           ; back to SFA-LOOP while there are more
13393  29B0                                             ; arguments.
13394  29B0             
13395  29B0             ; ---
13396  29B0             
13397  29B0             ;; SFA-MATCH
13398  29B0 CB 69       L2981:  BIT     5,C             ; test if numeric
13399  29B2 20 0C               JR      NZ,L2991        ; to SFA-END if so as will be stacked
13400  29B4                                             ; by scanning
13401  29B4             
13402  29B4 23                  INC     HL              ; point to start of string descriptor
13403  29B5 ED 5B 65 5C         LD      DE,($5C65)      ; set DE to STKEND
13404  29B9 CD EF 33            CALL    L33C0           ; routine MOVE-FP puts parameters on stack.
13405  29BC EB                  EX      DE,HL           ; new free location to HL.
13406  29BD 22 65 5C            LD      ($5C65),HL      ; use it to set STKEND system variable.
13407  29C0             
13408  29C0             ;; SFA-END
13409  29C0 D1          L2991:  POP     DE              ; discard
13410  29C1 D1                  POP     DE              ; pointers.
13411  29C2 AF                  XOR     A               ; clear carry flag.
13412  29C3 3C                  INC     A               ; and zero flag.
13413  29C4 C9                  RET                     ; return.
13414  29C5             
13415  29C5             ; ------------------------
13416  29C5             ; Stack variable component
13417  29C5             ; ------------------------
13418  29C5             ; This is called to evaluate a complex structure that has been found, in
13419  29C5             ; runtime, by LOOK-VARS in the variables area.
13420  29C5             ; In this case HL points to the initial letter, bits 7-5
13421  29C5             ; of which indicate the type of variable.
13422  29C5             ; 010 - simple string, 110 - string array, 100 - array of numbers.
13423  29C5             ;
13424  29C5             ; It is called from CLASS-01 when assigning to a string or array including
13425  29C5             ; a slice.
13426  29C5             ; It is called from SCANNING to isolate the required part of the structure.
13427  29C5             ;
13428  29C5             ; An important part of the runtime process is to check that the number of
13429  29C5             ; dimensions of the variable match the number of subscripts supplied in the
13430  29C5             ; BASIC line.
13431  29C5             ;
13432  29C5             ; If checking syntax,
13433  29C5             ; the B register, which counts dimensions is set to zero (256) to allow
13434  29C5             ; the loop to continue till all subscripts are checked. While doing this it
13435  29C5             ; is reading dimension sizes from some arbitrary area of memory. Although
13436  29C5             ; these are meaningless it is of no concern as the limit is never checked by
13437  29C5             ; int-exp during syntax checking.
13438  29C5             ;
13439  29C5             ; The routine is also called from the syntax path of DIM command to check the
13440  29C5             ; syntax of both string and numeric arrays definitions except that bit 6 of C
13441  29C5             ; is reset so both are checked as numeric arrays. This ruse avoids a terminal
13442  29C5             ; slice being accepted as part of the DIM command.
13443  29C5             ; All that is being checked is that there are a valid set of comma-separated
13444  29C5             ; expressions before a terminal ')', although, as above, it will still go
13445  29C5             ; through the motions of checking dummy dimension sizes.
13446  29C5             
13447  29C5             ;; STK-VAR
13448  29C5 AF          L2996:  XOR     A               ; clear A
13449  29C6 47                  LD      B,A             ; and B, the syntax dimension counter (256)
13450  29C7 CB 79               BIT     7,C             ; checking syntax ?
13451  29C9 20 4B               JR      NZ,L29E7        ; forward to SV-COUNT if so.
13452  29CB             
13453  29CB             ; runtime evaluation.
13454  29CB             
13455  29CB CB 7E               BIT     7,(HL)          ; will be reset if a simple string.
13456  29CD 20 0E               JR      NZ,L29AE        ; forward to SV-ARRAYS otherwise
13457  29CF             
13458  29CF 3C                  INC     A               ; set A to 1, simple string.
13459  29D0             
13460  29D0             ;; SV-SIMPLE$
13461  29D0 23          L29A1:  INC     HL              ; address length low
13462  29D1 4E                  LD      C,(HL)          ; place in C
13463  29D2 23                  INC     HL              ; address length high
13464  29D3 46                  LD      B,(HL)          ; place in B
13465  29D4 23                  INC     HL              ; address start of string
13466  29D5 EB                  EX      DE,HL           ; DE = start now.
13467  29D6 CD E1 2A            CALL    L2AB2           ; routine STK-STO-$ stacks string parameters
13468  29D9                                             ; DE start in variables area,
13469  29D9                                             ; BC length, A=1 simple string
13470  29D9             
13471  29D9             ; the only thing now is to consider if a slice is required.
13472  29D9             
13473  29D9 DF                  RST     18H             ; GET-CHAR puts character at CH_ADD in A
13474  29DA C3 78 2A            JP      L2A49           ; jump forward to SV-SLICE? to test for '('
13475  29DD             
13476  29DD             ; --------------------------------------------------------
13477  29DD             
13478  29DD             ; the branch was here with string and numeric arrays in runtime.
13479  29DD             
13480  29DD             ;; SV-ARRAYS
13481  29DD 23          L29AE:  INC     HL              ; step past
13482  29DE 23                  INC     HL              ; the total length
13483  29DF 23                  INC     HL              ; to address Number of dimensions.
13484  29E0 46                  LD      B,(HL)          ; transfer to B overwriting zero.
13485  29E1 CB 71               BIT     6,C             ; a numeric array ?
13486  29E3 28 0A               JR      Z,L29C0         ; forward to SV-PTR with numeric arrays
13487  29E5             
13488  29E5 05                  DEC     B               ; ignore the final element of a string array
13489  29E6                                             ; the fixed string size.
13490  29E6             
13491  29E6 28 E8               JR      Z,L29A1         ; back to SV-SIMPLE$ if result is zero as has
13492  29E8                                             ; been created with DIM a$(10) for instance
13493  29E8                                             ; and can be treated as a simple string.
13494  29E8             
13495  29E8             ; proceed with multi-dimensioned string arrays in runtime.
13496  29E8             
13497  29E8 EB                  EX      DE,HL           ; save pointer to dimensions in DE
13498  29E9             
13499  29E9 DF                  RST     18H             ; GET-CHAR looks at the BASIC line
13500  29EA FE 28               CP      $28             ; is character '(' ?
13501  29EC 20 61               JR      NZ,L2A20        ; to REPORT-3 if not
13502  29EE                                             ; 'Subscript wrong'
13503  29EE             
13504  29EE EB                  EX      DE,HL           ; dimensions pointer to HL to synchronize
13505  29EF                                             ; with next instruction.
13506  29EF             
13507  29EF             ; runtime numeric arrays path rejoins here.
13508  29EF             
13509  29EF             ;; SV-PTR
13510  29EF EB          L29C0:  EX      DE,HL           ; save dimension pointer in DE
13511  29F0 18 24               JR      L29E7           ; forward to SV-COUNT with true no of dims 
13512  29F2                                             ; in B. As there is no initial comma the 
13513  29F2                                             ; loop is entered at the midpoint.
13514  29F2             
13515  29F2             ; ----------------------------------------------------------
13516  29F2             ; the dimension counting loop which is entered at mid-point.
13517  29F2             
13518  29F2             ;; SV-COMMA
13519  29F2 E5          L29C3:  PUSH    HL              ; save counter
13520  29F3             
13521  29F3 DF                  RST     18H             ; GET-CHAR
13522  29F4             
13523  29F4 E1                  POP     HL              ; pop counter
13524  29F5 FE 2C               CP      $2C             ; is character ',' ?
13525  29F7 28 20               JR      Z,L29EA         ; forward to SV-LOOP if so
13526  29F9             
13527  29F9             ; in runtime the variable definition indicates a comma should appear here
13528  29F9             
13529  29F9 CB 79               BIT     7,C             ; checking syntax ?
13530  29FB 28 52               JR      Z,L2A20         ; forward to REPORT-3 if not
13531  29FD                                             ; 'Subscript error'
13532  29FD             
13533  29FD             ; proceed if checking syntax of an array?
13534  29FD             
13535  29FD CB 71               BIT     6,C             ; array of strings
13536  29FF 20 06               JR      NZ,L29D8        ; forward to SV-CLOSE if so
13537  2A01             
13538  2A01             ; an array of numbers.
13539  2A01             
13540  2A01 FE 29               CP      $29             ; is character ')' ?
13541  2A03 20 3C               JR      NZ,L2A12        ; forward to SV-RPT-C if not
13542  2A05                                             ; 'Nonsense in BASIC'
13543  2A05             
13544  2A05 E7                  RST     20H             ; NEXT-CHAR moves CH-ADD past the statement
13545  2A06 C9                  RET                     ; return ->
13546  2A07             
13547  2A07             ; ---
13548  2A07             
13549  2A07             ; the branch was here with an array of strings.
13550  2A07             
13551  2A07             ;; SV-CLOSE
13552  2A07 FE 29       L29D8:  CP      $29             ; as above ')' could follow the expression
13553  2A09 28 6C               JR      Z,L2A48         ; forward to SV-DIM if so
13554  2A0B             
13555  2A0B FE CC               CP      $CC             ; is it 'TO' ?
13556  2A0D 20 32               JR      NZ,L2A12        ; to SV-RPT-C with anything else
13557  2A0F                                             ; 'Nonsense in BASIC'
13558  2A0F             
13559  2A0F             ; now backtrack CH_ADD to set up for slicing routine.
13560  2A0F             ; Note. in a BASIC line we can safely backtrack to a colour parameter.
13561  2A0F             
13562  2A0F             ;; SV-CH-ADD
13563  2A0F DF          L29E0:  RST     18H             ; GET-CHAR
13564  2A10 2B                  DEC     HL              ; backtrack HL
13565  2A11 22 5D 5C            LD      ($5C5D),HL      ; to set CH_ADD up for slicing routine
13566  2A14 18 5E               JR      L2A45           ; forward to SV-SLICE and make a return
13567  2A16                                             ; when all slicing complete.
13568  2A16             
13569  2A16             ; ----------------------------------------
13570  2A16             ; -> the mid-point entry point of the loop
13571  2A16             
13572  2A16             ;; SV-COUNT
13573  2A16 21 00 00    L29E7:  LD      HL,$0000        ; initialize data pointer to zero.
13574  2A19             
13575  2A19             ;; SV-LOOP
13576  2A19 E5          L29EA:  PUSH    HL              ; save the data pointer.
13577  2A1A             
13578  2A1A E7                  RST     20H             ; NEXT-CHAR in BASIC area points to an
13579  2A1B                                             ; expression.
13580  2A1B             
13581  2A1B E1                  POP     HL              ; restore the data pointer.
13582  2A1C 79                  LD      A,C             ; transfer name/type to A.
13583  2A1D FE C0               CP      $C0             ; is it 11000000 ?
13584  2A1F                                             ; Note. the letter component is absent if
13585  2A1F                                             ; syntax checking.
13586  2A1F 20 09               JR      NZ,L29FB        ; forward to SV-MULT if not an array of
13587  2A21                                             ; strings.
13588  2A21             
13589  2A21             ; proceed to check string arrays during syntax.
13590  2A21             
13591  2A21 DF                  RST     18H             ; GET-CHAR
13592  2A22 FE 29               CP      $29             ; ')'  end of subscripts ?
13593  2A24 28 51               JR      Z,L2A48         ; forward to SV-DIM to consider further slice
13594  2A26             
13595  2A26 FE CC               CP      $CC             ; is it 'TO' ?
13596  2A28 28 E5               JR      Z,L29E0         ; back to SV-CH-ADD to consider a slice.
13597  2A2A                                             ; (no need to repeat get-char at L29E0)
13598  2A2A             
13599  2A2A             ; if neither, then an expression is required so rejoin runtime loop ??
13600  2A2A             ; registers HL and DE only point to somewhere meaningful in runtime so 
13601  2A2A             ; comments apply to that situation.
13602  2A2A             
13603  2A2A             ;; SV-MULT
13604  2A2A C5          L29FB:  PUSH    BC              ; save dimension number.
13605  2A2B E5                  PUSH    HL              ; push data pointer/rubbish.
13606  2A2C                                             ; DE points to current dimension.
13607  2A2C CD 1D 2B            CALL    L2AEE           ; routine DE,(DE+1) gets next dimension in DE
13608  2A2F                                             ; and HL points to it.
13609  2A2F E3                  EX      (SP),HL         ; dim pointer to stack, data pointer to HL (*)
13610  2A30 EB                  EX      DE,HL           ; data pointer to DE, dim size to HL.
13611  2A31             
13612  2A31 CD FB 2A            CALL    L2ACC           ; routine INT-EXP1 checks integer expression
13613  2A34                                             ; and gets result in BC in runtime.
13614  2A34 38 19               JR      C,L2A20         ; to REPORT-3 if > HL
13615  2A36                                             ; 'Subscript out of range'
13616  2A36             
13617  2A36 0B                  DEC     BC              ; adjust returned result from 1-x to 0-x
13618  2A37 CD 23 2B            CALL    L2AF4           ; routine GET-HL*DE multiplies data pointer by
13619  2A3A                                             ; dimension size.
13620  2A3A 09                  ADD     HL,BC           ; add the integer returned by expression.
13621  2A3B D1                  POP     DE              ; pop the dimension pointer.                              ***
13622  2A3C C1                  POP     BC              ; pop dimension counter.
13623  2A3D 10 B3               DJNZ    L29C3           ; back to SV-COMMA if more dimensions
13624  2A3F                                             ; Note. during syntax checking, unless there
13625  2A3F                                             ; are more than 256 subscripts, the branch
13626  2A3F                                             ; back to SV-COMMA is always taken.
13627  2A3F             
13628  2A3F CB 79               BIT     7,C             ; are we checking syntax ?
13629  2A41                                             ; then we've got a joker here.
13630  2A41             
13631  2A41             ;; SV-RPT-C
13632  2A41 20 66       L2A12:  JR      NZ,L2A7A        ; forward to SL-RPT-C if so
13633  2A43                                             ; 'Nonsense in BASIC'
13634  2A43                                             ; more than 256 subscripts in BASIC line.
13635  2A43             
13636  2A43             ; but in runtime the number of subscripts are at least the same as dims
13637  2A43             
13638  2A43 E5                  PUSH    HL              ; save data pointer.
13639  2A44 CB 71               BIT     6,C             ; is it a string array ?
13640  2A46 20 13               JR      NZ,L2A2C        ; forward to SV-ELEM$ if so.
13641  2A48             
13642  2A48             ; a runtime numeric array subscript.
13643  2A48             
13644  2A48 42                  LD      B,D             ; register DE has advanced past all dimensions
13645  2A49 4B                  LD      C,E             ; and points to start of data in variable.
13646  2A4A                                             ; transfer it to BC.
13647  2A4A             
13648  2A4A DF                  RST     18H             ; GET-CHAR checks BASIC line
13649  2A4B FE 29               CP      $29             ; must be a ')' ?
13650  2A4D 28 02               JR      Z,L2A22         ; skip to SV-NUMBER if so
13651  2A4F             
13652  2A4F             ; else more subscripts in BASIC line than the variable definition.
13653  2A4F             
13654  2A4F             ;; REPORT-3
13655  2A4F CF          L2A20:  RST     08H             ; ERROR-1
13656  2A50 02                  DEFB    $02             ; Error Report: Subscript wrong
13657  2A51             
13658  2A51             ; continue if subscripts matched the numeric array.
13659  2A51             
13660  2A51             ;; SV-NUMBER
13661  2A51 E7          L2A22:  RST     20H             ; NEXT-CHAR moves CH_ADD to next statement
13662  2A52                                             ; - finished parsing.
13663  2A52             
13664  2A52 E1                  POP     HL              ; pop the data pointer.
13665  2A53 11 05 00            LD      DE,$0005        ; each numeric element is 5 bytes.
13666  2A56 CD 23 2B            CALL    L2AF4           ; routine GET-HL*DE multiplies.
13667  2A59 09                  ADD     HL,BC           ; now add to start of data in the variable.
13668  2A5A             
13669  2A5A C9                  RET                     ; return with HL pointing at the numeric
13670  2A5B                                             ; array subscript.                       ->
13671  2A5B             
13672  2A5B             ; ---------------------------------------------------------------
13673  2A5B             
13674  2A5B             ; the branch was here for string subscripts when the number of subscripts
13675  2A5B             ; in the BASIC line was one less than in variable definition.
13676  2A5B             
13677  2A5B             ;; SV-ELEM$
13678  2A5B CD 1D 2B    L2A2C:  CALL    L2AEE           ; routine DE,(DE+1) gets final dimension
13679  2A5E                                             ; the length of strings in this array.
13680  2A5E E3                  EX      (SP),HL         ; start pointer to stack, data pointer to HL.
13681  2A5F CD 23 2B            CALL    L2AF4           ; routine GET-HL*DE multiplies by element
13682  2A62                                             ; size.
13683  2A62 C1                  POP     BC              ; the start of data pointer is added
13684  2A63 09                  ADD     HL,BC           ; in - now points to location before.
13685  2A64 23                  INC     HL              ; point to start of required string.
13686  2A65 42                  LD      B,D             ; transfer the length (final dimension size)
13687  2A66 4B                  LD      C,E             ; from DE to BC.
13688  2A67 EB                  EX      DE,HL           ; put start in DE.
13689  2A68 CD E0 2A            CALL    L2AB1           ; routine STK-ST-0 stores the string parameters
13690  2A6B                                             ; with A=0 - a slice or subscript.
13691  2A6B             
13692  2A6B             ; now check that there were no more subscripts in the BASIC line.
13693  2A6B             
13694  2A6B DF                  RST     18H             ; GET-CHAR
13695  2A6C FE 29               CP      $29             ; is it ')' ?
13696  2A6E 28 07               JR      Z,L2A48         ; forward to SV-DIM to consider a separate
13697  2A70                                             ; subscript or/and a slice.
13698  2A70             
13699  2A70 FE 2C               CP      $2C             ; a comma is allowed if the final subscript
13700  2A72                                             ; is to be sliced e.g. a$(2,3,4 TO 6).
13701  2A72 20 DB               JR      NZ,L2A20        ; to REPORT-3 with anything else
13702  2A74                                             ; 'Subscript error'
13703  2A74             
13704  2A74             ;; SV-SLICE
13705  2A74 CD 81 2A    L2A45:  CALL    L2A52           ; routine SLICING slices the string.
13706  2A77             
13707  2A77             ; but a slice of a simple string can itself be sliced.
13708  2A77             
13709  2A77             ;; SV-DIM
13710  2A77 E7          L2A48:  RST     20H             ; NEXT-CHAR
13711  2A78             
13712  2A78             ;; SV-SLICE?
13713  2A78 FE 28       L2A49:  CP      $28             ; is character '(' ?
13714  2A7A 28 F8               JR      Z,L2A45         ; loop back if so to SV-SLICE
13715  2A7C             
13716  2A7C FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS  - Signal string result
13717  2A80 C9                  RET                     ; and return.
13718  2A81             
13719  2A81             ; ---
13720  2A81             
13721  2A81             ; The above section deals with the flexible syntax allowed.
13722  2A81             ; DIM a$(3,3,10) can be considered as two dimensional array of ten-character
13723  2A81             ; strings or a 3-dimensional array of characters.
13724  2A81             ; a$(1,1) will return a 10-character string as will a$(1,1,1 TO 10)
13725  2A81             ; a$(1,1,1) will return a single character.
13726  2A81             ; a$(1,1) (1 TO 6) is the same as a$(1,1,1 TO 6)
13727  2A81             ; A slice can itself be sliced ad infinitum
13728  2A81             ; b$ () () () () () () (2 TO 10) (2 TO 9) (3) is the same as b$(5)
13729  2A81             
13730  2A81             
13731  2A81             
13732  2A81             ; -------------------------
13733  2A81             ; Handle slicing of strings
13734  2A81             ; -------------------------
13735  2A81             ; The syntax of string slicing is very natural and it is as well to reflect
13736  2A81             ; on the permutations possible.
13737  2A81             ; a$() and a$( TO ) indicate the entire string although just a$ would do
13738  2A81             ; and would avoid coming here.
13739  2A81             ; h$(16) indicates the single character at position 16.
13740  2A81             ; a$( TO 32) indicates the first 32 characters.
13741  2A81             ; a$(257 TO) indicates all except the first 256 characters.
13742  2A81             ; a$(19000 TO 19999) indicates the thousand characters at position 19000.
13743  2A81             ; Also a$(9 TO 5) returns a null string not an error.
13744  2A81             ; This enables a$(2 TO) to return a null string if the passed string is
13745  2A81             ; of length zero or 1.
13746  2A81             ; A string expression in brackets can be sliced. e.g. (STR$ PI) (3 TO )
13747  2A81             ; We arrived here from SCANNING with CH-ADD pointing to the initial '('
13748  2A81             ; or from above.
13749  2A81             
13750  2A81             ;; SLICING
13751  2A81 CD 5F 25    L2A52:  CALL    L2530           ; routine SYNTAX-Z
13752  2A84 C4 20 2C            CALL    NZ,L2BF1        ; routine STK-FETCH fetches parameters of
13753  2A87                                             ; string at runtime, start in DE, length 
13754  2A87                                             ; in BC. This could be an array subscript.
13755  2A87             
13756  2A87 E7                  RST     20H             ; NEXT-CHAR
13757  2A88 FE 29               CP      $29             ; is it ')' ?     e.g. a$()
13758  2A8A 28 50               JR      Z,L2AAD         ; forward to SL-STORE to store entire string.
13759  2A8C             
13760  2A8C D5                  PUSH    DE              ; else save start address of string
13761  2A8D             
13762  2A8D AF                  XOR     A               ; clear accumulator to use as a running flag.
13763  2A8E F5                  PUSH    AF              ; and save on stack before any branching.
13764  2A8F             
13765  2A8F C5                  PUSH    BC              ; save length of string to be sliced.
13766  2A90 11 01 00            LD      DE,$0001        ; default the start point to position 1.
13767  2A93             
13768  2A93 DF                  RST     18H             ; GET-CHAR
13769  2A94             
13770  2A94 E1                  POP     HL              ; pop length to HL as default end point
13771  2A95                                             ; and limit.
13772  2A95             
13773  2A95 FE CC               CP      $CC             ; is it 'TO' ?    e.g. a$( TO 10000)
13774  2A97 28 17               JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter.
13775  2A99             
13776  2A99 F1                  POP     AF              ; pop the running flag.
13777  2A9A             
13778  2A9A CD FC 2A            CALL    L2ACD           ; routine INT-EXP2 fetches first parameter.
13779  2A9D             
13780  2A9D F5                  PUSH    AF              ; save flag (will be $FF if parameter>limit)
13781  2A9E             
13782  2A9E 50                  LD      D,B             ; transfer the start
13783  2A9F 59                  LD      E,C             ; to DE overwriting 0001.
13784  2AA0 E5                  PUSH    HL              ; save original length.
13785  2AA1             
13786  2AA1 DF                  RST     18H             ; GET-CHAR
13787  2AA2 E1                  POP     HL              ; pop the limit length.
13788  2AA3 FE CC               CP      $CC             ; is it 'TO' after a start ?
13789  2AA5 28 09               JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter
13790  2AA7             
13791  2AA7 FE 29               CP      $29             ; is it ')' ?       e.g. a$(365)
13792  2AA9             
13793  2AA9             ;; SL-RPT-C
13794  2AA9 C2 B9 1C    L2A7A:  JP      NZ,L1C8A        ; jump to REPORT-C with anything else
13795  2AAC                                             ; 'Nonsense in BASIC'
13796  2AAC             
13797  2AAC 62                  LD      H,D             ; copy start
13798  2AAD 6B                  LD      L,E             ; to end - just a one character slice.
13799  2AAE 18 13               JR      L2A94           ; forward to SL-DEFINE.
13800  2AB0             
13801  2AB0             ; ---------------------
13802  2AB0             
13803  2AB0             ;; SL-SECOND
13804  2AB0 E5          L2A81:  PUSH    HL              ; save limit length.
13805  2AB1             
13806  2AB1 E7                  RST     20H             ; NEXT-CHAR
13807  2AB2             
13808  2AB2 E1                  POP     HL              ; pop the length.
13809  2AB3             
13810  2AB3 FE 29               CP      $29             ; is character ')' ?        e.g. a$(7 TO )
13811  2AB5 28 0C               JR      Z,L2A94         ; to SL-DEFINE using length as end point.
13812  2AB7             
13813  2AB7 F1                  POP     AF              ; else restore flag.
13814  2AB8 CD FC 2A            CALL    L2ACD           ; routine INT-EXP2 gets second expression.
13815  2ABB             
13816  2ABB F5                  PUSH    AF              ; save the running flag.
13817  2ABC             
13818  2ABC DF                  RST     18H             ; GET-CHAR
13819  2ABD             
13820  2ABD 60                  LD      H,B             ; transfer second parameter
13821  2ABE 69                  LD      L,C             ; to HL.              e.g. a$(42 to 99)
13822  2ABF FE 29               CP      $29             ; is character a ')' ?
13823  2AC1 20 E6               JR      NZ,L2A7A        ; to SL-RPT-C if not
13824  2AC3                                             ; 'Nonsense in BASIC'
13825  2AC3             
13826  2AC3             ; we now have start in DE and an end in HL.
13827  2AC3             
13828  2AC3             ;; SL-DEFINE
13829  2AC3 F1          L2A94:  POP     AF              ; pop the running flag.
13830  2AC4 E3                  EX      (SP),HL         ; put end point on stack, start address to HL
13831  2AC5 19                  ADD     HL,DE           ; add address of string to the start point.
13832  2AC6 2B                  DEC     HL              ; point to first character of slice.
13833  2AC7 E3                  EX      (SP),HL         ; start address to stack, end point to HL (*)
13834  2AC8 A7                  AND     A               ; prepare to subtract.
13835  2AC9 ED 52               SBC     HL,DE           ; subtract start point from end point.
13836  2ACB 01 00 00            LD      BC,$0000        ; default the length result to zero.
13837  2ACE 38 07               JR      C,L2AA8         ; forward to SL-OVER if start > end.
13838  2AD0             
13839  2AD0 23                  INC     HL              ; increment the length for inclusive byte.
13840  2AD1             
13841  2AD1 A7                  AND     A               ; now test the running flag.
13842  2AD2 FA 4F 2A            JP      M,L2A20         ; jump back to REPORT-3 if $FF.
13843  2AD5                                             ; 'Subscript out of range'
13844  2AD5             
13845  2AD5 44                  LD      B,H             ; transfer the length
13846  2AD6 4D                  LD      C,L             ; to BC.
13847  2AD7             
13848  2AD7             ;; SL-OVER
13849  2AD7 D1          L2AA8:  POP     DE              ; restore start address from machine stack ***
13850  2AD8 FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS - signal string result for
13851  2ADC                                             ; syntax.
13852  2ADC             
13853  2ADC             ;; SL-STORE
13854  2ADC CD 5F 25    L2AAD:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
13855  2ADF C8                  RET     Z               ; return if checking syntax.
13856  2AE0                                             ; but continue to store the string in runtime.
13857  2AE0             
13858  2AE0             ; ------------------------------------
13859  2AE0             ; other than from above, this routine is called from STK-VAR to stack
13860  2AE0             ; a known string array element.
13861  2AE0             ; ------------------------------------
13862  2AE0             
13863  2AE0             ;; STK-ST-0
13864  2AE0 AF          L2AB1:  XOR     A               ; clear to signal a sliced string or element.
13865  2AE1             
13866  2AE1             ; -------------------------
13867  2AE1             ; this routine is called from chr$, scrn$ etc. to store a simple string result.
13868  2AE1             ; --------------------------
13869  2AE1             
13870  2AE1             ;; STK-STO-$
13871  2AE1 FD CB 01 B6 L2AB2:  RES     6,(IY+$01)      ; update FLAGS - signal string result.
13872  2AE5                                             ; and continue to store parameters of string.
13873  2AE5             
13874  2AE5             ; ---------------------------------------
13875  2AE5             ; Pass five registers to calculator stack
13876  2AE5             ; ---------------------------------------
13877  2AE5             ; This subroutine puts five registers on the calculator stack.
13878  2AE5             
13879  2AE5             ;; STK-STORE
13880  2AE5 C5          L2AB6:  PUSH    BC              ; save two registers
13881  2AE6 CD D8 33            CALL    L33A9           ; routine TEST-5-SP checks room and puts 5 
13882  2AE9                                             ; in BC.
13883  2AE9 C1                  POP     BC              ; fetch the saved registers.
13884  2AEA 2A 65 5C            LD      HL,($5C65)      ; make HL point to first empty location STKEND
13885  2AED 77                  LD      (HL),A          ; place the 5 registers.
13886  2AEE 23                  INC     HL              ;
13887  2AEF 73                  LD      (HL),E          ;
13888  2AF0 23                  INC     HL              ;
13889  2AF1 72                  LD      (HL),D          ;
13890  2AF2 23                  INC     HL              ;
13891  2AF3 71                  LD      (HL),C          ;
13892  2AF4 23                  INC     HL              ;
13893  2AF5 70                  LD      (HL),B          ;
13894  2AF6 23                  INC     HL              ;
13895  2AF7 22 65 5C            LD      ($5C65),HL      ; update system variable STKEND.
13896  2AFA C9                  RET                     ; and return.
13897  2AFB             
13898  2AFB             ; -------------------------------------------
13899  2AFB             ; Return result of evaluating next expression
13900  2AFB             ; -------------------------------------------
13901  2AFB             ; This clever routine is used to check and evaluate an integer expression
13902  2AFB             ; which is returned in BC, setting A to $FF, if greater than a limit supplied
13903  2AFB             ; in HL. It is used to check array subscripts, parameters of a string slice
13904  2AFB             ; and the arguments of the DIM command. In the latter case, the limit check
13905  2AFB             ; is not required and H is set to $FF. When checking optional string slice
13906  2AFB             ; parameters, it is entered at the second entry point so as not to disturb
13907  2AFB             ; the running flag A, which may be $00 or $FF from a previous invocation.
13908  2AFB             
13909  2AFB             ;; INT-EXP1
13910  2AFB AF          L2ACC:  XOR     A               ; set result flag to zero.
13911  2AFC             
13912  2AFC             ; -> The entry point is here if A is used as a running flag.
13913  2AFC             
13914  2AFC             ;; INT-EXP2
13915  2AFC D5          L2ACD:  PUSH    DE              ; preserve DE register throughout.
13916  2AFD E5                  PUSH    HL              ; save the supplied limit.
13917  2AFE F5                  PUSH    AF              ; save the flag.
13918  2AFF             
13919  2AFF CD B1 1C            CALL    L1C82           ; routine EXPT-1NUM evaluates expression
13920  2B02                                             ; at CH_ADD returning if numeric result,
13921  2B02                                             ; with value on calculator stack.
13922  2B02             
13923  2B02 F1                  POP     AF              ; pop the flag.
13924  2B03 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
13925  2B06 28 12               JR      Z,L2AEB         ; forward to I-RESTORE if checking syntax so
13926  2B08                                             ; avoiding a comparison with supplied limit.
13927  2B08             
13928  2B08 F5                  PUSH    AF              ; save the flag.
13929  2B09             
13930  2B09 CD C8 1E            CALL    L1E99           ; routine FIND-INT2 fetches value from
13931  2B0C                                             ; calculator stack to BC producing an error
13932  2B0C                                             ; if too high.
13933  2B0C             
13934  2B0C D1                  POP     DE              ; pop the flag to D.
13935  2B0D 78                  LD      A,B             ; test value for zero and reject
13936  2B0E B1                  OR      C               ; as arrays and strings begin at 1.
13937  2B0F 37                  SCF                     ; set carry flag.
13938  2B10 28 05               JR      Z,L2AE8         ; forward to I-CARRY if zero.
13939  2B12             
13940  2B12 E1                  POP     HL              ; restore the limit.
13941  2B13 E5                  PUSH    HL              ; and save.
13942  2B14 A7                  AND     A               ; prepare to subtract.
13943  2B15 ED 42               SBC     HL,BC           ; subtract value from limit.
13944  2B17             
13945  2B17             ;; I-CARRY
13946  2B17 7A          L2AE8:  LD      A,D             ; move flag to accumulator $00 or $FF.
13947  2B18 DE 00               SBC     A,$00           ; will set to $FF if carry set.
13948  2B1A             
13949  2B1A             ;; I-RESTORE
13950  2B1A E1          L2AEB:  POP     HL              ; restore the limit.
13951  2B1B D1                  POP     DE              ; and DE register.
13952  2B1C C9                  RET                     ; return.
13953  2B1D             
13954  2B1D             
13955  2B1D             ; -----------------------
13956  2B1D             ; LD DE,(DE+1) Subroutine
13957  2B1D             ; -----------------------
13958  2B1D             ; This routine just loads the DE register with the contents of the two
13959  2B1D             ; locations following the location addressed by DE.
13960  2B1D             ; It is used to step along the 16-bit dimension sizes in array definitions.
13961  2B1D             ; Note. Such code is made into subroutines to make programs easier to
13962  2B1D             ; write and it would use less space to include the five instructions in-line.
13963  2B1D             ; However, there are so many exchanges going on at the places this is invoked
13964  2B1D             ; that to implement it in-line would make the code hard to follow.
13965  2B1D             ; It probably had a zippier label though as the intention is to simplify the
13966  2B1D             ; program.
13967  2B1D             
13968  2B1D             ;; DE,(DE+1)
13969  2B1D EB          L2AEE:  EX      DE,HL           ;
13970  2B1E 23                  INC     HL              ;
13971  2B1F 5E                  LD      E,(HL)          ;
13972  2B20 23                  INC     HL              ;
13973  2B21 56                  LD      D,(HL)          ;
13974  2B22 C9                  RET                     ;
13975  2B23             
13976  2B23             ; -------------------
13977  2B23             ; HL=HL*DE Subroutine
13978  2B23             ; -------------------
13979  2B23             ; This routine calls the mathematical routine to multiply HL by DE in runtime.
13980  2B23             ; It is called from STK-VAR and from DIM. In the latter case syntax is not
13981  2B23             ; being checked so the entry point could have been at the second CALL
13982  2B23             ; instruction to save a few clock-cycles.
13983  2B23             
13984  2B23             ;; GET-HL*DE
13985  2B23 CD 5F 25    L2AF4:  CALL    L2530           ; routine SYNTAX-Z.
13986  2B26 C8                  RET     Z               ; return if checking syntax.
13987  2B27             
13988  2B27 CD D8 30            CALL    L30A9           ; routine HL-HL*DE.
13989  2B2A DA 44 1F            JP      C,L1F15         ; jump back to REPORT-4 if over 65535.
13990  2B2D             
13991  2B2D C9                  RET                     ; else return with 16-bit result in HL.
13992  2B2E             
13993  2B2E             ; -----------------
13994  2B2E             ; THE 'LET' COMMAND
13995  2B2E             ; -----------------
13996  2B2E             ; Sinclair BASIC adheres to the ANSI-78 standard and a LET is required in
13997  2B2E             ; assignments e.g. LET a = 1  :   LET h$ = "hat".
13998  2B2E             ;
13999  2B2E             ; Long names may contain spaces but not colour controls (when assigned).
14000  2B2E             ; a substring can appear to the left of the equals sign.
14001  2B2E             
14002  2B2E             ; An earlier mathematician Lewis Carroll may have been pleased that
14003  2B2E             ; 10 LET Babies cannot manage crocodiles = Babies are illogical AND
14004  2B2E             ;    Nobody is despised who can manage a crocodile AND Illogical persons
14005  2B2E             ;    are despised
14006  2B2E             ; does not give the 'Nonsense..' error if the three variables exist.
14007  2B2E             ; I digress.
14008  2B2E             
14009  2B2E             ;; LET
14010  2B2E 2A 4D 5C    L2AFF:  LD      HL,($5C4D)      ; fetch system variable DEST to HL.
14011  2B31 FD CB 37 4E         BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
14012  2B35 28 5E               JR      Z,L2B66         ; forward to L-EXISTS if not.
14013  2B37             
14014  2B37             ; continue for a new variable. DEST points to start in BASIC line.
14015  2B37             ; from the CLASS routines.
14016  2B37             
14017  2B37 01 05 00            LD      BC,$0005        ; assume numeric and assign an initial 5 bytes
14018  2B3A             
14019  2B3A             ;; L-EACH-CH
14020  2B3A 03          L2B0B:  INC     BC              ; increase byte count for each relevant
14021  2B3B                                             ; character
14022  2B3B             
14023  2B3B             ;; L-NO-SP
14024  2B3B 23          L2B0C:  INC     HL              ; increase pointer.
14025  2B3C 7E                  LD      A,(HL)          ; fetch character.
14026  2B3D FE 20               CP      $20             ; is it a space ?
14027  2B3F 28 FA               JR      Z,L2B0C         ; back to L-NO-SP is so.
14028  2B41             
14029  2B41 30 0B               JR      NC,L2B1F        ; forward to L-TEST-CH if higher.
14030  2B43             
14031  2B43 FE 10               CP      $10             ; is it $00 - $0F ?
14032  2B45 38 11               JR      C,L2B29         ; forward to L-SPACES if so.
14033  2B47             
14034  2B47 FE 16               CP      $16             ; is it $16 - $1F ?
14035  2B49 30 0D               JR      NC,L2B29        ; forward to L-SPACES if so.
14036  2B4B             
14037  2B4B             ; it was $10 - $15  so step over a colour code.
14038  2B4B             
14039  2B4B 23                  INC     HL              ; increase pointer.
14040  2B4C 18 ED               JR      L2B0C           ; loop back to L-NO-SP.
14041  2B4E             
14042  2B4E             ; ---
14043  2B4E             
14044  2B4E             ; the branch was to here if higher than space.
14045  2B4E             
14046  2B4E             ;; L-TEST-CH
14047  2B4E CD B7 2C    L2B1F:  CALL    L2C88           ; routine ALPHANUM sets carry if alphanumeric
14048  2B51 38 E7               JR      C,L2B0B         ; loop back to L-EACH-CH for more if so.
14049  2B53             
14050  2B53 FE 24               CP      $24             ; is it '$' ?
14051  2B55 CA EF 2B            JP      Z,L2BC0         ; jump forward if so, to L-NEW$
14052  2B58                                             ; with a new string.
14053  2B58             
14054  2B58             ;; L-SPACES
14055  2B58 79          L2B29:  LD      A,C             ; save length lo in A.
14056  2B59 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE to HL.
14057  2B5C 2B                  DEC     HL              ; point to location before, the variables
14058  2B5D                                             ; end-marker.
14059  2B5D CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates BC spaces
14060  2B60                                             ; for name and numeric value.
14061  2B60 23                  INC     HL              ; advance to first new location.
14062  2B61 23                  INC     HL              ; then to second.
14063  2B62 EB                  EX      DE,HL           ; set DE to second location.
14064  2B63 D5                  PUSH    DE              ; save this pointer.
14065  2B64 2A 4D 5C            LD      HL,($5C4D)      ; reload HL with DEST.
14066  2B67 1B                  DEC     DE              ; point to first.
14067  2B68 D6 06               SUB     $06             ; subtract six from length_lo.
14068  2B6A 47                  LD      B,A             ; save count in B.
14069  2B6B 28 11               JR      Z,L2B4F         ; forward to L-SINGLE if it was just
14070  2B6D                                             ; one character.
14071  2B6D             
14072  2B6D             ; HL points to start of variable name after 'LET' in BASIC line.
14073  2B6D             
14074  2B6D             ;; L-CHAR
14075  2B6D 23          L2B3E:  INC     HL              ; increase pointer.
14076  2B6E 7E                  LD      A,(HL)          ; pick up character.
14077  2B6F FE 21               CP      $21             ; is it space or higher ?
14078  2B71 38 FA               JR      C,L2B3E         ; back to L-CHAR with space and less.
14079  2B73             
14080  2B73 F6 20               OR      $20             ; make variable lower-case.
14081  2B75 13                  INC     DE              ; increase destination pointer.
14082  2B76 12                  LD      (DE),A          ; and load to edit line.
14083  2B77 10 F4               DJNZ    L2B3E           ; loop back to L-CHAR until B is zero.
14084  2B79             
14085  2B79 F6 80               OR      $80             ; invert the last character.
14086  2B7B 12                  LD      (DE),A          ; and overwrite that in edit line.
14087  2B7C             
14088  2B7C             ; now consider first character which has bit 6 set
14089  2B7C             
14090  2B7C 3E C0               LD      A,$C0           ; set A 11000000 is xor mask for a long name.
14091  2B7E                                             ; %101      is xor/or  result
14092  2B7E             
14093  2B7E             ; single character numerics rejoin here with %00000000 in mask.
14094  2B7E             ;                                            %011      will be xor/or result
14095  2B7E             
14096  2B7E             ;; L-SINGLE
14097  2B7E 2A 4D 5C    L2B4F:  LD      HL,($5C4D)      ; fetch DEST - HL addresses first character.
14098  2B81 AE                  XOR     (HL)            ; apply variable type indicator mask (above).
14099  2B82 F6 20               OR      $20             ; make lowercase - set bit 5.
14100  2B84 E1                  POP     HL              ; restore pointer to 2nd character.
14101  2B85 CD 19 2C            CALL    L2BEA           ; routine L-FIRST puts A in first character.
14102  2B88                                             ; and returns with HL holding
14103  2B88                                             ; new E_LINE-1  the $80 vars end-marker.
14104  2B88             
14105  2B88             ;; L-NUMERIC
14106  2B88 E5          L2B59:  PUSH    HL              ; save the pointer.
14107  2B89             
14108  2B89             ; the value of variable is deleted but remains after calculator stack.
14109  2B89             
14110  2B89 EF                  RST     28H             ;; FP-CALC
14111  2B8A 02                  DEFB    $02             ;;delete      ; delete variable value
14112  2B8B 38                  DEFB    $38             ;;end-calc
14113  2B8C             
14114  2B8C             ; DE (STKEND) points to start of value.
14115  2B8C             
14116  2B8C E1                  POP     HL              ; restore the pointer.
14117  2B8D 01 05 00            LD      BC,$0005        ; start of number is five bytes before.
14118  2B90 A7                  AND     A               ; prepare for true subtraction.
14119  2B91 ED 42               SBC     HL,BC           ; HL points to start of value.
14120  2B93 18 40               JR      L2BA6           ; forward to L-ENTER  ==>
14121  2B95             
14122  2B95             ; ---
14123  2B95             
14124  2B95             
14125  2B95             ; the jump was to here if the variable already existed.
14126  2B95             
14127  2B95             ;; L-EXISTS
14128  2B95 FD CB 01 76 L2B66:  BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
14129  2B99 28 06               JR      Z,L2B72         ; skip forward to L-DELETE$   -*->
14130  2B9B                                             ; if string result.
14131  2B9B             
14132  2B9B             ; A numeric variable could be simple or an array element.
14133  2B9B             ; They are treated the same and the old value is overwritten.
14134  2B9B             
14135  2B9B 11 06 00            LD      DE,$0006        ; six bytes forward points to loc past value.
14136  2B9E 19                  ADD     HL,DE           ; add to start of number.
14137  2B9F 18 E7               JR      L2B59           ; back to L-NUMERIC to overwrite value.
14138  2BA1             
14139  2BA1             ; ---
14140  2BA1             
14141  2BA1             ; -*-> the branch was here if a string existed.
14142  2BA1             
14143  2BA1             ;; L-DELETE$
14144  2BA1 2A 4D 5C    L2B72:  LD      HL,($5C4D)      ; fetch DEST to HL.
14145  2BA4                                             ; (still set from first instruction)
14146  2BA4 ED 4B 72 5C         LD      BC,($5C72)      ; fetch STRLEN to BC.
14147  2BA8 FD CB 37 46         BIT     0,(IY+$37)      ; test FLAGX - handling a complete simple
14148  2BAC                                             ; string ?
14149  2BAC 20 30               JR      NZ,L2BAF        ; forward to L-ADD$ if so.
14150  2BAE             
14151  2BAE             ; must be a string array or a slice in workspace.
14152  2BAE             ; Note. LET a$(3 TO 6) = h$   will assign "hat " if h$ = "hat"
14153  2BAE             ;                                  and    "hats" if h$ = "hatstand".
14154  2BAE             ;
14155  2BAE             ; This is known as Procrustean lengthening and shortening after a
14156  2BAE             ; character Procrustes in Greek legend who made travellers sleep in his bed,
14157  2BAE             ; cutting off their feet or stretching them so they fitted the bed perfectly.
14158  2BAE             ; The bloke was hatstand and slain by Theseus.
14159  2BAE             
14160  2BAE 78                  LD      A,B             ; test if length
14161  2BAF B1                  OR      C               ; is zero and
14162  2BB0 C8                  RET     Z               ; return if so.
14163  2BB1             
14164  2BB1 E5                  PUSH    HL              ; save pointer to start.
14165  2BB2             
14166  2BB2 F7                  RST     30H             ; BC-SPACES creates room.
14167  2BB3 D5                  PUSH    DE              ; save pointer to first new location.
14168  2BB4 C5                  PUSH    BC              ; and length            (*)
14169  2BB5 54                  LD      D,H             ; set DE to point to last location.
14170  2BB6 5D                  LD      E,L             ;
14171  2BB7 23                  INC     HL              ; set HL to next location.
14172  2BB8 36 20               LD      (HL),$20        ; place a space there.
14173  2BBA ED B8               LDDR                    ; copy bytes filling with spaces.
14174  2BBC             
14175  2BBC E5                  PUSH    HL              ; save pointer to start.
14176  2BBD CD 20 2C            CALL    L2BF1           ; routine STK-FETCH start to DE,
14177  2BC0                                             ; length to BC.
14178  2BC0 E1                  POP     HL              ; restore the pointer.
14179  2BC1 E3                  EX      (SP),HL         ; (*) length to HL, pointer to stack.
14180  2BC2 A7                  AND     A               ; prepare for true subtraction.
14181  2BC3 ED 42               SBC     HL,BC           ; subtract old length from new.
14182  2BC5 09                  ADD     HL,BC           ; and add back.
14183  2BC6 30 02               JR      NC,L2B9B        ; forward if it fits to L-LENGTH.
14184  2BC8             
14185  2BC8 44                  LD      B,H             ; otherwise set
14186  2BC9 4D                  LD      C,L             ; length to old length.
14187  2BCA                                             ; "hatstand" becomes "hats"
14188  2BCA             
14189  2BCA             ;; L-LENGTH
14190  2BCA E3          L2B9B:  EX      (SP),HL         ; (*) length to stack, pointer to HL.
14191  2BCB EB                  EX      DE,HL           ; pointer to DE, start of string to HL.
14192  2BCC 78                  LD      A,B             ; is the length zero ?
14193  2BCD B1                  OR      C               ;
14194  2BCE 28 02               JR      Z,L2BA3         ; forward to L-IN-W/S if so
14195  2BD0                                             ; leaving prepared spaces.
14196  2BD0             
14197  2BD0 ED B0               LDIR                    ; else copy bytes overwriting some spaces.
14198  2BD2             
14199  2BD2             ;; L-IN-W/S
14200  2BD2 C1          L2BA3:  POP     BC              ; pop the new length.  (*)
14201  2BD3 D1                  POP     DE              ; pop pointer to new area.
14202  2BD4 E1                  POP     HL              ; pop pointer to variable in assignment.
14203  2BD5                                             ; and continue copying from workspace
14204  2BD5                                             ; to variables area.
14205  2BD5             
14206  2BD5             ; ==> branch here from  L-NUMERIC
14207  2BD5             
14208  2BD5             ;; L-ENTER
14209  2BD5 EB          L2BA6:  EX      DE,HL           ; exchange pointers HL=STKEND DE=end of vars.
14210  2BD6 78                  LD      A,B             ; test the length
14211  2BD7 B1                  OR      C               ; and make a 
14212  2BD8 C8                  RET     Z               ; return if zero (strings only).
14213  2BD9             
14214  2BD9 D5                  PUSH    DE              ; save start of destination.
14215  2BDA ED B0               LDIR                    ; copy bytes.
14216  2BDC E1                  POP     HL              ; address the start.
14217  2BDD C9                  RET                     ; and return.
14218  2BDE             
14219  2BDE             ; ---
14220  2BDE             
14221  2BDE             ; the branch was here from L-DELETE$ if an existing simple string.
14222  2BDE             ; register HL addresses start of string in variables area.
14223  2BDE             
14224  2BDE             ;; L-ADD$
14225  2BDE 2B          L2BAF:  DEC     HL              ; point to high byte of length.
14226  2BDF 2B                  DEC     HL              ; to low byte.
14227  2BE0 2B                  DEC     HL              ; to letter.
14228  2BE1 7E                  LD      A,(HL)          ; fetch masked letter to A.
14229  2BE2 E5                  PUSH    HL              ; save the pointer on stack.
14230  2BE3 C5                  PUSH    BC              ; save new length.
14231  2BE4 CD F5 2B            CALL    L2BC6           ; routine L-STRING adds new string at end
14232  2BE7                                             ; of variables area.
14233  2BE7                                             ; if no room we still have old one.
14234  2BE7 C1                  POP     BC              ; restore length.
14235  2BE8 E1                  POP     HL              ; restore start.
14236  2BE9 03                  INC     BC              ; increase
14237  2BEA 03                  INC     BC              ; length by three
14238  2BEB 03                  INC     BC              ; to include character and length bytes.
14239  2BEC C3 17 1A            JP      L19E8           ; jump to indirect exit via RECLAIM-2
14240  2BEF                                             ; deleting old version and adjusting pointers.
14241  2BEF             
14242  2BEF             ; ---
14243  2BEF             
14244  2BEF             ; the jump was here with a new string variable.
14245  2BEF             
14246  2BEF             ;; L-NEW$
14247  2BEF 3E DF       L2BC0:  LD      A,$DF           ; indicator mask %11011111 for
14248  2BF1                                             ;                %010xxxxx will be result
14249  2BF1 2A 4D 5C            LD      HL,($5C4D)      ; address DEST first character.
14250  2BF4 A6                  AND     (HL)            ; combine mask with character.
14251  2BF5             
14252  2BF5             ;; L-STRING
14253  2BF5 F5          L2BC6:  PUSH    AF              ; save first character and mask.
14254  2BF6 CD 20 2C            CALL    L2BF1           ; routine STK-FETCH fetches parameters of
14255  2BF9                                             ; the string.
14256  2BF9 EB                  EX      DE,HL           ; transfer start to HL.
14257  2BFA 09                  ADD     HL,BC           ; add to length.
14258  2BFB C5                  PUSH    BC              ; save the length.
14259  2BFC 2B                  DEC     HL              ; point to end of string.
14260  2BFD 22 4D 5C            LD      ($5C4D),HL      ; save pointer in DEST.
14261  2C00                                             ; (updated by POINTERS if in workspace)
14262  2C00 03                  INC     BC              ; extra byte for letter.
14263  2C01 03                  INC     BC              ; two bytes
14264  2C02 03                  INC     BC              ; for the length of string.
14265  2C03 2A 59 5C            LD      HL,($5C59)      ; address E_LINE.
14266  2C06 2B                  DEC     HL              ; now end of VARS area.
14267  2C07 CD 84 16            CALL    L1655           ; routine MAKE-ROOM makes room for string.
14268  2C0A                                             ; updating pointers including DEST.
14269  2C0A 2A 4D 5C            LD      HL,($5C4D)      ; pick up pointer to end of string from DEST.
14270  2C0D C1                  POP     BC              ; restore length from stack.
14271  2C0E C5                  PUSH    BC              ; and save again on stack.
14272  2C0F 03                  INC     BC              ; add a byte.
14273  2C10 ED B8               LDDR                    ; copy bytes from end to start.
14274  2C12 EB                  EX      DE,HL           ; HL addresses length low
14275  2C13 23                  INC     HL              ; increase to address high byte
14276  2C14 C1                  POP     BC              ; restore length to BC
14277  2C15 70                  LD      (HL),B          ; insert high byte
14278  2C16 2B                  DEC     HL              ; address low byte location
14279  2C17 71                  LD      (HL),C          ; insert that byte
14280  2C18 F1                  POP     AF              ; restore character and mask
14281  2C19             
14282  2C19             ;; L-FIRST
14283  2C19 2B          L2BEA:  DEC     HL              ; address variable name
14284  2C1A 77                  LD      (HL),A          ; and insert character.
14285  2C1B 2A 59 5C            LD      HL,($5C59)      ; load HL with E_LINE.
14286  2C1E 2B                  DEC     HL              ; now end of VARS area.
14287  2C1F C9                  RET                     ; return
14288  2C20             
14289  2C20             ; ------------------------------------
14290  2C20             ; Get last value from calculator stack
14291  2C20             ; ------------------------------------
14292  2C20             ;
14293  2C20             ;
14294  2C20             
14295  2C20             ;; STK-FETCH
14296  2C20 2A 65 5C    L2BF1:  LD      HL,($5C65)      ; STKEND
14297  2C23 2B                  DEC     HL              ;
14298  2C24 46                  LD      B,(HL)          ;
14299  2C25 2B                  DEC     HL              ;
14300  2C26 4E                  LD      C,(HL)          ;
14301  2C27 2B                  DEC     HL              ;
14302  2C28 56                  LD      D,(HL)          ;
14303  2C29 2B                  DEC     HL              ;
14304  2C2A 5E                  LD      E,(HL)          ;
14305  2C2B 2B                  DEC     HL              ;
14306  2C2C 7E                  LD      A,(HL)          ;
14307  2C2D 22 65 5C            LD      ($5C65),HL      ; STKEND
14308  2C30 C9                  RET                     ;
14309  2C31             
14310  2C31             ; ------------------
14311  2C31             ; Handle DIM command
14312  2C31             ; ------------------
14313  2C31             ; e.g. DIM a(2,3,4,7): DIM a$(32) : DIM b$(20,2,768) : DIM c$(20000)
14314  2C31             ; the only limit to dimensions is memory so, for example,
14315  2C31             ; DIM a(2,2,2,2,2,2,2,2,2,2,2,2,2) is possible and creates a multi-
14316  2C31             ; dimensional array of zeros. String arrays are initialized to spaces.
14317  2C31             ; It is not possible to erase an array, but it can be re-dimensioned to
14318  2C31             ; a minimal size of 1, after use, to free up memory.
14319  2C31             
14320  2C31             ;; DIM
14321  2C31 CD E1 28    L2C02:  CALL    L28B2           ; routine LOOK-VARS
14322  2C34             
14323  2C34             ;; D-RPORT-C
14324  2C34 C2 B9 1C    L2C05:  JP      NZ,L1C8A        ; jump to REPORT-C if a long-name variable.
14325  2C37                                             ; DIM lottery numbers(49) doesn't work.
14326  2C37             
14327  2C37 CD 5F 25            CALL    L2530           ; routine SYNTAX-Z
14328  2C3A 20 08               JR      NZ,L2C15        ; forward to D-RUN in runtime.
14329  2C3C             
14330  2C3C CB B1               RES     6,C             ; signal 'numeric' array even if string as
14331  2C3E                                             ; this simplifies the syntax checking.
14332  2C3E             
14333  2C3E CD C5 29            CALL    L2996           ; routine STK-VAR checks syntax.
14334  2C41 CD 1D 1C            CALL    L1BEE           ; routine CHECK-END performs early exit ->
14335  2C44             
14336  2C44             ; the branch was here in runtime.
14337  2C44             
14338  2C44             ;; D-RUN
14339  2C44 38 08       L2C15:  JR      C,L2C1F         ; skip to D-LETTER if variable did not exist.
14340  2C46                                             ; else reclaim the old one.
14341  2C46             
14342  2C46 C5                  PUSH    BC              ; save type in C.
14343  2C47 CD E7 19            CALL    L19B8           ; routine NEXT-ONE find following variable
14344  2C4A                                             ; or position of $80 end-marker.
14345  2C4A CD 17 1A            CALL    L19E8           ; routine RECLAIM-2 reclaims the 
14346  2C4D                                             ; space between.
14347  2C4D C1                  POP     BC              ; pop the type.
14348  2C4E             
14349  2C4E             ;; D-LETTER
14350  2C4E CB F9       L2C1F:  SET     7,C             ; signal array.
14351  2C50 06 00               LD      B,$00           ; initialize dimensions to zero and
14352  2C52 C5                  PUSH    BC              ; save with the type.
14353  2C53 21 01 00            LD      HL,$0001        ; make elements one character presuming string
14354  2C56 CB 71               BIT     6,C             ; is it a string ?
14355  2C58 20 02               JR      NZ,L2C2D        ; forward to D-SIZE if so.
14356  2C5A             
14357  2C5A 2E 05               LD      L,$05           ; make elements 5 bytes as is numeric.
14358  2C5C             
14359  2C5C             ;; D-SIZE
14360  2C5C EB          L2C2D:  EX      DE,HL           ; save the element size in DE.
14361  2C5D             
14362  2C5D             ; now enter a loop to parse each of the integers in the list.
14363  2C5D             
14364  2C5D             ;; D-NO-LOOP
14365  2C5D E7          L2C2E:  RST     20H             ; NEXT-CHAR
14366  2C5E 26 FF               LD      H,$FF           ; disable limit check by setting HL high
14367  2C60 CD FB 2A            CALL    L2ACC           ; routine INT-EXP1
14368  2C63 DA 4F 2A            JP      C,L2A20         ; to REPORT-3 if > 65280 and then some
14369  2C66                                             ; 'Subscript out of range'
14370  2C66             
14371  2C66 E1                  POP     HL              ; pop dimension counter, array type
14372  2C67 C5                  PUSH    BC              ; save dimension size                     ***
14373  2C68 24                  INC     H               ; increment the dimension counter
14374  2C69 E5                  PUSH    HL              ; save the dimension counter
14375  2C6A 60                  LD      H,B             ; transfer size
14376  2C6B 69                  LD      L,C             ; to HL
14377  2C6C CD 23 2B            CALL    L2AF4           ; routine GET-HL*DE multiplies dimension by
14378  2C6F                                             ; running total of size required initially
14379  2C6F                                             ; 1 or 5.
14380  2C6F EB                  EX      DE,HL           ; save running total in DE
14381  2C70             
14382  2C70 DF                  RST     18H             ; GET-CHAR
14383  2C71 FE 2C               CP      $2C             ; is it ',' ?
14384  2C73 28 E8               JR      Z,L2C2E         ; loop back to D-NO-LOOP until all dimensions
14385  2C75                                             ; have been considered
14386  2C75             
14387  2C75             ; when loop complete continue.
14388  2C75             
14389  2C75 FE 29               CP      $29             ; is it ')' ?
14390  2C77 20 BB               JR      NZ,L2C05        ; to D-RPORT-C with anything else
14391  2C79                                             ; 'Nonsense in BASIC'
14392  2C79             
14393  2C79             
14394  2C79 E7                  RST     20H             ; NEXT-CHAR advances to next statement/CR
14395  2C7A             
14396  2C7A C1                  POP     BC              ; pop dimension counter/type
14397  2C7B 79                  LD      A,C             ; type to A
14398  2C7C             
14399  2C7C             ; now calculate space required for array variable
14400  2C7C             
14401  2C7C 68                  LD      L,B             ; dimensions to L since these require 16 bits
14402  2C7D                                             ; then this value will be doubled
14403  2C7D 26 00               LD      H,$00           ; set high byte to zero
14404  2C7F             
14405  2C7F             ; another four bytes are required for letter(1), total length(2), number of
14406  2C7F             ; dimensions(1) but since we have yet to double allow for two
14407  2C7F             
14408  2C7F 23                  INC     HL              ; increment
14409  2C80 23                  INC     HL              ; increment
14410  2C81             
14411  2C81 29                  ADD     HL,HL           ; now double giving 4 + dimensions * 2
14412  2C82             
14413  2C82 19                  ADD     HL,DE           ; add to space required for array contents
14414  2C83             
14415  2C83 DA 44 1F            JP      C,L1F15         ; to REPORT-4 if > 65535
14416  2C86                                             ; 'Out of memory'
14417  2C86             
14418  2C86 D5                  PUSH    DE              ; save data space
14419  2C87 C5                  PUSH    BC              ; save dimensions/type
14420  2C88 E5                  PUSH    HL              ; save total space
14421  2C89 44                  LD      B,H             ; total space
14422  2C8A 4D                  LD      C,L             ; to BC
14423  2C8B 2A 59 5C            LD      HL,($5C59)      ; address E_LINE - first location after
14424  2C8E                                             ; variables area
14425  2C8E 2B                  DEC     HL              ; point to location before - the $80 end-marker
14426  2C8F CD 84 16            CALL    L1655           ; routine MAKE-ROOM creates the space if
14427  2C92                                             ; memory is available.
14428  2C92             
14429  2C92 23                  INC     HL              ; point to first new location and
14430  2C93 77                  LD      (HL),A          ; store letter/type
14431  2C94             
14432  2C94 C1                  POP     BC              ; pop total space
14433  2C95 0B                  DEC     BC              ; exclude name
14434  2C96 0B                  DEC     BC              ; exclude the 16-bit
14435  2C97 0B                  DEC     BC              ; counter itself
14436  2C98 23                  INC     HL              ; point to next location the 16-bit counter
14437  2C99 71                  LD      (HL),C          ; insert low byte
14438  2C9A 23                  INC     HL              ; address next
14439  2C9B 70                  LD      (HL),B          ; insert high byte
14440  2C9C             
14441  2C9C C1                  POP     BC              ; pop the number of dimensions.
14442  2C9D 78                  LD      A,B             ; dimensions to A
14443  2C9E 23                  INC     HL              ; address next
14444  2C9F 77                  LD      (HL),A          ; and insert "No. of dims"
14445  2CA0             
14446  2CA0 62                  LD      H,D             ; transfer DE space + 1 from make-room
14447  2CA1 6B                  LD      L,E             ; to HL
14448  2CA2 1B                  DEC     DE              ; set DE to next location down.
14449  2CA3 36 00               LD      (HL),$00        ; presume numeric and insert a zero
14450  2CA5 CB 71               BIT     6,C             ; test bit 6 of C. numeric or string ?
14451  2CA7 28 02               JR      Z,L2C7C         ; skip to DIM-CLEAR if numeric
14452  2CA9             
14453  2CA9 36 20               LD      (HL),$20        ; place a space character in HL
14454  2CAB             
14455  2CAB             ;; DIM-CLEAR
14456  2CAB C1          L2C7C:  POP     BC              ; pop the data length
14457  2CAC             
14458  2CAC ED B8               LDDR                    ; LDDR sets to zeros or spaces
14459  2CAE             
14460  2CAE             ; The number of dimensions is still in A.
14461  2CAE             ; A loop is now entered to insert the size of each dimension that was pushed
14462  2CAE             ; during the D-NO-LOOP working downwards from position before start of data.
14463  2CAE             
14464  2CAE             ;; DIM-SIZES
14465  2CAE C1          L2C7F:  POP     BC              ; pop a dimension size                    ***
14466  2CAF 70                  LD      (HL),B          ; insert high byte at position
14467  2CB0 2B                  DEC     HL              ; next location down
14468  2CB1 71                  LD      (HL),C          ; insert low byte
14469  2CB2 2B                  DEC     HL              ; next location down
14470  2CB3 3D                  DEC     A               ; decrement dimension counter
14471  2CB4 20 F8               JR      NZ,L2C7F        ; back to DIM-SIZES until all done.
14472  2CB6             
14473  2CB6 C9                  RET                     ; return.
14474  2CB7             
14475  2CB7             ; -----------------------------
14476  2CB7             ; Check whether digit or letter
14477  2CB7             ; -----------------------------
14478  2CB7             ; This routine checks that the character in A is alphanumeric
14479  2CB7             ; returning with carry set if so.
14480  2CB7             
14481  2CB7             ;; ALPHANUM
14482  2CB7 CD 4A 2D    L2C88:  CALL    L2D1B           ; routine NUMERIC will reset carry if so.
14483  2CBA 3F                  CCF                     ; Complement Carry Flag
14484  2CBB D8                  RET     C               ; Return if numeric else continue into
14485  2CBC                                             ; next routine.
14486  2CBC             
14487  2CBC             ; This routine checks that the character in A is alphabetic
14488  2CBC             
14489  2CBC             ;; ALPHA
14490  2CBC FE 41       L2C8D:  CP      $41             ; less than 'A' ?
14491  2CBE 3F                  CCF                     ; Complement Carry Flag
14492  2CBF D0                  RET     NC              ; return if so
14493  2CC0             
14494  2CC0 FE 5B               CP      $5B             ; less than 'Z'+1 ?
14495  2CC2 D8                  RET     C               ; is within first range
14496  2CC3             
14497  2CC3 FE 61               CP      $61             ; less than 'a' ?
14498  2CC5 3F                  CCF                     ; Complement Carry Flag
14499  2CC6 D0                  RET     NC              ; return if so.
14500  2CC7             
14501  2CC7 FE 7B               CP      $7B             ; less than 'z'+1 ?
14502  2CC9 C9                  RET                     ; carry set if within a-z.
14503  2CCA             
14504  2CCA             ; -------------------------
14505  2CCA             ; Decimal to floating point
14506  2CCA             ; -------------------------
14507  2CCA             ; This routine finds the floating point number represented by an expression
14508  2CCA             ; beginning with BIN, '.' or a digit.
14509  2CCA             ; Note that BIN need not have any '0's or '1's after it.
14510  2CCA             ; BIN is really just a notational symbol and not a function.
14511  2CCA             
14512  2CCA             ;; DEC-TO-FP
14513  2CCA FE C4       L2C9B:  CP      $C4             ; 'BIN' token ?
14514  2CCC 20 19               JR      NZ,L2CB8        ; to NOT-BIN if not
14515  2CCE             
14516  2CCE 11 00 00            LD      DE,$0000        ; initialize 16 bit buffer register.
14517  2CD1             
14518  2CD1             ;; BIN-DIGIT
14519  2CD1 E7          L2CA2:  RST     20H             ; NEXT-CHAR
14520  2CD2 D6 31               SUB     $31             ; '1'
14521  2CD4 CE 00               ADC     A,$00           ; will be zero if '1' or '0'
14522  2CD6                                             ; carry will be set if was '0'
14523  2CD6 20 0A               JR      NZ,L2CB3        ; forward to BIN-END if result not zero
14524  2CD8             
14525  2CD8 EB                  EX      DE,HL           ; buffer to HL
14526  2CD9 3F                  CCF                     ; Carry now set if originally '1'
14527  2CDA ED 6A               ADC     HL,HL           ; shift the carry into HL
14528  2CDC DA DC 31            JP      C,L31AD         ; to REPORT-6 if overflow - too many digits
14529  2CDF                                             ; after first '1'. There can be an unlimited
14530  2CDF                                             ; number of leading zeros.
14531  2CDF                                             ; 'Number too big' - raise an error
14532  2CDF             
14533  2CDF EB                  EX      DE,HL           ; save the buffer
14534  2CE0 18 EF               JR      L2CA2           ; back to BIN-DIGIT for more digits
14535  2CE2             
14536  2CE2             ; ---
14537  2CE2             
14538  2CE2             ;; BIN-END
14539  2CE2 42          L2CB3:  LD      B,D             ; transfer 16 bit buffer
14540  2CE3 4B                  LD      C,E             ; to BC register pair.
14541  2CE4 C3 5A 2D            JP      L2D2B           ; JUMP to STACK-BC to put on calculator stack
14542  2CE7             
14543  2CE7             ; ---
14544  2CE7             
14545  2CE7             ; continue here with .1,  42, 3.14, 5., 2.3 E -4
14546  2CE7             
14547  2CE7             ;; NOT-BIN
14548  2CE7 FE 2E       L2CB8:  CP      $2E             ; '.' - leading decimal point ?
14549  2CE9 28 0F               JR      Z,L2CCB         ; skip to DECIMAL if so.
14550  2CEB             
14551  2CEB CD 6A 2D            CALL    L2D3B           ; routine INT-TO-FP to evaluate all digits
14552  2CEE                                             ; This number 'x' is placed on stack.
14553  2CEE FE 2E               CP      $2E             ; '.' - mid decimal point ?
14554  2CF0             
14555  2CF0 20 28               JR      NZ,L2CEB        ; to E-FORMAT if not to consider that format
14556  2CF2             
14557  2CF2 E7                  RST     20H             ; NEXT-CHAR
14558  2CF3 CD 4A 2D            CALL    L2D1B           ; routine NUMERIC returns carry reset if 0-9
14559  2CF6             
14560  2CF6 38 22               JR      C,L2CEB         ; to E-FORMAT if not a digit e.g. '1.'
14561  2CF8             
14562  2CF8 18 0A               JR      L2CD5           ; to DEC-STO-1 to add the decimal part to 'x'
14563  2CFA             
14564  2CFA             ; ---
14565  2CFA             
14566  2CFA             ; a leading decimal point has been found in a number.
14567  2CFA             
14568  2CFA             ;; DECIMAL
14569  2CFA E7          L2CCB:  RST     20H             ; NEXT-CHAR
14570  2CFB CD 4A 2D            CALL    L2D1B           ; routine NUMERIC will reset carry if digit
14571  2CFE             
14572  2CFE             ;; DEC-RPT-C
14573  2CFE DA B9 1C    L2CCF:  JP      C,L1C8A         ; to REPORT-C if just a '.'
14574  2D01                                             ; raise 'Nonsense in BASIC'
14575  2D01             
14576  2D01             ; since there is no leading zero put one on the calculator stack.
14577  2D01             
14578  2D01 EF                  RST     28H             ;; FP-CALC
14579  2D02 A0                  DEFB    $A0             ;;stk-zero  ; 0.
14580  2D03 38                  DEFB    $38             ;;end-calc
14581  2D04             
14582  2D04             ; If rejoining from earlier there will be a value 'x' on stack.
14583  2D04             ; If continuing from above the value zero.
14584  2D04             ; Now store 1 in mem-0.
14585  2D04             ; Note. At each pass of the digit loop this will be divided by ten.
14586  2D04             
14587  2D04             ;; DEC-STO-1
14588  2D04 EF          L2CD5:  RST     28H             ;; FP-CALC
14589  2D05 A1                  DEFB    $A1             ;;stk-one   ;x or 0,1.
14590  2D06 C0                  DEFB    $C0             ;;st-mem-0  ;x or 0,1.
14591  2D07 02                  DEFB    $02             ;;delete    ;x or 0.
14592  2D08 38                  DEFB    $38             ;;end-calc
14593  2D09             
14594  2D09             
14595  2D09             ;; NXT-DGT-1
14596  2D09 DF          L2CDA:  RST     18H             ; GET-CHAR
14597  2D0A CD 51 2D            CALL    L2D22           ; routine STK-DIGIT stacks single digit 'd'
14598  2D0D 38 0B               JR      C,L2CEB         ; exit to E-FORMAT when digits exhausted  >
14599  2D0F             
14600  2D0F             
14601  2D0F EF                  RST     28H             ;; FP-CALC   ;x or 0,d.           first pass.
14602  2D10 E0                  DEFB    $E0             ;;get-mem-0  ;x or 0,d,1.
14603  2D11 A4                  DEFB    $A4             ;;stk-ten    ;x or 0,d,1,10.
14604  2D12 05                  DEFB    $05             ;;division   ;x or 0,d,1/10.
14605  2D13 C0                  DEFB    $C0             ;;st-mem-0   ;x or 0,d,1/10.
14606  2D14 04                  DEFB    $04             ;;multiply   ;x or 0,d/10.
14607  2D15 0F                  DEFB    $0F             ;;addition   ;x or 0 + d/10.
14608  2D16 38                  DEFB    $38             ;;end-calc   last value.
14609  2D17             
14610  2D17 E7                  RST     20H             ; NEXT-CHAR  moves to next character
14611  2D18 18 EF               JR      L2CDA           ; back to NXT-DGT-1
14612  2D1A             
14613  2D1A             ; ---
14614  2D1A             
14615  2D1A             ; although only the first pass is shown it can be seen that at each pass
14616  2D1A             ; the new less significant digit is multiplied by an increasingly smaller
14617  2D1A             ; factor (1/100, 1/1000, 1/10000 ... ) before being added to the previous
14618  2D1A             ; last value to form a new last value.
14619  2D1A             
14620  2D1A             ; Finally see if an exponent has been input.
14621  2D1A             
14622  2D1A             ;; E-FORMAT
14623  2D1A FE 45       L2CEB:  CP      $45             ; is character 'E' ?
14624  2D1C 28 03               JR      Z,L2CF2         ; to SIGN-FLAG if so
14625  2D1E             
14626  2D1E FE 65               CP      $65             ; 'e' is acceptable as well.
14627  2D20 C0                  RET     NZ              ; return as no exponent.
14628  2D21             
14629  2D21             ;; SIGN-FLAG
14630  2D21 06 FF       L2CF2:  LD      B,$FF           ; initialize temporary sign byte to $FF
14631  2D23             
14632  2D23 E7                  RST     20H             ; NEXT-CHAR
14633  2D24 FE 2B               CP      $2B             ; is character '+' ?
14634  2D26 28 05               JR      Z,L2CFE         ; to SIGN-DONE
14635  2D28             
14636  2D28 FE 2D               CP      $2D             ; is character '-' ?
14637  2D2A 20 02               JR      NZ,L2CFF        ; to ST-E-PART as no sign
14638  2D2C             
14639  2D2C 04                  INC     B               ; set sign to zero
14640  2D2D             
14641  2D2D             ; now consider digits of exponent.
14642  2D2D             ; Note. incidentally this is the only occasion in Spectrum BASIC when an
14643  2D2D             ; expression may not be used when a number is expected.
14644  2D2D             
14645  2D2D             ;; SIGN-DONE
14646  2D2D E7          L2CFE:  RST     20H             ; NEXT-CHAR
14647  2D2E             
14648  2D2E             ;; ST-E-PART
14649  2D2E CD 4A 2D    L2CFF:  CALL    L2D1B           ; routine NUMERIC
14650  2D31 38 CB               JR      C,L2CCF         ; to DEC-RPT-C if not
14651  2D33                                             ; raise 'Nonsense in BASIC'.
14652  2D33             
14653  2D33 C5                  PUSH    BC              ; save sign (in B)
14654  2D34 CD 6A 2D            CALL    L2D3B           ; routine INT-TO-FP places exponent on stack
14655  2D37 CD 04 2E            CALL    L2DD5           ; routine FP-TO-A  transfers it to A
14656  2D3A C1                  POP     BC              ; restore sign
14657  2D3B DA DC 31            JP      C,L31AD         ; to REPORT-6 if overflow (over 255)
14658  2D3E                                             ; raise 'Number too big'.
14659  2D3E             
14660  2D3E A7                  AND     A               ; set flags
14661  2D3F FA DC 31            JP      M,L31AD         ; to REPORT-6 if over '127'.
14662  2D42                                             ; raise 'Number too big'.
14663  2D42                                             ; 127 is still way too high and it is
14664  2D42                                             ; impossible to enter an exponent greater
14665  2D42                                             ; than 39 from the keyboard. The error gets
14666  2D42                                             ; raised later in E-TO-FP so two different
14667  2D42                                             ; error messages depending how high A is.
14668  2D42             
14669  2D42 04                  INC     B               ; $FF to $00 or $00 to $01 - expendable now.
14670  2D43 28 02               JR      Z,L2D18         ; forward to E-FP-JUMP if exponent positive
14671  2D45             
14672  2D45 ED 44               NEG                     ; Negate the exponent.
14673  2D47             
14674  2D47             ;; E-FP-JUMP
14675  2D47 C3 7E 2D    L2D18:  JP      L2D4F           ; JUMP forward to E-TO-FP to assign to
14676  2D4A                                             ; last value x on stack x * 10 to power A
14677  2D4A                                             ; a relative jump would have done.
14678  2D4A             
14679  2D4A             ; ---------------------
14680  2D4A             ; Check for valid digit
14681  2D4A             ; ---------------------
14682  2D4A             ; This routine checks that the ASCII character in A is numeric
14683  2D4A             ; returning with carry reset if so.
14684  2D4A             
14685  2D4A             ;; NUMERIC
14686  2D4A FE 30       L2D1B:  CP      $30             ; '0'
14687  2D4C D8                  RET     C               ; return if less than zero character.
14688  2D4D             
14689  2D4D FE 3A               CP      $3A             ; The upper test is '9'
14690  2D4F 3F                  CCF                     ; Complement Carry Flag
14691  2D50 C9                  RET                     ; Return - carry clear if character '0' - '9'
14692  2D51             
14693  2D51             ; -----------
14694  2D51             ; Stack Digit
14695  2D51             ; -----------
14696  2D51             ; This subroutine is called from INT-TO-FP and DEC-TO-FP to stack a digit
14697  2D51             ; on the calculator stack.
14698  2D51             
14699  2D51             ;; STK-DIGIT
14700  2D51 CD 4A 2D    L2D22:  CALL    L2D1B           ; routine NUMERIC
14701  2D54 D8                  RET     C               ; return if not numeric character
14702  2D55             
14703  2D55 D6 30               SUB     $30             ; convert from ASCII to digit
14704  2D57             
14705  2D57             ; -----------------
14706  2D57             ; Stack accumulator
14707  2D57             ; -----------------
14708  2D57             ;
14709  2D57             ;
14710  2D57             
14711  2D57             ;; STACK-A
14712  2D57 4F          L2D28:  LD      C,A             ; transfer to C
14713  2D58 06 00               LD      B,$00           ; and make B zero
14714  2D5A             
14715  2D5A             ; ----------------------
14716  2D5A             ; Stack BC register pair
14717  2D5A             ; ----------------------
14718  2D5A             ;
14719  2D5A             
14720  2D5A             ;; STACK-BC
14721  2D5A FD 21 3A 5C L2D2B:  LD      IY,$5C3A        ; re-initialize ERR_NR
14722  2D5E             
14723  2D5E AF                  XOR     A               ; clear to signal small integer
14724  2D5F 5F                  LD      E,A             ; place in E for sign
14725  2D60 51                  LD      D,C             ; LSB to D
14726  2D61 48                  LD      C,B             ; MSB to C
14727  2D62 47                  LD      B,A             ; last byte not used
14728  2D63 CD E5 2A            CALL    L2AB6           ; routine STK-STORE
14729  2D66             
14730  2D66 EF                  RST     28H             ;; FP-CALC
14731  2D67 38                  DEFB    $38             ;;end-calc  make HL = STKEND-5
14732  2D68             
14733  2D68 A7                  AND     A               ; clear carry
14734  2D69 C9                  RET                     ; before returning
14735  2D6A             
14736  2D6A             ; -------------------------
14737  2D6A             ; Integer to floating point
14738  2D6A             ; -------------------------
14739  2D6A             ; This routine places one or more digits found in a BASIC line
14740  2D6A             ; on the calculator stack multiplying the previous value by ten each time
14741  2D6A             ; before adding in the new digit to form a last value on calculator stack.
14742  2D6A             
14743  2D6A             ;; INT-TO-FP
14744  2D6A F5          L2D3B:  PUSH    AF              ; save first character
14745  2D6B             
14746  2D6B EF                  RST     28H             ;; FP-CALC
14747  2D6C A0                  DEFB    $A0             ;;stk-zero    ; v=0. initial value
14748  2D6D 38                  DEFB    $38             ;;end-calc
14749  2D6E             
14750  2D6E F1                  POP     AF              ; fetch first character back.
14751  2D6F             
14752  2D6F             ;; NXT-DGT-2
14753  2D6F CD 51 2D    L2D40:  CALL    L2D22           ; routine STK-DIGIT puts 0-9 on stack
14754  2D72 D8                  RET     C               ; will return when character is not numeric >
14755  2D73             
14756  2D73 EF                  RST     28H             ;; FP-CALC    ; v, d.
14757  2D74 01                  DEFB    $01             ;;exchange    ; d, v.
14758  2D75 A4                  DEFB    $A4             ;;stk-ten     ; d, v, 10.
14759  2D76 04                  DEFB    $04             ;;multiply    ; d, v*10.
14760  2D77 0F                  DEFB    $0F             ;;addition    ; d + v*10 = newvalue
14761  2D78 38                  DEFB    $38             ;;end-calc    ; v.
14762  2D79             
14763  2D79 CD 74 00            CALL    L0074           ; routine CH-ADD+1 get next character
14764  2D7C 18 F1               JR      L2D40           ; back to NXT-DGT-2 to process as a digit
14765  2D7E             
14766  2D7E             
14767  2D7E             ;*********************************
14768  2D7E             ;** Part 9. ARITHMETIC ROUTINES **
14769  2D7E             ;*********************************
14770  2D7E             
14771  2D7E             ; --------------------------
14772  2D7E             ; E-format to floating point
14773  2D7E             ; --------------------------
14774  2D7E             ; This subroutine is used by the PRINT-FP routine and the decimal to FP
14775  2D7E             ; routines to stack a number expressed in exponent format.
14776  2D7E             ; Note. Though not used by the ROM as such, it has also been set up as
14777  2D7E             ; a unary calculator literal but this will not work as the accumulator
14778  2D7E             ; is not available from within the calculator.
14779  2D7E             
14780  2D7E             ; on entry there is a value x on the calculator stack and an exponent of ten
14781  2D7E             ; in A.    The required value is x + 10 ^ A
14782  2D7E             
14783  2D7E             ;; e-to-fp
14784  2D7E             ;; E-TO-FP
14785  2D7E 07          L2D4F:  RLCA                    ; this will set the          x.
14786  2D7F 0F                  RRCA                    ; carry if bit 7 is set
14787  2D80             
14788  2D80 30 02               JR      NC,L2D55        ; to E-SAVE  if positive.
14789  2D82             
14790  2D82 2F                  CPL                     ; make negative positive
14791  2D83 3C                  INC     A               ; without altering carry.
14792  2D84             
14793  2D84             ;; E-SAVE
14794  2D84 F5          L2D55:  PUSH    AF              ; save positive exp and sign in carry
14795  2D85             
14796  2D85 21 92 5C            LD      HL,$5C92        ; address MEM-0
14797  2D88             
14798  2D88 CD 3A 35            CALL    L350B           ; routine FP-0/1
14799  2D8B                                             ; places an integer zero, if no carry,
14800  2D8B                                             ; else a one in mem-0 as a sign flag
14801  2D8B             
14802  2D8B EF                  RST     28H             ;; FP-CALC
14803  2D8C A4                  DEFB    $A4             ;;stk-ten                    x, 10.
14804  2D8D 38                  DEFB    $38             ;;end-calc
14805  2D8E             
14806  2D8E F1                  POP     AF              ; pop the exponent.
14807  2D8F             
14808  2D8F             ; now enter a loop
14809  2D8F             
14810  2D8F             ;; E-LOOP
14811  2D8F CB 3F       L2D60:  SRL     A               ; 0>76543210>C
14812  2D91             
14813  2D91 30 0D               JR      NC,L2D71        ; forward to E-TST-END if no bit
14814  2D93             
14815  2D93 F5                  PUSH    AF              ; save shifted exponent.
14816  2D94             
14817  2D94 EF                  RST     28H             ;; FP-CALC
14818  2D95 C1                  DEFB    $C1             ;;st-mem-1                   x, 10.
14819  2D96 E0                  DEFB    $E0             ;;get-mem-0                  x, 10, (0/1).
14820  2D97 00                  DEFB    $00             ;;jump-true
14821  2D98             
14822  2D98 04                  DEFB    $04             ;;to L2D6D, E-DIVSN
14823  2D99             
14824  2D99 04                  DEFB    $04             ;;multiply                   x*10.
14825  2D9A 33                  DEFB    $33             ;;jump
14826  2D9B             
14827  2D9B 02                  DEFB    $02             ;;to L2D6E, E-FETCH
14828  2D9C             
14829  2D9C             ;; E-DIVSN
14830  2D9C 05          L2D6D:  DEFB    $05             ;;division                   x/10.
14831  2D9D             
14832  2D9D             ;; E-FETCH
14833  2D9D E1          L2D6E:  DEFB    $E1             ;;get-mem-1                  x/10 or x*10, 10.
14834  2D9E 38                  DEFB    $38             ;;end-calc                   new x, 10.
14835  2D9F             
14836  2D9F F1                  POP     AF              ; restore shifted exponent
14837  2DA0             
14838  2DA0             ; the loop branched to here with no carry
14839  2DA0             
14840  2DA0             ;; E-TST-END
14841  2DA0 28 08       L2D71:  JR      Z,L2D7B         ; forward to E-END  if A emptied of bits
14842  2DA2             
14843  2DA2 F5                  PUSH    AF              ; re-save shifted exponent
14844  2DA3             
14845  2DA3 EF                  RST     28H             ;; FP-CALC
14846  2DA4 31                  DEFB    $31             ;;duplicate                  new x, 10, 10.
14847  2DA5 04                  DEFB    $04             ;;multiply                   new x, 100.
14848  2DA6 38                  DEFB    $38             ;;end-calc
14849  2DA7             
14850  2DA7 F1                  POP     AF              ; restore shifted exponent
14851  2DA8 18 E5               JR      L2D60           ; back to E-LOOP  until all bits done.
14852  2DAA             
14853  2DAA             ; ---
14854  2DAA             
14855  2DAA             ; although only the first pass is shown it can be seen that for each set bit
14856  2DAA             ; representing a power of two, x is multiplied or divided by the
14857  2DAA             ; corresponding power of ten.
14858  2DAA             
14859  2DAA             ;; E-END
14860  2DAA EF          L2D7B:  RST     28H             ;; FP-CALC                   final x, factor.
14861  2DAB 02                  DEFB    $02             ;;delete                     final x.
14862  2DAC 38                  DEFB    $38             ;;end-calc                   x.
14863  2DAD             
14864  2DAD C9                  RET                     ; return
14865  2DAE             
14866  2DAE             
14867  2DAE             
14868  2DAE             
14869  2DAE             ; -------------
14870  2DAE             ; Fetch integer
14871  2DAE             ; -------------
14872  2DAE             ; This routine is called by the mathematical routines - FP-TO-BC, PRINT-FP,
14873  2DAE             ; mult, re-stack and negate to fetch an integer from address HL.
14874  2DAE             ; HL points to the stack or a location in MEM and no deletion occurs.
14875  2DAE             ; If the number is negative then a similar process to that used in INT-STORE
14876  2DAE             ; is used to restore the twos complement number to normal in DE and a sign
14877  2DAE             ; in C.
14878  2DAE             
14879  2DAE             ;; INT-FETCH
14880  2DAE 23          L2D7F:  INC     HL              ; skip zero indicator.
14881  2DAF 4E                  LD      C,(HL)          ; fetch sign to C
14882  2DB0 23                  INC     HL              ; address low byte
14883  2DB1 7E                  LD      A,(HL)          ; fetch to A
14884  2DB2 A9                  XOR     C               ; two's complement
14885  2DB3 91                  SUB     C               ;
14886  2DB4 5F                  LD      E,A             ; place in E
14887  2DB5 23                  INC     HL              ; address high byte
14888  2DB6 7E                  LD      A,(HL)          ; fetch to A
14889  2DB7 89                  ADC     A,C             ; two's complement
14890  2DB8 A9                  XOR     C               ;
14891  2DB9 57                  LD      D,A             ; place in D
14892  2DBA C9                  RET                     ; return
14893  2DBB             
14894  2DBB             ; ------------------------
14895  2DBB             ; Store a positive integer
14896  2DBB             ; ------------------------
14897  2DBB             ; This entry point is not used in this ROM but would
14898  2DBB             ; store any integer as positive.
14899  2DBB             
14900  2DBB             ;; p-int-sto
14901  2DBB 0E 00       L2D8C:  LD      C,$00           ; make sign byte positive and continue
14902  2DBD             
14903  2DBD             ; -------------
14904  2DBD             ; Store integer
14905  2DBD             ; -------------
14906  2DBD             ; this routine stores an integer in DE at address HL.
14907  2DBD             ; It is called from mult, truncate, negate and sgn.
14908  2DBD             ; The sign byte $00 +ve or $FF -ve is in C.
14909  2DBD             ; If negative, the number is stored in 2's complement form so that it is
14910  2DBD             ; ready to be added.
14911  2DBD             
14912  2DBD             ;; INT-STORE
14913  2DBD E5          L2D8E:  PUSH    HL              ; preserve HL
14914  2DBE             
14915  2DBE 36 00               LD      (HL),$00        ; first byte zero shows integer not exponent
14916  2DC0 23                  INC     HL              ;
14917  2DC1 71                  LD      (HL),C          ; then store the sign byte
14918  2DC2 23                  INC     HL              ;
14919  2DC3                                             ; e.g.             +1             -1
14920  2DC3 7B                  LD      A,E             ; fetch low byte   00000001       00000001
14921  2DC4 A9                  XOR     C               ; xor sign         00000000   or  11111111
14922  2DC5                                             ; gives            00000001   or  11111110
14923  2DC5 91                  SUB     C               ; sub sign         00000000   or  11111111
14924  2DC6                                             ; gives            00000001>0 or  11111111>C
14925  2DC6 77                  LD      (HL),A          ; store 2's complement.
14926  2DC7 23                  INC     HL              ;
14927  2DC8 7A                  LD      A,D             ; high byte        00000000       00000000
14928  2DC9 89                  ADC     A,C             ; sign             00000000<0     11111111<C
14929  2DCA                                             ; gives            00000000   or  00000000
14930  2DCA A9                  XOR     C               ; xor sign         00000000       11111111
14931  2DCB 77                  LD      (HL),A          ; store 2's complement.
14932  2DCC 23                  INC     HL              ;
14933  2DCD 36 00               LD      (HL),$00        ; last byte always zero for integers.
14934  2DCF                                             ; is not used and need not be looked at when
14935  2DCF                                             ; testing for zero but comes into play should
14936  2DCF                                             ; an integer be converted to fp.
14937  2DCF E1                  POP     HL              ; restore HL
14938  2DD0 C9                  RET                     ; return.
14939  2DD1             
14940  2DD1             
14941  2DD1             ; -----------------------------
14942  2DD1             ; Floating point to BC register
14943  2DD1             ; -----------------------------
14944  2DD1             ; This routine gets a floating point number e.g. 127.4 from the calculator
14945  2DD1             ; stack to the BC register.
14946  2DD1             
14947  2DD1             ;; FP-TO-BC
14948  2DD1 EF          L2DA2:  RST     28H             ;; FP-CALC            set HL to
14949  2DD2 38                  DEFB    $38             ;;end-calc            point to last value.
14950  2DD3             
14951  2DD3 7E                  LD      A,(HL)          ; get first of 5 bytes
14952  2DD4 A7                  AND     A               ; and test
14953  2DD5 28 05               JR      Z,L2DAD         ; forward to FP-DELETE if an integer
14954  2DD7             
14955  2DD7             ; The value is first rounded up and then converted to integer.
14956  2DD7             
14957  2DD7 EF                  RST     28H             ;; FP-CALC           x.
14958  2DD8 A2                  DEFB    $A2             ;;stk-half           x. 1/2.
14959  2DD9 0F                  DEFB    $0F             ;;addition           x + 1/2.
14960  2DDA 27                  DEFB    $27             ;;int                int(x + .5)
14961  2DDB 38                  DEFB    $38             ;;end-calc
14962  2DDC             
14963  2DDC             ; now delete but leave HL pointing at integer
14964  2DDC             
14965  2DDC             ;; FP-DELETE
14966  2DDC EF          L2DAD:  RST     28H             ;; FP-CALC
14967  2DDD 02                  DEFB    $02             ;;delete
14968  2DDE 38                  DEFB    $38             ;;end-calc
14969  2DDF             
14970  2DDF E5                  PUSH    HL              ; save pointer.
14971  2DE0 D5                  PUSH    DE              ; and STKEND.
14972  2DE1 EB                  EX      DE,HL           ; make HL point to exponent/zero indicator
14973  2DE2 46                  LD      B,(HL)          ; indicator to B
14974  2DE3 CD AE 2D            CALL    L2D7F           ; routine INT-FETCH
14975  2DE6                                             ; gets int in DE sign byte to C
14976  2DE6                                             ; but meaningless values if a large integer
14977  2DE6             
14978  2DE6 AF                  XOR     A               ; clear A
14979  2DE7 90                  SUB     B               ; subtract indicator byte setting carry
14980  2DE8                                             ; if not a small integer.
14981  2DE8             
14982  2DE8 CB 79               BIT     7,C             ; test a bit of the sign byte setting zero
14983  2DEA                                             ; if positive.
14984  2DEA             
14985  2DEA 42                  LD      B,D             ; transfer int
14986  2DEB 4B                  LD      C,E             ; to BC
14987  2DEC 7B                  LD      A,E             ; low byte to A as a useful return value.
14988  2DED             
14989  2DED D1                  POP     DE              ; pop STKEND
14990  2DEE E1                  POP     HL              ; and pointer to last value
14991  2DEF C9                  RET                     ; return
14992  2DF0                                             ; if carry is set then the number was too big.
14993  2DF0             
14994  2DF0             ; ------------
14995  2DF0             ; LOG(2^A)
14996  2DF0             ; ------------
14997  2DF0             ; This routine is used when printing floating point numbers to calculate
14998  2DF0             ; the number of digits before the decimal point.
14999  2DF0             
15000  2DF0             ; first convert a one-byte signed integer to its five byte form.
15001  2DF0             
15002  2DF0             ;; LOG(2^A)
15003  2DF0 57          L2DC1:  LD      D,A             ; store a copy of A in D.
15004  2DF1 17                  RLA                     ; test sign bit of A.
15005  2DF2 9F                  SBC     A,A             ; now $FF if negative or $00
15006  2DF3 5F                  LD      E,A             ; sign byte to E.
15007  2DF4 4F                  LD      C,A             ; and to C
15008  2DF5 AF                  XOR     A               ; clear A
15009  2DF6 47                  LD      B,A             ; and B.
15010  2DF7 CD E5 2A            CALL    L2AB6           ; routine STK-STORE stacks number AEDCB
15011  2DFA             
15012  2DFA             ;  so 00 00 XX 00 00 (positive) or 00 FF XX FF 00 (negative).
15013  2DFA             ;  i.e. integer indicator, sign byte, low, high, unused.
15014  2DFA             
15015  2DFA             ; now multiply exponent by log to the base 10 of two.
15016  2DFA             
15017  2DFA EF                  RST      28H            ;; FP-CALC
15018  2DFB             
15019  2DFB 34                  DEFB    $34             ;;stk-data                      .30103 (log 2)
15020  2DFC EF                  DEFB    $EF             ;;Exponent: $7F, Bytes: 4
15021  2DFD 1A 20 9A 85         DEFB    $1A,$20,$9A,$85 ;;
15022  2E01 04                  DEFB    $04             ;;multiply
15023  2E02             
15024  2E02 27                  DEFB    $27             ;;int
15025  2E03             
15026  2E03 38                  DEFB    $38             ;;end-calc
15027  2E04             
15028  2E04             ; -------------------
15029  2E04             ; Floating point to A
15030  2E04             ; -------------------
15031  2E04             ; this routine collects a floating point number from the stack into the
15032  2E04             ; accumulator returning carry set if not in range 0 - 255.
15033  2E04             ; Not all the calling routines raise an error with overflow so no attempt
15034  2E04             ; is made to produce an error report here.
15035  2E04             
15036  2E04             ;; FP-TO-A
15037  2E04 CD D1 2D    L2DD5:  CALL    L2DA2           ; routine FP-TO-BC returns with C in A also.
15038  2E07 D8                  RET     C               ; return with carry set if > 65535, overflow
15039  2E08             
15040  2E08 F5                  PUSH    AF              ; save the value and flags
15041  2E09 05                  DEC     B               ; and test that
15042  2E0A 04                  INC     B               ; the high byte is zero.
15043  2E0B 28 03               JR      Z,L2DE1         ; forward  FP-A-END if zero
15044  2E0D             
15045  2E0D             ; else there has been 8-bit overflow
15046  2E0D             
15047  2E0D F1                  POP     AF              ; retrieve the value
15048  2E0E 37                  SCF                     ; set carry flag to show overflow
15049  2E0F C9                  RET                     ; and return.
15050  2E10             
15051  2E10             ; ---
15052  2E10             
15053  2E10             ;; FP-A-END
15054  2E10 F1          L2DE1:  POP     AF              ; restore value and success flag and
15055  2E11 C9                  RET                     ; return.
15056  2E12             
15057  2E12             
15058  2E12             ; -----------------------------
15059  2E12             ; Print a floating point number
15060  2E12             ; -----------------------------
15061  2E12             ; Not a trivial task.
15062  2E12             ; Begin by considering whether to print a leading sign for negative numbers.
15063  2E12             
15064  2E12             ;; PRINT-FP
15065  2E12 EF          L2DE3:  RST     28H             ;; FP-CALC
15066  2E13 31                  DEFB    $31             ;;duplicate
15067  2E14 36                  DEFB    $36             ;;less-0
15068  2E15 00                  DEFB    $00             ;;jump-true
15069  2E16             
15070  2E16 0B                  DEFB    $0B             ;;to L2DF2, PF-NEGTVE
15071  2E17             
15072  2E17 31                  DEFB    $31             ;;duplicate
15073  2E18 37                  DEFB    $37             ;;greater-0
15074  2E19 00                  DEFB    $00             ;;jump-true
15075  2E1A             
15076  2E1A 0D                  DEFB    $0D             ;;to L2DF8, PF-POSTVE
15077  2E1B             
15078  2E1B             ; must be zero itself
15079  2E1B             
15080  2E1B 02                  DEFB    $02             ;;delete
15081  2E1C 38                  DEFB    $38             ;;end-calc
15082  2E1D             
15083  2E1D 3E 30               LD      A,$30           ; prepare the character '0'
15084  2E1F             
15085  2E1F D7                  RST     10H             ; PRINT-A
15086  2E20 C9                  RET                     ; return.                 ->
15087  2E21             ; ---
15088  2E21             
15089  2E21             ;; PF-NEGTVE
15090  2E21 2A          L2DF2:  DEFB    $2A             ;;abs
15091  2E22 38                  DEFB    $38             ;;end-calc
15092  2E23             
15093  2E23 3E 2D               LD      A,$2D           ; the character '-'
15094  2E25             
15095  2E25 D7                  RST     10H             ; PRINT-A
15096  2E26             
15097  2E26             ; and continue to print the now positive number.
15098  2E26             
15099  2E26 EF                  RST     28H             ;; FP-CALC
15100  2E27             
15101  2E27             ;; PF-POSTVE
15102  2E27 A0          L2DF8:  DEFB    $A0             ;;stk-zero     x,0.     begin by
15103  2E28 C3                  DEFB    $C3             ;;st-mem-3     x,0.     clearing a temporary
15104  2E29 C4                  DEFB    $C4             ;;st-mem-4     x,0.     output buffer to
15105  2E2A C5                  DEFB    $C5             ;;st-mem-5     x,0.     fifteen zeros.
15106  2E2B 02                  DEFB    $02             ;;delete       x.
15107  2E2C 38                  DEFB    $38             ;;end-calc     x.
15108  2E2D             
15109  2E2D D9                  EXX                     ; in case called from 'str$' then save the
15110  2E2E E5                  PUSH    HL              ; pointer to whatever comes after
15111  2E2F D9                  EXX                     ; str$ as H'L' will be used.
15112  2E30             
15113  2E30             ; now enter a loop?
15114  2E30             
15115  2E30             ;; PF-LOOP
15116  2E30 EF          L2E01:  RST     28H             ;; FP-CALC
15117  2E31 31                  DEFB    $31             ;;duplicate    x,x.
15118  2E32 27                  DEFB    $27             ;;int          x,int x.
15119  2E33 C2                  DEFB    $C2             ;;st-mem-2     x,int x.
15120  2E34 03                  DEFB    $03             ;;subtract     x-int x.     fractional part.
15121  2E35 E2                  DEFB    $E2             ;;get-mem-2    x-int x, int x.
15122  2E36 01                  DEFB    $01             ;;exchange     int x, x-int x.
15123  2E37 C2                  DEFB    $C2             ;;st-mem-2     int x, x-int x.
15124  2E38 02                  DEFB    $02             ;;delete       int x.
15125  2E39 38                  DEFB    $38             ;;end-calc     int x.
15126  2E3A                                             ;
15127  2E3A                                             ; mem-2 holds the fractional part.
15128  2E3A             
15129  2E3A             ; HL points to last value int x
15130  2E3A             
15131  2E3A 7E                  LD      A,(HL)          ; fetch exponent of int x.
15132  2E3B A7                  AND     A               ; test
15133  2E3C 20 47               JR      NZ,L2E56        ; forward to PF-LARGE if a large integer
15134  2E3E                                             ; > 65535
15135  2E3E             
15136  2E3E             ; continue with small positive integer components in range 0 - 65535 
15137  2E3E             ; if original number was say .999 then this integer component is zero. 
15138  2E3E             
15139  2E3E CD AE 2D            CALL    L2D7F           ; routine INT-FETCH gets x in DE
15140  2E41                                             ; (but x is not deleted)
15141  2E41             
15142  2E41 06 10               LD      B,$10           ; set B, bit counter, to 16d
15143  2E43             
15144  2E43 7A                  LD      A,D             ; test if
15145  2E44 A7                  AND     A               ; high byte is zero
15146  2E45 20 06               JR      NZ,L2E1E        ; forward to PF-SAVE if 16-bit integer.
15147  2E47             
15148  2E47             ; and continue with integer in range 0 - 255.
15149  2E47             
15150  2E47 B3                  OR      E               ; test the low byte for zero
15151  2E48                                             ; i.e. originally just point something or other.
15152  2E48 28 09               JR      Z,L2E24         ; forward if so to PF-SMALL 
15153  2E4A             
15154  2E4A             ; 
15155  2E4A             
15156  2E4A 53                  LD      D,E             ; transfer E to D
15157  2E4B 06 08               LD      B,$08           ; and reduce the bit counter to 8.
15158  2E4D             
15159  2E4D             ;; PF-SAVE
15160  2E4D D5          L2E1E:  PUSH    DE              ; save the part before decimal point.
15161  2E4E D9                  EXX                     ;
15162  2E4F D1                  POP     DE              ; and pop in into D'E'
15163  2E50 D9                  EXX                     ;
15164  2E51 18 57               JR      L2E7B           ; forward to PF-BITS
15165  2E53             
15166  2E53             ; ---------------------
15167  2E53             
15168  2E53             ; the branch was here when 'int x' was found to be zero as in say 0.5.
15169  2E53             ; The zero has been fetched from the calculator stack but not deleted and
15170  2E53             ; this should occur now. This omission leaves the stack unbalanced and while
15171  2E53             ; that causes no problems with a simple PRINT statement, it will if str$ is
15172  2E53             ; being used in an expression e.g. "2" + STR$ 0.5 gives the result "0.5"
15173  2E53             ; instead of the expected result "20.5".
15174  2E53             ; credit Tony Stratton, 1982.
15175  2E53             ; A DEFB 02 delete is required immediately on using the calculator.
15176  2E53             
15177  2E53             ;; PF-SMALL
15178  2E53 EF          L2E24:  RST     28H             ;; FP-CALC       int x = 0.
15179  2E54 E2          L2E25:  DEFB    $E2             ;;get-mem-2      int x = 0, x-int x.
15180  2E55 38                  DEFB    $38             ;;end-calc
15181  2E56             
15182  2E56 7E                  LD      A,(HL)          ; fetch exponent of positive fractional number
15183  2E57 D6 7E               SUB     $7E             ; subtract 
15184  2E59             
15185  2E59 CD F0 2D            CALL    L2DC1           ; routine LOG(2^A) calculates leading digits.
15186  2E5C             
15187  2E5C 57                  LD      D,A             ; transfer count to D
15188  2E5D 3A AC 5C            LD      A,($5CAC)       ; fetch total MEM-5-1
15189  2E60 92                  SUB     D               ;
15190  2E61 32 AC 5C            LD      ($5CAC),A       ; MEM-5-1
15191  2E64 7A                  LD      A,D             ; 
15192  2E65 CD 7E 2D            CALL    L2D4F           ; routine E-TO-FP
15193  2E68             
15194  2E68 EF                  RST     28H             ;; FP-CALC
15195  2E69 31                  DEFB    $31             ;;duplicate
15196  2E6A 27                  DEFB    $27             ;;int
15197  2E6B C1                  DEFB    $C1             ;;st-mem-1
15198  2E6C 03                  DEFB    $03             ;;subtract
15199  2E6D E1                  DEFB    $E1             ;;get-mem-1
15200  2E6E 38                  DEFB    $38             ;;end-calc
15201  2E6F             
15202  2E6F CD 04 2E            CALL    L2DD5           ; routine FP-TO-A
15203  2E72             
15204  2E72 E5                  PUSH    HL              ; save HL
15205  2E73 32 A1 5C            LD      ($5CA1),A       ; MEM-3-1
15206  2E76 3D                  DEC     A               ;
15207  2E77 17                  RLA                     ;
15208  2E78 9F                  SBC     A,A             ;
15209  2E79 3C                  INC     A               ;
15210  2E7A             
15211  2E7A 21 AB 5C            LD      HL,$5CAB        ; address MEM-5-1 leading digit counter
15212  2E7D 77                  LD      (HL),A          ; store counter
15213  2E7E 23                  INC     HL              ; address MEM-5-2 total digits
15214  2E7F 86                  ADD     A,(HL)          ; add counter to contents
15215  2E80 77                  LD      (HL),A          ; and store updated value
15216  2E81 E1                  POP     HL              ; restore HL
15217  2E82             
15218  2E82 C3 FE 2E            JP      L2ECF           ; JUMP forward to PF-FRACTN
15219  2E85             
15220  2E85             ; ---
15221  2E85             
15222  2E85             ; Note. while it would be pedantic to comment on every occasion a JP
15223  2E85             ; instruction could be replaced with a JR instruction, this applies to the
15224  2E85             ; above, which is useful if you wish to correct the unbalanced stack error
15225  2E85             ; by inserting a 'DEFB 02 delete' at L2E25, and maintain main addresses.
15226  2E85             
15227  2E85             ; the branch was here with a large positive integer > 65535 e.g. 123456789
15228  2E85             ; the accumulator holds the exponent.
15229  2E85             
15230  2E85             ;; PF-LARGE
15231  2E85 D6 80       L2E56:  SUB     $80             ; make exponent positive
15232  2E87 FE 1C               CP      $1C             ; compare to 28
15233  2E89 38 13               JR      C,L2E6F         ; to PF-MEDIUM if integer <= 2^27
15234  2E8B             
15235  2E8B CD F0 2D            CALL    L2DC1           ; routine LOG(2^A)
15236  2E8E D6 07               SUB     $07             ;
15237  2E90 47                  LD      B,A             ;
15238  2E91 21 AC 5C            LD      HL,$5CAC        ; address MEM-5-1 the leading digits counter.
15239  2E94 86                  ADD     A,(HL)          ; add A to contents
15240  2E95 77                  LD      (HL),A          ; store updated value.
15241  2E96 78                  LD      A,B             ; 
15242  2E97 ED 44               NEG                     ; negate
15243  2E99 CD 7E 2D            CALL    L2D4F           ; routine E-TO-FP
15244  2E9C 18 92               JR      L2E01           ; back to PF-LOOP
15245  2E9E             
15246  2E9E             ; ----------------------------
15247  2E9E             
15248  2E9E             ;; PF-MEDIUM
15249  2E9E EB          L2E6F:  EX      DE,HL           ;
15250  2E9F CD E9 2F            CALL    L2FBA           ; routine FETCH-TWO
15251  2EA2 D9                  EXX                     ;
15252  2EA3 CB FA               SET     7,D             ;
15253  2EA5 7D                  LD      A,L             ;
15254  2EA6 D9                  EXX                     ;
15255  2EA7 D6 80               SUB     $80             ;
15256  2EA9 47                  LD      B,A             ;
15257  2EAA             
15258  2EAA             ; the branch was here to handle bits in DE with 8 or 16 in B  if small int
15259  2EAA             ; and integer in D'E', 6 nibbles will accommodate 065535 but routine does
15260  2EAA             ; 32-bit numbers as well from above
15261  2EAA             
15262  2EAA             ;; PF-BITS
15263  2EAA CB 23       L2E7B:  SLA     E               ;  C<xxxxxxxx<0
15264  2EAC CB 12               RL      D               ;  C<xxxxxxxx<C
15265  2EAE D9                  EXX                     ;
15266  2EAF CB 13               RL      E               ;  C<xxxxxxxx<C
15267  2EB1 CB 12               RL      D               ;  C<xxxxxxxx<C
15268  2EB3 D9                  EXX                     ;
15269  2EB4             
15270  2EB4 21 AA 5C            LD      HL,$5CAA        ; set HL to mem-4-5th last byte of buffer
15271  2EB7 0E 05               LD      C,$05           ; set byte count to 5 -  10 nibbles
15272  2EB9             
15273  2EB9             ;; PF-BYTES
15274  2EB9 7E          L2E8A:  LD      A,(HL)          ; fetch 0 or prev value
15275  2EBA 8F                  ADC     A,A             ; shift left add in carry    C<xxxxxxxx<C
15276  2EBB             
15277  2EBB 27                  DAA                     ; Decimal Adjust Accumulator.
15278  2EBC                                             ; if greater than 9 then the left hand
15279  2EBC                                             ; nibble is incremented. If greater than
15280  2EBC                                             ; 99 then adjusted and carry set.
15281  2EBC                                             ; so if we'd built up 7 and a carry came in
15282  2EBC                                             ;      0000 0111 < C
15283  2EBC                                             ;      0000 1111
15284  2EBC                                             ; daa     1 0101  which is 15 in BCD
15285  2EBC             
15286  2EBC 77                  LD      (HL),A          ; put back
15287  2EBD 2B                  DEC     HL              ; work down thru mem 4
15288  2EBE 0D                  DEC     C               ; decrease the 5 counter.
15289  2EBF 20 F8               JR      NZ,L2E8A        ; back to PF-BYTES until the ten nibbles rolled
15290  2EC1             
15291  2EC1 10 E7               DJNZ    L2E7B           ; back to PF-BITS until 8 or 16 (or 32) done
15292  2EC3             
15293  2EC3             ; at most 9 digits for 32-bit number will have been loaded with digits
15294  2EC3             ; each of the 9 nibbles in mem 4 is placed into ten bytes in mem-3 and mem 4
15295  2EC3             ; unless the nibble is zero as the buffer is already zero.
15296  2EC3             ; ( or in the case of mem-5 will become zero as a result of RLD instruction )
15297  2EC3             
15298  2EC3 AF                  XOR     A               ; clear to accept
15299  2EC4 21 A6 5C            LD      HL,$5CA6        ; address MEM-4-0 byte destination.
15300  2EC7 11 A1 5C            LD      DE,$5CA1        ; address MEM-3-0 nibble source.
15301  2ECA 06 09               LD      B,$09           ; the count is 9 (not ten) as the first 
15302  2ECC                                             ; nibble is known to be blank.
15303  2ECC             
15304  2ECC ED 6F               RLD                     ; shift RH nibble to left in (HL)
15305  2ECE                                             ;    A           (HL)
15306  2ECE                                             ; 0000 0000 < 0000 3210
15307  2ECE                                             ; 0000 0000   3210 0000
15308  2ECE                                             ; A picks up the blank nibble
15309  2ECE             
15310  2ECE             
15311  2ECE 0E FF               LD      C,$FF           ; set a flag to indicate when a significant
15312  2ED0                                             ; digit has been encountered.
15313  2ED0             
15314  2ED0             ;; PF-DIGITS
15315  2ED0 ED 6F       L2EA1:  RLD                     ; pick up leftmost nibble from (HL)
15316  2ED2                                             ;    A           (HL)
15317  2ED2                                             ; 0000 0000 < 7654 3210
15318  2ED2                                             ; 0000 7654   3210 0000
15319  2ED2             
15320  2ED2             
15321  2ED2 20 04               JR      NZ,L2EA9        ; to PF-INSERT if non-zero value picked up.
15322  2ED4             
15323  2ED4 0D                  DEC     C               ; test
15324  2ED5 0C                  INC     C               ; flag
15325  2ED6 20 0A               JR      NZ,L2EB3        ; skip forward to PF-TEST-2 if flag still $FF
15326  2ED8                                             ; indicating this is a leading zero.
15327  2ED8             
15328  2ED8             ; but if the zero is a significant digit e.g. 10 then include in digit totals.
15329  2ED8             ; the path for non-zero digits rejoins here.
15330  2ED8             
15331  2ED8             ;; PF-INSERT
15332  2ED8 12          L2EA9:  LD      (DE),A          ; insert digit at destination
15333  2ED9 13                  INC     DE              ; increase the destination pointer
15334  2EDA FD 34 71            INC     (IY+$71)        ; increment MEM-5-1st  digit counter
15335  2EDD FD 34 72            INC     (IY+$72)        ; increment MEM-5-2nd  leading digit counter
15336  2EE0 0E 00               LD      C,$00           ; set flag to zero indicating that any 
15337  2EE2                                             ; subsequent zeros are significant and not 
15338  2EE2                                             ; leading.
15339  2EE2             
15340  2EE2             ;; PF-TEST-2
15341  2EE2 CB 40       L2EB3:  BIT     0,B             ; test if the nibble count is even
15342  2EE4 28 01               JR      Z,L2EB8         ; skip to PF-ALL-9 if so to deal with the
15343  2EE6                                             ; other nibble in the same byte
15344  2EE6             
15345  2EE6 23                  INC     HL              ; point to next source byte if not
15346  2EE7             
15347  2EE7             ;; PF-ALL-9
15348  2EE7 10 E7       L2EB8:  DJNZ    L2EA1           ; decrement the nibble count, back to PF-DIGITS
15349  2EE9                                             ; if all nine not done.
15350  2EE9             
15351  2EE9             ; For 8-bit integers there will be at most 3 digits.
15352  2EE9             ; For 16-bit integers there will be at most 5 digits. 
15353  2EE9             ; but for larger integers there could be nine leading digits.
15354  2EE9             ; if nine digits complete then the last one is rounded up as the number will
15355  2EE9             ; be printed using E-format notation
15356  2EE9             
15357  2EE9 3A AB 5C            LD      A,($5CAB)       ; fetch digit count from MEM-5-1st
15358  2EEC D6 09               SUB     $09             ; subtract 9 - max possible
15359  2EEE 38 0A               JR      C,L2ECB         ; forward if less to PF-MORE
15360  2EF0             
15361  2EF0 FD 35 71            DEC     (IY+$71)        ; decrement digit counter MEM-5-1st to 8
15362  2EF3 3E 04               LD      A,$04           ; load A with the value 4.
15363  2EF5 FD BE 6F            CP      (IY+$6F)        ; compare with MEM-4-4th - the ninth digit
15364  2EF8 18 41               JR      L2F0C           ; forward to PF-ROUND
15365  2EFA                                             ; to consider rounding.
15366  2EFA             
15367  2EFA             ; ---------------------------------------
15368  2EFA              
15369  2EFA             ; now delete int x from calculator stack and fetch fractional part.
15370  2EFA             
15371  2EFA             ;; PF-MORE
15372  2EFA EF          L2ECB:  RST     28H             ;; FP-CALC        int x.
15373  2EFB 02                  DEFB    $02             ;;delete          .
15374  2EFC E2                  DEFB    $E2             ;;get-mem-2       x - int x = f.
15375  2EFD 38                  DEFB    $38             ;;end-calc        f.
15376  2EFE             
15377  2EFE             ;; PF-FRACTN
15378  2EFE EB          L2ECF:  EX      DE,HL           ;
15379  2EFF CD E9 2F            CALL    L2FBA           ; routine FETCH-TWO
15380  2F02 D9                  EXX                     ;
15381  2F03 3E 80               LD      A,$80           ;
15382  2F05 95                  SUB     L               ;
15383  2F06 2E 00               LD      L,$00           ;
15384  2F08 CB FA               SET     7,D             ;
15385  2F0A D9                  EXX                     ;
15386  2F0B CD 0C 30            CALL    L2FDD           ; routine SHIFT-FP
15387  2F0E             
15388  2F0E             ;; PF-FRN-LP
15389  2F0E FD 7E 71    L2EDF:  LD      A,(IY+$71)      ; MEM-5-1st
15390  2F11 FE 08               CP      $08             ;
15391  2F13 38 06               JR      C,L2EEC         ; to PF-FR-DGT
15392  2F15             
15393  2F15 D9                  EXX                     ;
15394  2F16 CB 12               RL      D               ;
15395  2F18 D9                  EXX                     ;
15396  2F19 18 20               JR      L2F0C           ; to PF-ROUND
15397  2F1B             
15398  2F1B             ; ---
15399  2F1B             
15400  2F1B             ;; PF-FR-DGT
15401  2F1B 01 00 02    L2EEC:  LD      BC,$0200        ;
15402  2F1E             
15403  2F1E             ;; PF-FR-EXX
15404  2F1E 7B          L2EEF:  LD      A,E             ;
15405  2F1F CD BA 2F            CALL    L2F8B           ; routine CA-10*A+C
15406  2F22 5F                  LD      E,A             ;
15407  2F23 7A                  LD      A,D             ;
15408  2F24 CD BA 2F            CALL    L2F8B           ; routine CA-10*A+C
15409  2F27 57                  LD      D,A             ;
15410  2F28 C5                  PUSH    BC              ;
15411  2F29 D9                  EXX                     ;
15412  2F2A C1                  POP     BC              ;
15413  2F2B 10 F1               DJNZ    L2EEF           ; to PF-FR-EXX
15414  2F2D             
15415  2F2D 21 A1 5C            LD      HL,$5CA1        ; MEM-3
15416  2F30 79                  LD      A,C             ;
15417  2F31 FD 4E 71            LD      C,(IY+$71)      ; MEM-5-1st
15418  2F34 09                  ADD     HL,BC           ;
15419  2F35 77                  LD      (HL),A          ;
15420  2F36 FD 34 71            INC     (IY+$71)        ; MEM-5-1st
15421  2F39 18 D3               JR      L2EDF           ; to PF-FRN-LP
15422  2F3B             
15423  2F3B             ; ----------------
15424  2F3B             
15425  2F3B             ; 1) with 9 digits but 8 in mem-5-1 and A holding 4, carry set if rounding up.
15426  2F3B             ; e.g. 
15427  2F3B             ;      999999999 is printed as 1E+9
15428  2F3B             ;      100000001 is printed as 1E+8
15429  2F3B             ;      100000009 is printed as 1.0000001E+8
15430  2F3B             
15431  2F3B             ;; PF-ROUND
15432  2F3B F5          L2F0C:  PUSH    AF              ; save A and flags
15433  2F3C 21 A1 5C            LD      HL,$5CA1        ; address MEM-3 start of digits
15434  2F3F FD 4E 71            LD      C,(IY+$71)      ; MEM-5-1st No. of digits to C
15435  2F42 06 00               LD      B,$00           ; prepare to add
15436  2F44 09                  ADD     HL,BC           ; address last digit + 1
15437  2F45 41                  LD      B,C             ; No. of digits to B counter
15438  2F46 F1                  POP     AF              ; restore A and carry flag from comparison.
15439  2F47             
15440  2F47             ;; PF-RND-LP
15441  2F47 2B          L2F18:  DEC     HL              ; address digit at rounding position.
15442  2F48 7E                  LD      A,(HL)          ; fetch it
15443  2F49 CE 00               ADC     A,$00           ; add carry from the comparison
15444  2F4B 77                  LD      (HL),A          ; put back result even if $0A.
15445  2F4C A7                  AND     A               ; test A
15446  2F4D 28 05               JR      Z,L2F25         ; skip to PF-R-BACK if ZERO?
15447  2F4F             
15448  2F4F FE 0A               CP      $0A             ; compare to 'ten' - overflow
15449  2F51 3F                  CCF                     ; complement carry flag so that set if ten.
15450  2F52 30 08               JR      NC,L2F2D        ; forward to PF-COUNT with 1 - 9.
15451  2F54             
15452  2F54             ;; PF-R-BACK
15453  2F54 10 F1       L2F25:  DJNZ    L2F18           ; loop back to PF-RND-LP
15454  2F56             
15455  2F56             ; if B counts down to zero then we've rounded right back as in 999999995.
15456  2F56             ; and the first 8 locations all hold $0A.
15457  2F56             
15458  2F56             
15459  2F56 36 01               LD      (HL),$01        ; load first location with digit 1.
15460  2F58 04                  INC     B               ; make B hold 1 also.
15461  2F59                                             ; could save an instruction byte here.
15462  2F59 FD 34 72            INC     (IY+$72)        ; make MEM-5-2nd hold 1.
15463  2F5C                                             ; and proceed to initialize total digits to 1.
15464  2F5C             
15465  2F5C             ;; PF-COUNT
15466  2F5C FD 70 71    L2F2D:  LD      (IY+$71),B      ; MEM-5-1st
15467  2F5F             
15468  2F5F             ; now balance the calculator stack by deleting  it
15469  2F5F             
15470  2F5F EF                  RST     28H             ;; FP-CALC
15471  2F60 02                  DEFB    $02             ;;delete
15472  2F61 38                  DEFB    $38             ;;end-calc
15473  2F62             
15474  2F62             ; note if used from str$ then other values may be on the calculator stack.
15475  2F62             ; we can also restore the next literal pointer from its position on the
15476  2F62             ; machine stack.
15477  2F62             
15478  2F62 D9                  EXX                     ;
15479  2F63 E1                  POP     HL              ; restore next literal pointer.
15480  2F64 D9                  EXX                     ;
15481  2F65             
15482  2F65 ED 4B AB 5C         LD      BC,($5CAB)      ; set C to MEM-5-1st digit counter.
15483  2F69                                             ; set B to MEM-5-2nd leading digit counter.
15484  2F69 21 A1 5C            LD      HL,$5CA1        ; set HL to start of digits at MEM-3-1
15485  2F6C 78                  LD      A,B             ;
15486  2F6D FE 09               CP      $09             ;
15487  2F6F 38 04               JR      C,L2F46         ; to PF-NOT-E
15488  2F71             
15489  2F71 FE FC               CP      $FC             ;
15490  2F73 38 26               JR      C,L2F6C         ; to PF-E-FRMT
15491  2F75             
15492  2F75             ;; PF-NOT-E
15493  2F75 A7          L2F46:  AND     A               ; test for zero leading digits as in .123
15494  2F76             
15495  2F76 CC 1E 16            CALL    Z,L15EF         ; routine OUT-CODE prints a zero e.g. 0.123
15496  2F79             
15497  2F79             ;; PF-E-SBRN
15498  2F79 AF          L2F4A:  XOR     A               ;
15499  2F7A 90                  SUB     B               ;
15500  2F7B FA 81 2F            JP      M,L2F52         ; skip forward to PF-OUT-LP if originally +ve
15501  2F7E             
15502  2F7E 47                  LD      B,A             ; else negative count now +ve
15503  2F7F 18 0C               JR      L2F5E           ; forward to PF-DC-OUT       ->
15504  2F81             
15505  2F81             ; ---
15506  2F81             
15507  2F81             ;; PF-OUT-LP
15508  2F81 79          L2F52:  LD      A,C             ; fetch total digit count
15509  2F82 A7                  AND     A               ; test for zero
15510  2F83 28 03               JR      Z,L2F59         ; forward to PF-OUT-DT if so
15511  2F85             
15512  2F85 7E                  LD      A,(HL)          ; fetch digit
15513  2F86 23                  INC     HL              ; address next digit
15514  2F87 0D                  DEC     C               ; decrease total digit counter
15515  2F88             
15516  2F88             ;; PF-OUT-DT
15517  2F88 CD 1E 16    L2F59:  CALL    L15EF           ; routine OUT-CODE outputs it.
15518  2F8B 10 F4               DJNZ    L2F52           ; loop back to PF-OUT-LP until B leading 
15519  2F8D                                             ; digits output.
15520  2F8D             
15521  2F8D             ;; PF-DC-OUT
15522  2F8D 79          L2F5E:  LD      A,C             ; fetch total digits and
15523  2F8E A7                  AND     A               ; test if also zero
15524  2F8F C8                  RET     Z               ; return if so              -->
15525  2F90             
15526  2F90             ; 
15527  2F90             
15528  2F90 04                  INC     B               ; increment B
15529  2F91 3E 2E               LD      A,$2E           ; prepare the character '.'
15530  2F93             
15531  2F93             ;; PF-DEC-0S
15532  2F93 D7          L2F64:  RST     10H             ; PRINT-A outputs the character '.' or '0'
15533  2F94             
15534  2F94 3E 30               LD      A,$30           ; prepare the character '0'
15535  2F96                                             ; (for cases like .000012345678)
15536  2F96 10 FB               DJNZ    L2F64           ; loop back to PF-DEC-0S for B times.
15537  2F98             
15538  2F98 41                  LD      B,C             ; load B with now trailing digit counter.
15539  2F99 18 E6               JR      L2F52           ; back to PF-OUT-LP
15540  2F9B             
15541  2F9B             ; ---------------------------------
15542  2F9B             
15543  2F9B             ; the branch was here for E-format printing e.g. 123456789 => 1.2345679e+8
15544  2F9B             
15545  2F9B             ;; PF-E-FRMT
15546  2F9B 50          L2F6C:  LD      D,B             ; counter to D
15547  2F9C 15                  DEC     D               ; decrement
15548  2F9D 06 01               LD      B,$01           ; load B with 1.
15549  2F9F             
15550  2F9F CD 79 2F            CALL    L2F4A           ; routine PF-E-SBRN above
15551  2FA2             
15552  2FA2 3E 45               LD      A,$45           ; prepare character 'e'
15553  2FA4 D7                  RST     10H             ; PRINT-A
15554  2FA5             
15555  2FA5 4A                  LD      C,D             ; exponent to C
15556  2FA6 79                  LD      A,C             ; and to A
15557  2FA7 A7                  AND     A               ; test exponent
15558  2FA8 F2 B2 2F            JP      P,L2F83         ; to PF-E-POS if positive
15559  2FAB             
15560  2FAB ED 44               NEG                     ; negate
15561  2FAD 4F                  LD      C,A             ; positive exponent to C
15562  2FAE 3E 2D               LD      A,$2D           ; prepare character '-'
15563  2FB0 18 02               JR      L2F85           ; skip to PF-E-SIGN
15564  2FB2             
15565  2FB2             ; ---
15566  2FB2             
15567  2FB2             ;; PF-E-POS
15568  2FB2 3E 2B       L2F83:  LD      A,$2B           ; prepare character '+'
15569  2FB4             
15570  2FB4             ;; PF-E-SIGN
15571  2FB4 D7          L2F85:  RST     10H             ; PRINT-A outputs the sign
15572  2FB5             
15573  2FB5 06 00               LD      B,$00           ; make the high byte zero.
15574  2FB7 C3 4A 1A            JP      L1A1B           ; exit via OUT-NUM-1 to print exponent in BC
15575  2FBA             
15576  2FBA             ; ------------------------------
15577  2FBA             ; Handle printing floating point
15578  2FBA             ; ------------------------------
15579  2FBA             ; This subroutine is called twice from above when printing floating-point
15580  2FBA             ; numbers. It returns 10*A +C in registers C and A
15581  2FBA             
15582  2FBA             ;; CA-10*A+C
15583  2FBA D5          L2F8B:  PUSH    DE              ; preserve DE.
15584  2FBB 6F                  LD      L,A             ; transfer A to L
15585  2FBC 26 00               LD      H,$00           ; zero high byte.
15586  2FBE 5D                  LD      E,L             ; copy HL
15587  2FBF 54                  LD      D,H             ; to DE.
15588  2FC0 29                  ADD     HL,HL           ; double (*2)
15589  2FC1 29                  ADD     HL,HL           ; double (*4)
15590  2FC2 19                  ADD     HL,DE           ; add DE (*5)
15591  2FC3 29                  ADD     HL,HL           ; double (*10)
15592  2FC4 59                  LD      E,C             ; copy C to E    (D is 0)
15593  2FC5 19                  ADD     HL,DE           ; and add to give required result.
15594  2FC6 4C                  LD      C,H             ; transfer to
15595  2FC7 7D                  LD      A,L             ; destination registers.
15596  2FC8 D1                  POP     DE              ; restore DE
15597  2FC9 C9                  RET                     ; return with result.
15598  2FCA             
15599  2FCA             ; --------------
15600  2FCA             ; Prepare to add
15601  2FCA             ; --------------
15602  2FCA             ; This routine is called twice by addition to prepare the two numbers. The
15603  2FCA             ; exponent is picked up in A and the location made zero. Then the sign bit
15604  2FCA             ; is tested before being set to the implied state. Negative numbers are twos
15605  2FCA             ; complemented.
15606  2FCA             
15607  2FCA             ;; PREP-ADD
15608  2FCA 7E          L2F9B:  LD      A,(HL)          ; pick up exponent
15609  2FCB 36 00               LD      (HL),$00        ; make location zero
15610  2FCD A7                  AND     A               ; test if number is zero
15611  2FCE C8                  RET     Z               ; return if so
15612  2FCF             
15613  2FCF 23                  INC     HL              ; address mantissa
15614  2FD0 CB 7E               BIT     7,(HL)          ; test the sign bit
15615  2FD2 CB FE               SET     7,(HL)          ; set it to implied state
15616  2FD4 2B                  DEC     HL              ; point to exponent
15617  2FD5 C8                  RET     Z               ; return if positive number.
15618  2FD6             
15619  2FD6 C5                  PUSH    BC              ; preserve BC
15620  2FD7 01 05 00            LD      BC,$0005        ; length of number
15621  2FDA 09                  ADD     HL,BC           ; point HL past end
15622  2FDB 41                  LD      B,C             ; set B to 5 counter
15623  2FDC 4F                  LD      C,A             ; store exponent in C
15624  2FDD 37                  SCF                     ; set carry flag
15625  2FDE             
15626  2FDE             ;; NEG-BYTE
15627  2FDE 2B          L2FAF:  DEC     HL              ; work from LSB to MSB
15628  2FDF 7E                  LD      A,(HL)          ; fetch byte
15629  2FE0 2F                  CPL                     ; complement
15630  2FE1 CE 00               ADC     A,$00           ; add in initial carry or from prev operation
15631  2FE3 77                  LD      (HL),A          ; put back
15632  2FE4 10 F8               DJNZ    L2FAF           ; loop to NEG-BYTE till all 5 done
15633  2FE6             
15634  2FE6 79                  LD      A,C             ; stored exponent to A
15635  2FE7 C1                  POP     BC              ; restore original BC
15636  2FE8 C9                  RET                     ; return
15637  2FE9             
15638  2FE9             ; -----------------
15639  2FE9             ; Fetch two numbers
15640  2FE9             ; -----------------
15641  2FE9             ; This routine is called twice when printing floating point numbers and also
15642  2FE9             ; to fetch two numbers by the addition, multiply and division routines.
15643  2FE9             ; HL addresses the first number, DE addresses the second number.
15644  2FE9             ; For arithmetic only, A holds the sign of the result which is stored in
15645  2FE9             ; the second location. 
15646  2FE9             
15647  2FE9             ;; FETCH-TWO
15648  2FE9 E5          L2FBA:  PUSH    HL              ; save pointer to first number, result if math.
15649  2FEA F5                  PUSH    AF              ; save result sign.
15650  2FEB             
15651  2FEB 4E                  LD      C,(HL)          ;
15652  2FEC 23                  INC     HL              ;
15653  2FED             
15654  2FED 46                  LD      B,(HL)          ;
15655  2FEE 77                  LD      (HL),A          ; store the sign at correct location in 
15656  2FEF                                             ; destination 5 bytes for arithmetic only.
15657  2FEF 23                  INC     HL              ;
15658  2FF0             
15659  2FF0 79                  LD      A,C             ;
15660  2FF1 4E                  LD      C,(HL)          ;
15661  2FF2 C5                  PUSH    BC              ;
15662  2FF3 23                  INC     HL              ;
15663  2FF4 4E                  LD      C,(HL)          ;
15664  2FF5 23                  INC     HL              ;
15665  2FF6 46                  LD      B,(HL)          ;
15666  2FF7 EB                  EX      DE,HL           ;
15667  2FF8 57                  LD      D,A             ;
15668  2FF9 5E                  LD      E,(HL)          ;
15669  2FFA D5                  PUSH    DE              ;
15670  2FFB 23                  INC     HL              ;
15671  2FFC 56                  LD      D,(HL)          ;
15672  2FFD 23                  INC     HL              ;
15673  2FFE 5E                  LD      E,(HL)          ;
15674  2FFF D5                  PUSH    DE              ;
15675  3000 D9                  EXX                     ;
15676  3001 D1                  POP     DE              ;
15677  3002 E1                  POP     HL              ;
15678  3003 C1                  POP     BC              ;
15679  3004 D9                  EXX                     ;
15680  3005 23                  INC     HL              ;
15681  3006 56                  LD      D,(HL)          ;
15682  3007 23                  INC     HL              ;
15683  3008 5E                  LD      E,(HL)          ;
15684  3009             
15685  3009 F1                  POP     AF              ; restore possible result sign.
15686  300A E1                  POP     HL              ; and pointer to possible result.
15687  300B C9                  RET                     ; return.
15688  300C             
15689  300C             ; ---------------------------------
15690  300C             ; Shift floating point number right
15691  300C             ; ---------------------------------
15692  300C             ;
15693  300C             ;
15694  300C             
15695  300C             ;; SHIFT-FP
15696  300C A7          L2FDD:  AND     A               ;
15697  300D C8                  RET     Z               ;
15698  300E             
15699  300E FE 21               CP      $21             ;
15700  3010 30 16               JR      NC,L2FF9        ; to ADDEND-0
15701  3012             
15702  3012 C5                  PUSH    BC              ;
15703  3013 47                  LD      B,A             ;
15704  3014             
15705  3014             ;; ONE-SHIFT
15706  3014 D9          L2FE5:  EXX                     ;
15707  3015 CB 2D               SRA     L               ;
15708  3017 CB 1A               RR      D               ;
15709  3019 CB 1B               RR      E               ;
15710  301B D9                  EXX                     ;
15711  301C CB 1A               RR      D               ;
15712  301E CB 1B               RR      E               ;
15713  3020 10 F2               DJNZ    L2FE5           ; to ONE-SHIFT
15714  3022             
15715  3022 C1                  POP     BC              ;
15716  3023 D0                  RET     NC              ;
15717  3024             
15718  3024 CD 33 30            CALL    L3004           ; routine ADD-BACK
15719  3027 C0                  RET     NZ              ;
15720  3028             
15721  3028             ;; ADDEND-0
15722  3028 D9          L2FF9:  EXX                     ;
15723  3029 AF                  XOR     A               ;
15724  302A             
15725  302A             ;; ZEROS-4/5
15726  302A 2E 00       L2FFB:  LD      L,$00           ;
15727  302C 57                  LD      D,A             ;
15728  302D 5D                  LD      E,L             ;
15729  302E D9                  EXX                     ;
15730  302F 11 00 00            LD      DE,$0000        ;
15731  3032 C9                  RET                     ;
15732  3033             
15733  3033             ; ------------------
15734  3033             ; Add back any carry
15735  3033             ; ------------------
15736  3033             ;
15737  3033             ;
15738  3033             
15739  3033             ;; ADD-BACK
15740  3033 1C          L3004:  INC     E               ;
15741  3034 C0                  RET     NZ              ;
15742  3035             
15743  3035 14                  INC      D              ;
15744  3036 C0                  RET     NZ              ;
15745  3037             
15746  3037 D9                  EXX                     ;
15747  3038 1C                  INC     E               ;
15748  3039 20 01               JR      NZ,L300D        ; to ALL-ADDED
15749  303B             
15750  303B 14                  INC     D               ;
15751  303C             
15752  303C             ;; ALL-ADDED
15753  303C D9          L300D:  EXX                     ;
15754  303D C9                  RET                     ;
15755  303E             
15756  303E             ; -----------------------
15757  303E             ; Handle subtraction (03)
15758  303E             ; -----------------------
15759  303E             ; Subtraction is done by switching the sign byte/bit of the second number
15760  303E             ; which may be integer of floating point and continuing into addition.
15761  303E             
15762  303E             ;; subtract
15763  303E EB          L300F:  EX      DE,HL           ; address second number with HL
15764  303F             
15765  303F CD 9D 34            CALL    L346E           ; routine NEGATE switches sign
15766  3042             
15767  3042 EB                  EX      DE,HL           ; address first number again
15768  3043                                             ; and continue.
15769  3043             
15770  3043             ; --------------------
15771  3043             ; Handle addition (0F)
15772  3043             ; --------------------
15773  3043             ; HL points to first number, DE to second.
15774  3043             ; If they are both integers, then go for the easy route.
15775  3043             
15776  3043             ;; addition
15777  3043 1A          L3014:  LD      A,(DE)          ; fetch first byte of second
15778  3044 B6                  OR      (HL)            ; combine with first byte of first
15779  3045 20 26               JR      NZ,L303E        ; forward to FULL-ADDN if at least one was
15780  3047                                             ; in floating point form.
15781  3047             
15782  3047             ; continue if both were small integers.
15783  3047             
15784  3047 D5                  PUSH    DE              ; save pointer to lowest number for result.
15785  3048             
15786  3048 23                  INC     HL              ; address sign byte and
15787  3049 E5                  PUSH    HL              ; push the pointer.
15788  304A             
15789  304A 23                  INC     HL              ; address low byte
15790  304B 5E                  LD      E,(HL)          ; to E
15791  304C 23                  INC     HL              ; address high byte
15792  304D 56                  LD      D,(HL)          ; to D
15793  304E 23                  INC     HL              ; address unused byte
15794  304F             
15795  304F 23                  INC     HL              ; address known zero indicator of 1st number
15796  3050 23                  INC     HL              ; address sign byte
15797  3051             
15798  3051 7E                  LD      A,(HL)          ; sign to A, $00 or $FF
15799  3052             
15800  3052 23                  INC     HL              ; address low byte
15801  3053 4E                  LD      C,(HL)          ; to C
15802  3054 23                  INC     HL              ; address high byte
15803  3055 46                  LD      B,(HL)          ; to B
15804  3056             
15805  3056 E1                  POP     HL              ; pop result sign pointer
15806  3057 EB                  EX      DE,HL           ; integer to HL
15807  3058             
15808  3058 09                  ADD     HL,BC           ; add to the other one in BC
15809  3059                                             ; setting carry if overflow.
15810  3059             
15811  3059 EB                  EX      DE,HL           ; save result in DE bringing back sign pointer
15812  305A             
15813  305A 8E                  ADC     A,(HL)          ; if pos/pos A=01 with overflow else 00
15814  305B                                             ; if neg/neg A=FF with overflow else FE
15815  305B                                             ; if mixture A=00 with overflow else FF
15816  305B             
15817  305B 0F                  RRCA                    ; bit 0 to (C)
15818  305C             
15819  305C CE 00               ADC     A,$00           ; both acceptable signs now zero
15820  305E             
15821  305E 20 0B               JR      NZ,L303C        ; forward to ADDN-OFLW if not
15822  3060             
15823  3060 9F                  SBC     A,A             ; restore a negative result sign
15824  3061             
15825  3061 77                  LD      (HL),A          ;
15826  3062 23                  INC     HL              ;
15827  3063 73                  LD      (HL),E          ;
15828  3064 23                  INC     HL              ;
15829  3065 72                  LD      (HL),D          ;
15830  3066 2B                  DEC     HL              ;
15831  3067 2B                  DEC     HL              ;
15832  3068 2B                  DEC     HL              ;
15833  3069             
15834  3069 D1                  POP     DE              ; STKEND
15835  306A C9                  RET                     ;
15836  306B             
15837  306B             ; ---
15838  306B             
15839  306B             ;; ADDN-OFLW
15840  306B 2B          L303C:  DEC     HL              ;
15841  306C D1                  POP     DE              ;
15842  306D             
15843  306D             ;; FULL-ADDN
15844  306D CD C2 32    L303E:  CALL    L3293           ; routine RE-ST-TWO
15845  3070 D9                  EXX                     ;
15846  3071 E5                  PUSH    HL              ;
15847  3072 D9                  EXX                     ;
15848  3073 D5                  PUSH    DE              ;
15849  3074 E5                  PUSH    HL              ;
15850  3075 CD CA 2F            CALL    L2F9B           ; routine PREP-ADD
15851  3078 47                  LD      B,A             ;
15852  3079 EB                  EX      DE,HL           ;
15853  307A CD CA 2F            CALL    L2F9B           ; routine PREP-ADD
15854  307D 4F                  LD       C,A            ;
15855  307E B8                  CP      B               ;
15856  307F 30 03               JR      NC,L3055        ; to SHIFT-LEN
15857  3081             
15858  3081 78                  LD      A,B             ;
15859  3082 41                  LD      B,C             ;
15860  3083 EB                  EX      DE,HL           ;
15861  3084             
15862  3084             ;; SHIFT-LEN
15863  3084 F5          L3055:  PUSH    AF              ;
15864  3085 90                  SUB     B               ;
15865  3086 CD E9 2F            CALL    L2FBA           ; routine FETCH-TWO
15866  3089 CD 0C 30            CALL    L2FDD           ; routine SHIFT-FP
15867  308C F1                  POP     AF              ;
15868  308D E1                  POP     HL              ;
15869  308E 77                  LD      (HL),A          ;
15870  308F E5                  PUSH    HL              ;
15871  3090 68                  LD      L,B             ;
15872  3091 61                  LD      H,C             ;
15873  3092 19                  ADD     HL,DE           ;
15874  3093 D9                  EXX                     ;
15875  3094 EB                  EX      DE,HL           ;
15876  3095 ED 4A               ADC     HL,BC           ;
15877  3097 EB                  EX      DE,HL           ;
15878  3098 7C                  LD      A,H             ;
15879  3099 8D                  ADC     A,L             ;
15880  309A 6F                  LD      L,A             ;
15881  309B 1F                  RRA                     ;
15882  309C AD                  XOR     L               ;
15883  309D D9                  EXX                     ;
15884  309E EB                  EX      DE,HL           ;
15885  309F E1                  POP     HL              ;
15886  30A0 1F                  RRA                     ;
15887  30A1 30 08               JR      NC,L307C        ; to TEST-NEG
15888  30A3             
15889  30A3 3E 01               LD      A,$01           ;
15890  30A5 CD 0C 30            CALL    L2FDD           ; routine SHIFT-FP
15891  30A8 34                  INC     (HL)            ;
15892  30A9 28 23               JR      Z,L309F         ; to ADD-REP-6
15893  30AB             
15894  30AB             ;; TEST-NEG
15895  30AB D9          L307C:  EXX                     ;
15896  30AC 7D                  LD      A,L             ;
15897  30AD E6 80               AND     $80             ;
15898  30AF D9                  EXX                     ;
15899  30B0 23                  INC     HL              ;
15900  30B1 77                  LD      (HL),A          ;
15901  30B2 2B                  DEC     HL              ;
15902  30B3 28 1F               JR      Z,L30A5         ; to GO-NC-MLT
15903  30B5             
15904  30B5 7B                  LD      A,E             ;
15905  30B6 ED 44               NEG                     ; Negate
15906  30B8 3F                  CCF                     ; Complement Carry Flag
15907  30B9 5F                  LD      E,A             ;
15908  30BA 7A                  LD      A,D             ;
15909  30BB 2F                  CPL                     ;
15910  30BC CE 00               ADC     A,$00           ;
15911  30BE 57                  LD      D,A             ;
15912  30BF D9                  EXX                     ;
15913  30C0 7B                  LD      A,E             ;
15914  30C1 2F                  CPL                     ;
15915  30C2 CE 00               ADC     A,$00           ;
15916  30C4 5F                  LD      E,A             ;
15917  30C5 7A                  LD      A,D             ;
15918  30C6 2F                  CPL                     ;
15919  30C7 CE 00               ADC     A,$00           ;
15920  30C9 30 07               JR      NC,L30A3        ; to END-COMPL
15921  30CB             
15922  30CB 1F                  RRA                     ;
15923  30CC D9                  EXX                     ;
15924  30CD 34                  INC     (HL)            ;
15925  30CE             
15926  30CE             ;; ADD-REP-6
15927  30CE CA DC 31    L309F:  JP      Z,L31AD         ; to REPORT-6
15928  30D1             
15929  30D1 D9                  EXX                     ;
15930  30D2             
15931  30D2             ;; END-COMPL
15932  30D2 57          L30A3:  LD      D,A             ;
15933  30D3 D9                  EXX                     ;
15934  30D4             
15935  30D4             ;; GO-NC-MLT
15936  30D4 AF          L30A5:  XOR     A               ;
15937  30D5 C3 84 31            JP      L3155           ; to TEST-NORM
15938  30D8             
15939  30D8             ; -----------------------------
15940  30D8             ; Used in 16 bit multiplication
15941  30D8             ; -----------------------------
15942  30D8             ; This routine is used, in the first instance, by the multiply calculator
15943  30D8             ; literal to perform an integer multiplication in preference to
15944  30D8             ; 32-bit multiplication to which it will resort if this overflows.
15945  30D8             ;
15946  30D8             ; It is also used by STK-VAR to calculate array subscripts and by DIM to
15947  30D8             ; calculate the space required for multi-dimensional arrays.
15948  30D8             
15949  30D8             ;; HL-HL*DE
15950  30D8 C5          L30A9:  PUSH    BC              ; preserve BC throughout
15951  30D9 06 10               LD      B,$10           ; set B to 16
15952  30DB 7C                  LD      A,H             ; save H in A high byte
15953  30DC 4D                  LD      C,L             ; save L in C low byte
15954  30DD 21 00 00            LD      HL,$0000        ; initialize result to zero
15955  30E0             
15956  30E0             ; now enter a loop.
15957  30E0             
15958  30E0             ;; HL-LOOP
15959  30E0 29          L30B1:  ADD     HL,HL           ; double result
15960  30E1 38 0A               JR      C,L30BE         ; to HL-END if overflow
15961  30E3             
15962  30E3 CB 11               RL      C               ; shift AC left into carry
15963  30E5 17                  RLA                     ;
15964  30E6 30 03               JR      NC,L30BC        ; to HL-AGAIN to skip addition if no carry
15965  30E8             
15966  30E8 19                  ADD     HL,DE           ; add in DE
15967  30E9 38 02               JR      C,L30BE         ; to HL-END if overflow
15968  30EB             
15969  30EB             ;; HL-AGAIN
15970  30EB 10 F3       L30BC:  DJNZ    L30B1           ; back to HL-LOOP for all 16 bits
15971  30ED             
15972  30ED             ;; HL-END
15973  30ED C1          L30BE:  POP     BC              ; restore preserved BC
15974  30EE C9                  RET                     ; return with carry reset if successful
15975  30EF                                             ; and result in HL.
15976  30EF             
15977  30EF             ; ----------------------------------------------
15978  30EF             ; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
15979  30EF             ; ----------------------------------------------
15980  30EF             ;   This routine is called in succession from multiply and divide to prepare
15981  30EF             ;   two mantissas by setting the leftmost bit that is used for the sign.
15982  30EF             ;   On the first call A holds zero and picks up the sign bit. On the second
15983  30EF             ;   call the two bits are XORed to form the result sign - minus * minus giving
15984  30EF             ;   plus etc. If either number is zero then this is flagged.
15985  30EF             ;   HL addresses the exponent.
15986  30EF             
15987  30EF             ;; PREP-M/D
15988  30EF CD 18 35    L30C0:  CALL    L34E9           ; routine TEST-ZERO  preserves accumulator.
15989  30F2 D8                  RET     C               ; return carry set if zero
15990  30F3             
15991  30F3 23                  INC     HL              ; address first byte of mantissa
15992  30F4 AE                  XOR     (HL)            ; pick up the first or xor with first.
15993  30F5 CB FE               SET     7,(HL)          ; now set to give true 32-bit mantissa
15994  30F7 2B                  DEC     HL              ; point to exponent
15995  30F8 C9                  RET                     ; return with carry reset
15996  30F9             
15997  30F9             ; ----------------------
15998  30F9             ; THE 'MULTIPLY' ROUTINE     
15999  30F9             ; ----------------------
16000  30F9             ; (offset: $04 'multiply')
16001  30F9             ;
16002  30F9             ;
16003  30F9             ;   "He said go forth and something about mathematics, I wasn't really 
16004  30F9             ;    listening" - overheard conversation between two unicorns.
16005  30F9             ;    [ The Odd Streak ].
16006  30F9             
16007  30F9             ;; multiply
16008  30F9 1A          L30CA:  LD      A,(DE)          ;
16009  30FA B6                  OR      (HL)            ;
16010  30FB 20 22               JR      NZ,L30F0        ; to MULT-LONG
16011  30FD             
16012  30FD D5                  PUSH    DE              ;
16013  30FE E5                  PUSH    HL              ;
16014  30FF D5                  PUSH    DE              ;
16015  3100 CD AE 2D            CALL    L2D7F           ; routine INT-FETCH
16016  3103 EB                  EX      DE,HL           ;
16017  3104 E3                  EX      (SP),HL         ;
16018  3105 41                  LD      B,C             ;
16019  3106 CD AE 2D            CALL    L2D7F           ; routine INT-FETCH
16020  3109 78                  LD      A,B             ;
16021  310A A9                  XOR     C               ;
16022  310B 4F                  LD      C,A             ;
16023  310C E1                  POP     HL              ;
16024  310D CD D8 30            CALL    L30A9           ; routine HL-HL*DE
16025  3110 EB                  EX      DE,HL           ;
16026  3111 E1                  POP     HL              ;
16027  3112 38 0A               JR      C,L30EF         ; to MULT-OFLW
16028  3114             
16029  3114 7A                  LD      A,D             ;
16030  3115 B3                  OR      E               ;
16031  3116 20 01               JR      NZ,L30EA        ; to MULT-RSLT
16032  3118             
16033  3118 4F                  LD      C,A             ;
16034  3119             
16035  3119             ;; MULT-RSLT
16036  3119 CD BD 2D    L30EA:  CALL    L2D8E           ; routine INT-STORE
16037  311C D1                  POP      DE             ;
16038  311D C9                  RET                     ;
16039  311E             
16040  311E             ; ---
16041  311E             
16042  311E             ;; MULT-OFLW
16043  311E D1          L30EF:  POP     DE              ;
16044  311F             
16045  311F             ;; MULT-LONG
16046  311F CD C2 32    L30F0:  CALL    L3293           ; routine RE-ST-TWO
16047  3122 AF                  XOR     A               ;
16048  3123 CD EF 30            CALL    L30C0           ; routine PREP-M/D
16049  3126 D8                  RET     C               ;
16050  3127             
16051  3127 D9                  EXX                     ;
16052  3128 E5                  PUSH    HL              ;
16053  3129 D9                  EXX                     ;
16054  312A D5                  PUSH    DE              ;
16055  312B EB                  EX      DE,HL           ;
16056  312C CD EF 30            CALL    L30C0           ; routine PREP-M/D
16057  312F EB                  EX      DE,HL           ;
16058  3130 38 5A               JR      C,L315D         ; to ZERO-RSLT
16059  3132             
16060  3132 E5                  PUSH    HL              ;
16061  3133 CD E9 2F            CALL    L2FBA           ; routine FETCH-TWO
16062  3136 78                  LD      A,B             ;
16063  3137 A7                  AND     A               ;
16064  3138 ED 62               SBC     HL,HL           ;
16065  313A D9                  EXX                     ;
16066  313B E5                  PUSH    HL              ;
16067  313C ED 62               SBC     HL,HL           ;
16068  313E D9                  EXX                     ;
16069  313F 06 21               LD      B,$21           ;
16070  3141 18 11               JR      L3125           ; to STRT-MLT
16071  3143             
16072  3143             ; ---
16073  3143             
16074  3143             ;; MLT-LOOP
16075  3143 30 05       L3114:  JR      NC,L311B        ; to NO-ADD
16076  3145             
16077  3145 19                  ADD     HL,DE           ;
16078  3146 D9                  EXX                     ;
16079  3147 ED 5A               ADC     HL,DE           ;
16080  3149 D9                  EXX                     ;
16081  314A             
16082  314A             ;; NO-ADD
16083  314A D9          L311B:  EXX                     ;
16084  314B CB 1C               RR      H               ;
16085  314D CB 1D               RR      L               ;
16086  314F D9                  EXX                     ;
16087  3150 CB 1C               RR      H               ;
16088  3152 CB 1D               RR      L               ;
16089  3154             
16090  3154             ;; STRT-MLT
16091  3154 D9          L3125:  EXX                     ;
16092  3155 CB 18               RR      B               ;
16093  3157 CB 19               RR      C               ;
16094  3159 D9                  EXX                     ;
16095  315A CB 19               RR      C               ;
16096  315C 1F                  RRA                     ;
16097  315D 10 E4               DJNZ    L3114           ; to MLT-LOOP
16098  315F             
16099  315F EB                  EX      DE,HL           ;
16100  3160 D9                  EXX                     ;
16101  3161 EB                  EX      DE,HL           ;
16102  3162 D9                  EXX                     ;
16103  3163 C1                  POP     BC              ;
16104  3164 E1                  POP     HL              ;
16105  3165 78                  LD      A,B             ;
16106  3166 81                  ADD     A,C             ;
16107  3167 20 01               JR      NZ,L313B        ; to MAKE-EXPT
16108  3169             
16109  3169 A7                  AND     A               ;
16110  316A             
16111  316A             ;; MAKE-EXPT
16112  316A 3D          L313B:  DEC     A               ;
16113  316B 3F                  CCF                     ; Complement Carry Flag
16114  316C             
16115  316C             ;; DIVN-EXPT
16116  316C 17          L313D:  RLA                     ;
16117  316D 3F                  CCF                     ; Complement Carry Flag
16118  316E 1F                  RRA                     ;
16119  316F F2 75 31            JP      P,L3146         ; to OFLW1-CLR
16120  3172             
16121  3172 30 68               JR      NC,L31AD        ; to REPORT-6
16122  3174             
16123  3174 A7                  AND     A               ;
16124  3175             
16125  3175             ;; OFLW1-CLR
16126  3175 3C          L3146:  INC     A               ;
16127  3176 20 08               JR      NZ,L3151        ; to OFLW2-CLR
16128  3178             
16129  3178 38 06               JR      C,L3151         ; to OFLW2-CLR
16130  317A             
16131  317A D9                  EXX                     ;
16132  317B CB 7A               BIT     7,D             ;
16133  317D D9                  EXX                     ;
16134  317E 20 5C               JR      NZ,L31AD        ; to REPORT-6
16135  3180             
16136  3180             ;; OFLW2-CLR
16137  3180 77          L3151:  LD      (HL),A          ;
16138  3181 D9                  EXX                     ;
16139  3182 78                  LD      A,B             ;
16140  3183 D9                  EXX                     ;
16141  3184             
16142  3184             ;; TEST-NORM
16143  3184 30 15       L3155:  JR      NC,L316C        ; to NORMALISE
16144  3186             
16145  3186 7E                  LD      A,(HL)          ;
16146  3187 A7                  AND     A               ;
16147  3188             
16148  3188             ;; NEAR-ZERO
16149  3188 3E 80       L3159:  LD      A,$80           ;
16150  318A 28 01               JR      Z,L315E         ; to SKIP-ZERO
16151  318C             
16152  318C             ;; ZERO-RSLT
16153  318C AF          L315D:  XOR     A               ;
16154  318D             
16155  318D             ;; SKIP-ZERO
16156  318D D9          L315E:  EXX                     ;
16157  318E A2                  AND     D               ;
16158  318F CD 2A 30            CALL    L2FFB           ; routine ZEROS-4/5
16159  3192 07                  RLCA                    ;
16160  3193 77                  LD      (HL),A          ;
16161  3194 38 2E               JR      C,L3195         ; to OFLOW-CLR
16162  3196             
16163  3196 23                  INC     HL              ;
16164  3197 77                  LD      (HL),A          ;
16165  3198 2B                  DEC     HL              ;
16166  3199 18 29               JR      L3195           ; to OFLOW-CLR
16167  319B             
16168  319B             ; ---
16169  319B             
16170  319B             ;; NORMALISE
16171  319B 06 20       L316C:  LD      B,$20           ;
16172  319D             
16173  319D             ;; SHIFT-ONE
16174  319D D9          L316E:  EXX                     ;
16175  319E CB 7A               BIT     7,D             ;
16176  31A0 D9                  EXX                     ;
16177  31A1 20 12               JR      NZ,L3186        ; to NORML-NOW
16178  31A3             
16179  31A3 07                  RLCA                    ;
16180  31A4 CB 13               RL      E               ;
16181  31A6 CB 12               RL      D               ;
16182  31A8 D9                  EXX                     ;
16183  31A9 CB 13               RL      E               ;
16184  31AB CB 12               RL      D               ;
16185  31AD D9                  EXX                     ;
16186  31AE 35                  DEC     (HL)            ;
16187  31AF 28 D7               JR      Z,L3159         ; to NEAR-ZERO
16188  31B1             
16189  31B1 10 EA               DJNZ    L316E           ; to SHIFT-ONE
16190  31B3             
16191  31B3 18 D7               JR      L315D           ; to ZERO-RSLT
16192  31B5             
16193  31B5             ; ---
16194  31B5             
16195  31B5             ;; NORML-NOW
16196  31B5 17          L3186:  RLA                     ;
16197  31B6 30 0C               JR      NC,L3195        ; to OFLOW-CLR
16198  31B8             
16199  31B8 CD 33 30            CALL    L3004           ; routine ADD-BACK
16200  31BB 20 07               JR      NZ,L3195        ; to OFLOW-CLR
16201  31BD             
16202  31BD D9                  EXX                     ;
16203  31BE 16 80               LD       D,$80          ;
16204  31C0 D9                  EXX                     ;
16205  31C1 34                  INC     (HL)            ;
16206  31C2 28 18               JR      Z,L31AD         ; to REPORT-6
16207  31C4             
16208  31C4             ;; OFLOW-CLR
16209  31C4 E5          L3195:  PUSH    HL              ;
16210  31C5 23                  INC     HL              ;
16211  31C6 D9                  EXX                     ;
16212  31C7 D5                  PUSH    DE              ;
16213  31C8 D9                  EXX                     ;
16214  31C9 C1                  POP     BC              ;
16215  31CA 78                  LD      A,B             ;
16216  31CB 17                  RLA                     ;
16217  31CC CB 16               RL      (HL)            ;
16218  31CE 1F                  RRA                     ;
16219  31CF 77                  LD      (HL),A          ;
16220  31D0 23                  INC     HL              ;
16221  31D1 71                  LD      (HL),C          ;
16222  31D2 23                  INC     HL              ;
16223  31D3 72                  LD      (HL),D          ;
16224  31D4 23                  INC     HL              ;
16225  31D5 73                  LD      (HL),E          ;
16226  31D6 E1                  POP     HL              ;
16227  31D7 D1                  POP     DE              ;
16228  31D8 D9                  EXX                     ;
16229  31D9 E1                  POP     HL              ;
16230  31DA D9                  EXX                     ;
16231  31DB C9                  RET                     ;
16232  31DC             
16233  31DC             ; ---
16234  31DC             
16235  31DC             ;; REPORT-6
16236  31DC CF          L31AD:  RST     08H             ; ERROR-1
16237  31DD 05                  DEFB    $05             ; Error Report: Number too big
16238  31DE             
16239  31DE             ; ----------------------
16240  31DE             ; THE 'DIVISION' ROUTINE
16241  31DE             ; ----------------------
16242  31DE             ; (offset: $05 'division')
16243  31DE             ;
16244  31DE             ;   "He who can properly define and divide is to be considered a god"
16245  31DE             ;   - Plato,  429 - 347 B.C.
16246  31DE             
16247  31DE             ;; division
16248  31DE CD C2 32    L31AF:  CALL    L3293           ; routine RE-ST-TWO
16249  31E1 EB                  EX      DE,HL           ;
16250  31E2 AF                  XOR     A               ;
16251  31E3 CD EF 30            CALL    L30C0           ; routine PREP-M/D
16252  31E6 38 F4               JR      C,L31AD         ; to REPORT-6
16253  31E8             
16254  31E8 EB                  EX      DE,HL           ;
16255  31E9 CD EF 30            CALL    L30C0           ; routine PREP-M/D
16256  31EC D8                  RET     C               ;
16257  31ED             
16258  31ED D9                  EXX                     ;
16259  31EE E5                  PUSH    HL              ;
16260  31EF D9                  EXX                     ;
16261  31F0 D5                  PUSH    DE              ;
16262  31F1 E5                  PUSH    HL              ;
16263  31F2 CD E9 2F            CALL    L2FBA           ; routine FETCH-TWO
16264  31F5 D9                  EXX                     ;
16265  31F6 E5                  PUSH    HL              ;
16266  31F7 60                  LD      H,B             ;
16267  31F8 69                  LD      L,C             ;
16268  31F9 D9                  EXX                     ;
16269  31FA 61                  LD      H,C             ;
16270  31FB 68                  LD      L,B             ;
16271  31FC AF                  XOR     A               ;
16272  31FD 06 DF               LD      B,$DF           ;
16273  31FF 18 10               JR      L31E2           ; to DIV-START
16274  3201             
16275  3201             ; ---
16276  3201             
16277  3201             ;; DIV-LOOP
16278  3201 17          L31D2:  RLA                     ;
16279  3202 CB 11               RL      C               ;
16280  3204 D9                  EXX                     ;
16281  3205 CB 11               RL      C               ;
16282  3207 CB 10               RL      B               ;
16283  3209 D9                  EXX                     ;
16284  320A             
16285  320A             ;; div-34th
16286  320A 29          L31DB:  ADD     HL,HL           ;
16287  320B D9                  EXX                     ;
16288  320C ED 6A               ADC     HL,HL           ;
16289  320E D9                  EXX                     ;
16290  320F 38 10               JR      C,L31F2         ; to SUBN-ONLY
16291  3211             
16292  3211             ;; DIV-START
16293  3211 ED 52       L31E2:  SBC     HL,DE           ;
16294  3213 D9                  EXX                     ;
16295  3214 ED 52               SBC     HL,DE           ;
16296  3216 D9                  EXX                     ;
16297  3217 30 0F               JR      NC,L31F9        ; to NO-RSTORE
16298  3219             
16299  3219 19                  ADD     HL,DE           ;
16300  321A D9                  EXX                     ;
16301  321B ED 5A               ADC     HL,DE           ;
16302  321D D9                  EXX                     ;
16303  321E A7                  AND     A               ;
16304  321F 18 08               JR      L31FA           ; to COUNT-ONE
16305  3221             
16306  3221             ; ---
16307  3221             
16308  3221             ;; SUBN-ONLY
16309  3221 A7          L31F2:  AND     A               ;
16310  3222 ED 52               SBC     HL,DE           ;
16311  3224 D9                  EXX                     ;
16312  3225 ED 52               SBC     HL,DE           ;
16313  3227 D9                  EXX                     ;
16314  3228             
16315  3228             ;; NO-RSTORE
16316  3228 37          L31F9:  SCF                     ; Set Carry Flag
16317  3229             
16318  3229             ;; COUNT-ONE
16319  3229 04          L31FA:  INC     B               ;
16320  322A FA 01 32            JP      M,L31D2         ; to DIV-LOOP
16321  322D             
16322  322D F5                  PUSH    AF              ;
16323  322E 28 E1               JR      Z,L31E2         ; to DIV-START
16324  3230             
16325  3230             ;
16326  3230             ;
16327  3230             ;
16328  3230             ;
16329  3230             
16330  3230 5F                  LD      E,A             ;
16331  3231 51                  LD      D,C             ;
16332  3232 D9                  EXX                     ;
16333  3233 59                  LD      E,C             ;
16334  3234 50                  LD      D,B             ;
16335  3235 F1                  POP     AF              ;
16336  3236 CB 18               RR      B               ;
16337  3238 F1                  POP     AF              ;
16338  3239 CB 18               RR      B               ;
16339  323B D9                  EXX                     ;
16340  323C C1                  POP     BC              ;
16341  323D E1                  POP     HL              ;
16342  323E 78                  LD      A,B             ;
16343  323F 91                  SUB     C               ;
16344  3240 C3 6C 31            JP      L313D           ; jump back to DIVN-EXPT
16345  3243             
16346  3243             ; ------------------------------------
16347  3243             ; Integer truncation towards zero ($3A)
16348  3243             ; ------------------------------------
16349  3243             ;
16350  3243             ;
16351  3243             
16352  3243             ;; truncate
16353  3243 7E          L3214:  LD      A,(HL)          ;
16354  3244 A7                  AND     A               ;
16355  3245 C8                  RET     Z               ;
16356  3246             
16357  3246 FE 81               CP      $81             ;
16358  3248 30 06               JR      NC,L3221        ; to T-GR-ZERO
16359  324A             
16360  324A 36 00               LD      (HL),$00        ;
16361  324C 3E 20               LD      A,$20           ;
16362  324E 18 51               JR      L3272           ; to NIL-BYTES
16363  3250             
16364  3250             ; ---
16365  3250             
16366  3250             ;; T-GR-ZERO
16367  3250 FE 91       L3221:  CP      $91             ;
16368  3252 20 1A               JR      NZ,L323F        ; to T-SMALL
16369  3254             
16370  3254 23                  INC     HL              ;
16371  3255 23                  INC     HL              ;
16372  3256 23                  INC     HL              ;
16373  3257 3E 80               LD      A,$80           ;
16374  3259 A6                  AND     (HL)            ;
16375  325A 2B                  DEC     HL              ;
16376  325B B6                  OR      (HL)            ;
16377  325C 2B                  DEC     HL              ;
16378  325D 20 03               JR      NZ,L3233        ; to T-FIRST
16379  325F             
16380  325F 3E 80               LD      A,$80           ;
16381  3261 AE                  XOR     (HL)            ;
16382  3262             
16383  3262             ;; T-FIRST
16384  3262 2B          L3233:  DEC     HL              ;
16385  3263 20 36               JR      NZ,L326C        ; to T-EXPNENT
16386  3265             
16387  3265 77                  LD      (HL),A          ;
16388  3266 23                  INC     HL              ;
16389  3267 36 FF               LD      (HL),$FF        ;
16390  3269 2B                  DEC     HL              ;
16391  326A 3E 18               LD      A,$18           ;
16392  326C 18 33               JR      L3272           ; to NIL-BYTES
16393  326E             
16394  326E             ; ---
16395  326E             
16396  326E             ;; T-SMALL
16397  326E 30 2C       L323F:  JR      NC,L326D        ; to X-LARGE
16398  3270             
16399  3270 D5                  PUSH    DE              ;
16400  3271 2F                  CPL                     ;
16401  3272 C6 91               ADD     A,$91           ;
16402  3274 23                  INC     HL              ;
16403  3275 56                  LD      D,(HL)          ;
16404  3276 23                  INC     HL              ;
16405  3277 5E                  LD      E,(HL)          ;
16406  3278 2B                  DEC     HL              ;
16407  3279 2B                  DEC     HL              ;
16408  327A 0E 00               LD      C,$00           ;
16409  327C CB 7A               BIT     7,D             ;
16410  327E 28 01               JR      Z,L3252         ; to T-NUMERIC
16411  3280             
16412  3280 0D                  DEC     C               ;
16413  3281             
16414  3281             ;; T-NUMERIC
16415  3281 CB FA       L3252:  SET     7,D             ;
16416  3283 06 08               LD      B,$08           ;
16417  3285 90                  SUB     B               ;
16418  3286 80                  ADD     A,B             ;
16419  3287 38 04               JR      C,L325E         ; to T-TEST
16420  3289             
16421  3289 5A                  LD      E,D             ;
16422  328A 16 00               LD      D,$00           ;
16423  328C 90                  SUB     B               ;
16424  328D             
16425  328D             ;; T-TEST
16426  328D 28 07       L325E:  JR      Z,L3267         ; to T-STORE
16427  328F             
16428  328F 47                  LD      B,A             ;
16429  3290             
16430  3290             ;; T-SHIFT
16431  3290 CB 3A       L3261:  SRL     D               ;
16432  3292 CB 1B               RR      E               ;
16433  3294 10 FA               DJNZ    L3261           ; to T-SHIFT
16434  3296             
16435  3296             ;; T-STORE
16436  3296 CD BD 2D    L3267:  CALL    L2D8E           ; routine INT-STORE
16437  3299 D1                  POP     DE              ;
16438  329A C9                  RET                     ;
16439  329B             
16440  329B             ; ---
16441  329B             
16442  329B             ;; T-EXPNENT
16443  329B 7E          L326C:  LD      A,(HL)          ;
16444  329C             
16445  329C             ;; X-LARGE
16446  329C D6 A0       L326D:  SUB     $A0             ;
16447  329E F0                  RET     P               ;
16448  329F             
16449  329F ED 44               NEG                     ; Negate
16450  32A1             
16451  32A1             ;; NIL-BYTES
16452  32A1 D5          L3272:  PUSH    DE              ;
16453  32A2 EB                  EX      DE,HL           ;
16454  32A3 2B                  DEC     HL              ;
16455  32A4 47                  LD      B,A             ;
16456  32A5 CB 38               SRL     B               ;
16457  32A7 CB 38               SRL     B               ;
16458  32A9 CB 38               SRL     B               ;
16459  32AB 28 05               JR      Z,L3283         ; to BITS-ZERO
16460  32AD             
16461  32AD             ;; BYTE-ZERO
16462  32AD 36 00       L327E:  LD      (HL),$00        ;
16463  32AF 2B                  DEC     HL              ;
16464  32B0 10 FB               DJNZ    L327E           ; to BYTE-ZERO
16465  32B2             
16466  32B2             ;; BITS-ZERO
16467  32B2 E6 07       L3283:  AND     $07             ;
16468  32B4 28 09               JR      Z,L3290         ; to IX-END
16469  32B6             
16470  32B6 47                  LD      B,A             ;
16471  32B7 3E FF               LD      A,$FF           ;
16472  32B9             
16473  32B9             ;; LESS-MASK
16474  32B9 CB 27       L328A:  SLA     A               ;
16475  32BB 10 FC               DJNZ    L328A           ; to LESS-MASK
16476  32BD             
16477  32BD A6                  AND     (HL)            ;
16478  32BE 77                  LD      (HL),A          ;
16479  32BF             
16480  32BF             ;; IX-END
16481  32BF EB          L3290:  EX      DE,HL           ;
16482  32C0 D1                  POP     DE              ;
16483  32C1 C9                  RET                     ;
16484  32C2             
16485  32C2             ; ----------------------------------
16486  32C2             ; Storage of numbers in 5 byte form.
16487  32C2             ; ==================================
16488  32C2             ; Both integers and floating-point numbers can be stored in five bytes.
16489  32C2             ; Zero is a special case stored as 5 zeros.
16490  32C2             ; For integers the form is
16491  32C2             ; Byte 1 - zero,
16492  32C2             ; Byte 2 - sign byte, $00 +ve, $FF -ve.
16493  32C2             ; Byte 3 - Low byte of integer.
16494  32C2             ; Byte 4 - High byte
16495  32C2             ; Byte 5 - unused but always zero.
16496  32C2             ;
16497  32C2             ; it seems unusual to store the low byte first but it is just as easy either
16498  32C2             ; way. Statistically it just increases the chances of trailing zeros which
16499  32C2             ; is an advantage elsewhere in saving ROM code.
16500  32C2             ;
16501  32C2             ;             zero     sign     low      high    unused
16502  32C2             ; So +1 is  00000000 00000000 00000001 00000000 00000000
16503  32C2             ;
16504  32C2             ; and -1 is 00000000 11111111 11111111 11111111 00000000
16505  32C2             ;
16506  32C2             ; much of the arithmetic found in BASIC lines can be done using numbers
16507  32C2             ; in this form using the Z80's 16 bit register operation ADD.
16508  32C2             ; (multiplication is done by a sequence of additions).
16509  32C2             ;
16510  32C2             ; Storing -ve integers in two's complement form, means that they are ready for
16511  32C2             ; addition and you might like to add the numbers above to prove that the
16512  32C2             ; answer is zero. If, as in this case, the carry is set then that denotes that
16513  32C2             ; the result is positive. This only applies when the signs don't match.
16514  32C2             ; With positive numbers a carry denotes the result is out of integer range.
16515  32C2             ; With negative numbers a carry denotes the result is within range.
16516  32C2             ; The exception to the last rule is when the result is -65536
16517  32C2             ;
16518  32C2             ; Floating point form is an alternative method of storing numbers which can
16519  32C2             ; be used for integers and larger (or fractional) numbers.
16520  32C2             ;
16521  32C2             ; In this form 1 is stored as
16522  32C2             ;           10000001 00000000 00000000 00000000 00000000
16523  32C2             ;
16524  32C2             ; When a small integer is converted to a floating point number the last two
16525  32C2             ; bytes are always blank so they are omitted in the following steps
16526  32C2             ;
16527  32C2             ; first make exponent +1 +16d  (bit 7 of the exponent is set if positive)
16528  32C2             
16529  32C2             ; 10010001 00000000 00000001
16530  32C2             ; 10010000 00000000 00000010 <-  now shift left and decrement exponent
16531  32C2             ; ...
16532  32C2             ; 10000010 01000000 00000000 <-  until a 1 abuts the imaginary point
16533  32C2             ; 10000001 10000000 00000000     to the left of the mantissa.
16534  32C2             ;
16535  32C2             ; however since the leftmost bit of the mantissa is always set then it can
16536  32C2             ; be used to denote the sign of the mantissa and put back when needed by the
16537  32C2             ; PREP routines which gives
16538  32C2             ;
16539  32C2             ; 10000001 00000000 00000000
16540  32C2             
16541  32C2             ; ----------------------------------------------
16542  32C2             ; THE 'RE-STACK TWO "SMALL" INTEGERS' SUBROUTINE
16543  32C2             ; ----------------------------------------------
16544  32C2             ;   This routine is called to re-stack two numbers in full floating point form
16545  32C2             ;   e.g. from mult when integer multiplication has overflowed.
16546  32C2             
16547  32C2             ;; RE-ST-TWO
16548  32C2 CD C5 32    L3293:  CALL    L3296           ; routine RESTK-SUB  below and continue
16549  32C5                                             ; into the routine to do the other one.
16550  32C5             
16551  32C5             ;; RESTK-SUB
16552  32C5 EB          L3296:  EX      DE,HL           ; swap pointers
16553  32C6             
16554  32C6             ; ---------------------------------------------
16555  32C6             ; THE 'RE-STACK ONE "SMALL" INTEGER' SUBROUTINE
16556  32C6             ; ---------------------------------------------
16557  32C6             ; (offset: $3D 're-stack')
16558  32C6             ;   This routine re-stacks an integer, usually on the calculator stack, in full 
16559  32C6             ;   floating point form.  HL points to first byte.
16560  32C6             
16561  32C6             ;; re-stack
16562  32C6 7E          L3297:  LD      A,(HL)          ; Fetch Exponent byte to A
16563  32C7 A7                  AND     A               ; test it
16564  32C8 C0                  RET     NZ              ; return if not zero as already in full
16565  32C9                                             ; floating-point form.
16566  32C9             
16567  32C9 D5                  PUSH    DE              ; preserve DE.
16568  32CA CD AE 2D            CALL    L2D7F           ; routine INT-FETCH
16569  32CD                                             ; integer to DE, sign to C.
16570  32CD             
16571  32CD             ; HL points to 4th byte.
16572  32CD             
16573  32CD AF                  XOR     A               ; clear accumulator.
16574  32CE 23                  INC     HL              ; point to 5th.
16575  32CF 77                  LD      (HL),A          ; and blank.
16576  32D0 2B                  DEC     HL              ; point to 4th.
16577  32D1 77                  LD      (HL),A          ; and blank.
16578  32D2             
16579  32D2 06 91               LD      B,$91           ; set exponent byte +ve $81
16580  32D4                                             ; and imaginary dec point 16 bits to right
16581  32D4                                             ; of first bit.
16582  32D4             
16583  32D4             ;   we could skip to normalize now but it's quicker to avoid normalizing 
16584  32D4             ;   through an empty D.
16585  32D4             
16586  32D4 7A                  LD      A,D             ; fetch the high byte D
16587  32D5 A7                  AND     A               ; is it zero ?
16588  32D6 20 08               JR      NZ,L32B1        ; skip to RS-NRMLSE if not.
16589  32D8             
16590  32D8 B3                  OR      E               ; low byte E to A and test for zero
16591  32D9 42                  LD      B,D             ; set B exponent to 0
16592  32DA 28 10               JR      Z,L32BD         ; forward to RS-STORE if value is zero.
16593  32DC             
16594  32DC 53                  LD      D,E             ; transfer E to D
16595  32DD 58                  LD      E,B             ; set E to 0
16596  32DE 06 89               LD      B,$89           ; reduce the initial exponent by eight.
16597  32E0             
16598  32E0             
16599  32E0             ;; RS-NRMLSE
16600  32E0 EB          L32B1:  EX      DE,HL           ; integer to HL, addr of 4th byte to DE.
16601  32E1             
16602  32E1             ;; RSTK-LOOP
16603  32E1 05          L32B2:  DEC     B               ; decrease exponent
16604  32E2 29                  ADD     HL,HL           ; shift DE left
16605  32E3 30 FC               JR      NC,L32B2        ; loop back to RSTK-LOOP
16606  32E5                                             ; until a set bit pops into carry
16607  32E5             
16608  32E5 CB 09               RRC     C               ; now rotate the sign byte $00 or $FF
16609  32E7                                             ; into carry to give a sign bit
16610  32E7             
16611  32E7 CB 1C               RR      H               ; rotate the sign bit to left of H
16612  32E9 CB 1D               RR      L               ; rotate any carry into L
16613  32EB             
16614  32EB EB                  EX      DE,HL           ; address 4th byte, normalized int to DE
16615  32EC             
16616  32EC             ;; RS-STORE
16617  32EC 2B          L32BD:  DEC     HL              ; address 3rd byte
16618  32ED 73                  LD      (HL),E          ; place E
16619  32EE 2B                  DEC     HL              ; address 2nd byte
16620  32EF 72                  LD      (HL),D          ; place D
16621  32F0 2B                  DEC     HL              ; address 1st byte
16622  32F1 70                  LD      (HL),B          ; store the exponent
16623  32F2             
16624  32F2 D1                  POP     DE              ; restore initial DE.
16625  32F3 C9                  RET                     ; return.
16626  32F4             
16627  32F4             ;****************************************
16628  32F4             ;** Part 10. FLOATING-POINT CALCULATOR **
16629  32F4             ;****************************************
16630  32F4             
16631  32F4             ; As a general rule the calculator avoids using the IY register.
16632  32F4             ; exceptions are val, val$ and str$.
16633  32F4             ; So an assembly language programmer who has disabled interrupts to use
16634  32F4             ; IY for other purposes can still use the calculator for mathematical
16635  32F4             ; purposes.
16636  32F4             
16637  32F4             
16638  32F4             ; ------------------------
16639  32F4             ; THE 'TABLE OF CONSTANTS'
16640  32F4             ; ------------------------
16641  32F4             ;
16642  32F4             ;
16643  32F4             
16644  32F4             ; used 11 times
16645  32F4             ;; stk-zero                                                 00 00 00 00 00
16646  32F4 00          L32C5:  DEFB    $00             ;;Bytes: 1
16647  32F5 B0                  DEFB    $B0             ;;Exponent $00
16648  32F6 00                  DEFB    $00             ;;(+00,+00,+00)
16649  32F7             
16650  32F7             ; used 19 times
16651  32F7             ;; stk-one                                                  00 00 01 00 00
16652  32F7 40          L32C8:  DEFB    $40             ;;Bytes: 2
16653  32F8 B0                  DEFB    $B0             ;;Exponent $00
16654  32F9 00 01               DEFB    $00,$01         ;;(+00,+00)
16655  32FB             
16656  32FB             ; used 9 times
16657  32FB             ;; stk-half                                                 80 00 00 00 00
16658  32FB 30          L32CC:  DEFB    $30             ;;Exponent: $80, Bytes: 1
16659  32FC 00                  DEFB    $00             ;;(+00,+00,+00)
16660  32FD             
16661  32FD             ; used 4 times.
16662  32FD             ;; stk-pi/2                                                 81 49 0F DA A2
16663  32FD F1          L32CE:  DEFB    $F1             ;;Exponent: $81, Bytes: 4
16664  32FE 49 0F DA A2         DEFB    $49,$0F,$DA,$A2 ;;
16665  3302             
16666  3302             ; used 3 times.
16667  3302             ;; stk-ten                                                  00 00 0A 00 00
16668  3302 40          L32D3:  DEFB    $40             ;;Bytes: 2
16669  3303 B0                  DEFB    $B0             ;;Exponent $00
16670  3304 00 0A               DEFB    $00,$0A         ;;(+00,+00)
16671  3306             
16672  3306             
16673  3306             ; ------------------------
16674  3306             ; THE 'TABLE OF ADDRESSES'
16675  3306             ; ------------------------
16676  3306             ;  "Each problem that I solved became a rule which served afterwards to solve 
16677  3306             ;   other problems" - Rene Descartes 1596 - 1650.
16678  3306             ;
16679  3306             ;   Starts with binary operations which have two operands and one result.
16680  3306             ;   Three pseudo binary operations first.
16681  3306             
16682  3306             ;; tbl-addrs
16683  3306 BE 36       L32D7:  DEFW    L368F           ; $00 Address: $368F - jump-true
16684  3308 6B 34               DEFW    L343C           ; $01 Address: $343C - exchange
16685  330A D0 33               DEFW    L33A1           ; $02 Address: $33A1 - delete
16686  330C             
16687  330C             ;   True binary operations.
16688  330C             
16689  330C 3E 30               DEFW    L300F           ; $03 Address: $300F - subtract
16690  330E F9 30               DEFW    L30CA           ; $04 Address: $30CA - multiply
16691  3310 DE 31               DEFW    L31AF           ; $05 Address: $31AF - division
16692  3312 80 38               DEFW    L3851           ; $06 Address: $3851 - to-power
16693  3314 4A 35               DEFW    L351B           ; $07 Address: $351B - or
16694  3316             
16695  3316 53 35               DEFW    L3524           ; $08 Address: $3524 - no-&-no
16696  3318 6A 35               DEFW    L353B           ; $09 Address: $353B - no-l-eql
16697  331A 6A 35               DEFW    L353B           ; $0A Address: $353B - no-gr-eql
16698  331C 6A 35               DEFW    L353B           ; $0B Address: $353B - nos-neql
16699  331E 6A 35               DEFW    L353B           ; $0C Address: $353B - no-grtr
16700  3320 6A 35               DEFW    L353B           ; $0D Address: $353B - no-less
16701  3322 6A 35               DEFW    L353B           ; $0E Address: $353B - nos-eql
16702  3324 43 30               DEFW    L3014           ; $0F Address: $3014 - addition
16703  3326             
16704  3326 5C 35               DEFW    L352D           ; $10 Address: $352D - str-&-no
16705  3328 6A 35               DEFW    L353B           ; $11 Address: $353B - str-l-eql
16706  332A 6A 35               DEFW    L353B           ; $12 Address: $353B - str-gr-eql
16707  332C 6A 35               DEFW    L353B           ; $13 Address: $353B - strs-neql
16708  332E 6A 35               DEFW    L353B           ; $14 Address: $353B - str-grtr
16709  3330 6A 35               DEFW    L353B           ; $15 Address: $353B - str-less
16710  3332 6A 35               DEFW    L353B           ; $16 Address: $353B - strs-eql
16711  3334 CB 35               DEFW    L359C           ; $17 Address: $359C - strs-add
16712  3336             
16713  3336             ;   Unary follow.
16714  3336             
16715  3336 0D 36               DEFW    L35DE           ; $18 Address: $35DE - val$
16716  3338 EB 34               DEFW    L34BC           ; $19 Address: $34BC - usr-$
16717  333A 74 36               DEFW    L3645           ; $1A Address: $3645 - read-in
16718  333C 9D 34               DEFW    L346E           ; $1B Address: $346E - negate
16719  333E             
16720  333E 98 36               DEFW    L3669           ; $1C Address: $3669 - code
16721  3340 0D 36               DEFW    L35DE           ; $1D Address: $35DE - val
16722  3342 A3 36               DEFW    L3674           ; $1E Address: $3674 - len
16723  3344 E4 37               DEFW    L37B5           ; $1F Address: $37B5 - sin
16724  3346 D9 37               DEFW    L37AA           ; $20 Address: $37AA - cos
16725  3348 09 38               DEFW    L37DA           ; $21 Address: $37DA - tan
16726  334A 62 38               DEFW    L3833           ; $22 Address: $3833 - asn
16727  334C 72 38               DEFW    L3843           ; $23 Address: $3843 - acs
16728  334E 11 38               DEFW    L37E2           ; $24 Address: $37E2 - atn
16729  3350 42 37               DEFW    L3713           ; $25 Address: $3713 - ln
16730  3352 F3 36               DEFW    L36C4           ; $26 Address: $36C4 - exp
16731  3354 DE 36               DEFW    L36AF           ; $27 Address: $36AF - int
16732  3356 79 38               DEFW    L384A           ; $28 Address: $384A - sqr
16733  3358 C1 34               DEFW    L3492           ; $29 Address: $3492 - sgn
16734  335A 99 34               DEFW    L346A           ; $2A Address: $346A - abs
16735  335C DB 34               DEFW    L34AC           ; $2B Address: $34AC - peek
16736  335E D4 34               DEFW    L34A5           ; $2C Address: $34A5 - in
16737  3360 E2 34               DEFW    L34B3           ; $2D Address: $34B3 - usr-no
16738  3362 4E 36               DEFW    L361F           ; $2E Address: $361F - str$
16739  3364 F8 35               DEFW    L35C9           ; $2F Address: $35C9 - chrs
16740  3366 30 35               DEFW    L3501           ; $30 Address: $3501 - not
16741  3368             
16742  3368             ;   End of true unary.
16743  3368             
16744  3368 EF 33               DEFW    L33C0           ; $31 Address: $33C0 - duplicate
16745  336A CF 36               DEFW    L36A0           ; $32 Address: $36A0 - n-mod-m
16746  336C B5 36               DEFW    L3686           ; $33 Address: $3686 - jump
16747  336E F5 33               DEFW    L33C6           ; $34 Address: $33C6 - stk-data
16748  3370 A9 36               DEFW    L367A           ; $35 Address: $367A - dec-jr-nz
16749  3372 35 35               DEFW    L3506           ; $36 Address: $3506 - less-0
16750  3374 28 35               DEFW    L34F9           ; $37 Address: $34F9 - greater-0
16751  3376 CA 36               DEFW    L369B           ; $38 Address: $369B - end-calc
16752  3378 B2 37               DEFW    L3783           ; $39 Address: $3783 - get-argt
16753  337A 43 32               DEFW    L3214           ; $3A Address: $3214 - truncate
16754  337C D1 33               DEFW    L33A2           ; $3B Address: $33A2 - fp-calc-2
16755  337E 7E 2D               DEFW    L2D4F           ; $3C Address: $2D4F - e-to-fp
16756  3380 C6 32               DEFW    L3297           ; $3D Address: $3297 - re-stack
16757  3382             
16758  3382             ;   The following are just the next available slots for the 128 compound 
16759  3382             ;   literals which are in range $80 - $FF.
16760  3382             
16761  3382 78 34               DEFW    L3449           ;     Address: $3449 - series-xx    $80 - $9F.
16762  3384 4A 34               DEFW    L341B           ;     Address: $341B - stk-const-xx $A0 - $BF.
16763  3386 5C 34               DEFW    L342D           ;     Address: $342D - st-mem-xx    $C0 - $DF.
16764  3388 3E 34               DEFW    L340F           ;     Address: $340F - get-mem-xx   $E0 - $FF.
16765  338A             
16766  338A             ;   Aside: 3E - 3F are therefore unused calculator literals.
16767  338A             ;   If the literal has to be also usable as a function then bits 6 and 7 are 
16768  338A             ;   used to show type of arguments and result.
16769  338A             
16770  338A             ; --------------
16771  338A             ; The Calculator
16772  338A             ; --------------
16773  338A             ;  "A good calculator does not need artificial aids"
16774  338A             ;  Lao Tze 604 - 531 B.C.
16775  338A             
16776  338A             ;; CALCULATE
16777  338A CD EE 35    L335B:  CALL    L35BF           ; routine STK-PNTRS is called to set up the
16778  338D                                             ; calculator stack pointers for a default
16779  338D                                             ; unary operation. HL = last value on stack.
16780  338D                                             ; DE = STKEND first location after stack.
16781  338D             
16782  338D             ; the calculate routine is called at this point by the series generator...
16783  338D             
16784  338D             ;; GEN-ENT-1
16785  338D 78          L335E:  LD      A,B             ; fetch the Z80 B register to A
16786  338E 32 67 5C            LD      ($5C67),A       ; and store value in system variable BREG.
16787  3391                                             ; this will be the counter for dec-jr-nz
16788  3391                                             ; or if used from fp-calc2 the calculator
16789  3391                                             ; instruction.
16790  3391             
16791  3391             ; ... and again later at this point
16792  3391             
16793  3391             ;; GEN-ENT-2
16794  3391 D9          L3362:  EXX                     ; switch sets
16795  3392 E3                  EX      (SP),HL         ; and store the address of next instruction,
16796  3393                                             ; the return address, in H'L'.
16797  3393                                             ; If this is a recursive call the H'L'
16798  3393                                             ; of the previous invocation goes on stack.
16799  3393                                             ; c.f. end-calc.
16800  3393 D9                  EXX                     ; switch back to main set
16801  3394             
16802  3394             ; this is the re-entry looping point when handling a string of literals.
16803  3394             
16804  3394             ;; RE-ENTRY
16805  3394 ED 53 65 5C L3365:  LD      ($5C65),DE      ; save end of stack in system variable STKEND
16806  3398 D9                  EXX                     ; switch to alt
16807  3399 7E                  LD      A,(HL)          ; get next literal
16808  339A 23                  INC     HL              ; increase pointer'
16809  339B             
16810  339B             ; single operation jumps back to here
16811  339B             
16812  339B             ;; SCAN-ENT
16813  339B E5          L336C:  PUSH    HL              ; save pointer on stack
16814  339C A7                  AND     A               ; now test the literal
16815  339D F2 AF 33            JP      P,L3380         ; forward to FIRST-3D if in range $00 - $3D
16816  33A0                                             ; anything with bit 7 set will be one of
16817  33A0                                             ; 128 compound literals.
16818  33A0             
16819  33A0             ; compound literals have the following format.
16820  33A0             ; bit 7 set indicates compound.
16821  33A0             ; bits 6-5 the subgroup 0-3.
16822  33A0             ; bits 4-0 the embedded parameter $00 - $1F.
16823  33A0             ; The subgroup 0-3 needs to be manipulated to form the next available four
16824  33A0             ; address places after the simple literals in the address table.
16825  33A0             
16826  33A0 57                  LD      D,A             ; save literal in D
16827  33A1 E6 60               AND     $60             ; and with 01100000 to isolate subgroup
16828  33A3 0F                  RRCA                    ; rotate bits
16829  33A4 0F                  RRCA                    ; 4 places to right
16830  33A5 0F                  RRCA                    ; not five as we need offset * 2
16831  33A6 0F                  RRCA                    ; 00000xx0
16832  33A7 C6 7C               ADD     A,$7C           ; add ($3E * 2) to give correct offset.
16833  33A9                                             ; alter above if you add more literals.
16834  33A9 6F                  LD      L,A             ; store in L for later indexing.
16835  33AA 7A                  LD      A,D             ; bring back compound literal
16836  33AB E6 1F               AND     $1F             ; use mask to isolate parameter bits
16837  33AD 18 0E               JR      L338E           ; forward to ENT-TABLE
16838  33AF             
16839  33AF             ; ---
16840  33AF             
16841  33AF             ; the branch was here with simple literals.
16842  33AF             
16843  33AF             ;; FIRST-3D
16844  33AF FE 18       L3380:  CP      $18             ; compare with first unary operations.
16845  33B1 30 08               JR      NC,L338C        ; to DOUBLE-A with unary operations
16846  33B3             
16847  33B3             ; it is binary so adjust pointers.
16848  33B3             
16849  33B3 D9                  EXX                     ;
16850  33B4 01 FB FF            LD      BC,$FFFB        ; the value -5
16851  33B7 54                  LD      D,H             ; transfer HL, the last value, to DE.
16852  33B8 5D                  LD      E,L             ;
16853  33B9 09                  ADD     HL,BC           ; subtract 5 making HL point to second
16854  33BA                                             ; value.
16855  33BA D9                  EXX                     ;
16856  33BB             
16857  33BB             ;; DOUBLE-A
16858  33BB 07          L338C:  RLCA                    ; double the literal
16859  33BC 6F                  LD      L,A             ; and store in L for indexing
16860  33BD             
16861  33BD             ;; ENT-TABLE
16862  33BD 11 06 33    L338E:  LD      DE,L32D7        ; Address: tbl-addrs
16863  33C0 26 00               LD      H,$00           ; prepare to index
16864  33C2 19                  ADD     HL,DE           ; add to get address of routine
16865  33C3 5E                  LD      E,(HL)          ; low byte to E
16866  33C4 23                  INC     HL              ;
16867  33C5 56                  LD      D,(HL)          ; high byte to D
16868  33C6 21 94 33            LD      HL,L3365        ; Address: RE-ENTRY
16869  33C9 E3                  EX      (SP),HL         ; goes to stack
16870  33CA D5                  PUSH    DE              ; now address of routine
16871  33CB D9                  EXX                     ; main set
16872  33CC                                             ; avoid using IY register.
16873  33CC ED 4B 66 5C         LD      BC,($5C66)      ; STKEND_hi
16874  33D0                                             ; nothing much goes to C but BREG to B
16875  33D0                                             ; and continue into next ret instruction
16876  33D0                                             ; which has a dual identity
16877  33D0             
16878  33D0             
16879  33D0             ; ------------------
16880  33D0             ; Handle delete (02)
16881  33D0             ; ------------------
16882  33D0             ; A simple return but when used as a calculator literal this
16883  33D0             ; deletes the last value from the calculator stack.
16884  33D0             ; On entry, as always with binary operations,
16885  33D0             ; HL=first number, DE=second number
16886  33D0             ; On exit, HL=result, DE=stkend.
16887  33D0             ; So nothing to do
16888  33D0             
16889  33D0             ;; delete
16890  33D0 C9          L33A1:  RET                     ; return - indirect jump if from above.
16891  33D1             
16892  33D1             ; ---------------------
16893  33D1             ; Single operation (3B)
16894  33D1             ; ---------------------
16895  33D1             ;   This single operation is used, in the first instance, to evaluate most
16896  33D1             ;   of the mathematical and string functions found in BASIC expressions.
16897  33D1             
16898  33D1             ;; fp-calc-2
16899  33D1 F1          L33A2:  POP     AF              ; drop return address.
16900  33D2 3A 67 5C            LD      A,($5C67)       ; load accumulator from system variable BREG
16901  33D5                                             ; value will be literal e.g. 'tan'
16902  33D5 D9                  EXX                     ; switch to alt
16903  33D6 18 C3               JR      L336C           ; back to SCAN-ENT
16904  33D8                                             ; next literal will be end-calc at L2758
16905  33D8             
16906  33D8             ; ---------------------------------
16907  33D8             ; THE 'TEST FIVE SPACES' SUBROUTINE
16908  33D8             ; ---------------------------------
16909  33D8             ;   This routine is called from MOVE-FP, STK-CONST and STK-STORE to test that 
16910  33D8             ;   there is enough space between the calculator stack and the machine stack 
16911  33D8             ;   for another five-byte value.  It returns with BC holding the value 5 ready 
16912  33D8             ;   for any subsequent LDIR.
16913  33D8             
16914  33D8             ;; TEST-5-SP
16915  33D8 D5          L33A9:  PUSH    DE              ; save
16916  33D9 E5                  PUSH    HL              ; registers
16917  33DA 01 05 00            LD      BC,$0005        ; an overhead of five bytes
16918  33DD CD 34 1F            CALL    L1F05           ; routine TEST-ROOM tests free RAM raising
16919  33E0                                             ; an error if not.
16920  33E0 E1                  POP     HL              ; else restore
16921  33E1 D1                  POP     DE              ; registers.
16922  33E2 C9                  RET                     ; return with BC set at 5.
16923  33E3             
16924  33E3             ; -----------------------------
16925  33E3             ; THE 'STACK NUMBER' SUBROUTINE
16926  33E3             ; -----------------------------
16927  33E3             ;   This routine is called to stack a hidden floating point number found in
16928  33E3             ;   a BASIC line.  It is also called to stack a numeric variable value, and
16929  33E3             ;   from BEEP, to stack an entry in the semi-tone table.  It is not part of the
16930  33E3             ;   calculator suite of routines.  On entry, HL points to the number to be 
16931  33E3             ;   stacked.
16932  33E3             
16933  33E3             ;; STACK-NUM
16934  33E3 ED 5B 65 5C L33B4:  LD      DE,($5C65)      ; Load destination from STKEND system variable.
16935  33E7             
16936  33E7 CD EF 33            CALL    L33C0           ; Routine MOVE-FP puts on calculator stack 
16937  33EA                                             ; with a memory check.
16938  33EA ED 53 65 5C         LD      ($5C65),DE      ; Set STKEND to next free location.
16939  33EE             
16940  33EE C9                  RET                     ; Return.
16941  33EF             
16942  33EF             ; ---------------------------------
16943  33EF             ; Move a floating point number (31)
16944  33EF             ; ---------------------------------
16945  33EF             
16946  33EF             ; This simple routine is a 5-byte LDIR instruction
16947  33EF             ; that incorporates a memory check.
16948  33EF             ; When used as a calculator literal it duplicates the last value on the
16949  33EF             ; calculator stack.
16950  33EF             ; Unary so on entry HL points to last value, DE to stkend
16951  33EF             
16952  33EF             ;; duplicate
16953  33EF             ;; MOVE-FP
16954  33EF CD D8 33    L33C0:  CALL    L33A9           ; routine TEST-5-SP test free memory
16955  33F2                                             ; and sets BC to 5.
16956  33F2 ED B0               LDIR                    ; copy the five bytes.
16957  33F4 C9                  RET                     ; return with DE addressing new STKEND
16958  33F5                                             ; and HL addressing new last value.
16959  33F5             
16960  33F5             ; -------------------
16961  33F5             ; Stack literals ($34)
16962  33F5             ; -------------------
16963  33F5             ; When a calculator subroutine needs to put a value on the calculator
16964  33F5             ; stack that is not a regular constant this routine is called with a
16965  33F5             ; variable number of following data bytes that convey to the routine
16966  33F5             ; the integer or floating point form as succinctly as is possible.
16967  33F5             
16968  33F5             ;; stk-data
16969  33F5 62          L33C6:  LD      H,D             ; transfer STKEND
16970  33F6 6B                  LD      L,E             ; to HL for result.
16971  33F7             
16972  33F7             ;; STK-CONST
16973  33F7 CD D8 33    L33C8:  CALL    L33A9           ; routine TEST-5-SP tests that room exists
16974  33FA                                             ; and sets BC to $05.
16975  33FA             
16976  33FA D9                  EXX                     ; switch to alternate set
16977  33FB E5                  PUSH    HL              ; save the pointer to next literal on stack
16978  33FC D9                  EXX                     ; switch back to main set
16979  33FD             
16980  33FD E3                  EX      (SP),HL         ; pointer to HL, destination to stack.
16981  33FE             
16982  33FE C5                  PUSH    BC              ; save BC - value 5 from test room ??.
16983  33FF             
16984  33FF 7E                  LD      A,(HL)          ; fetch the byte following 'stk-data'
16985  3400 E6 C0               AND     $C0             ; isolate bits 7 and 6
16986  3402 07                  RLCA                    ; rotate
16987  3403 07                  RLCA                    ; to bits 1 and 0  range $00 - $03.
16988  3404 4F                  LD      C,A             ; transfer to C
16989  3405 0C                  INC     C               ; and increment to give number of bytes
16990  3406                                             ; to read. $01 - $04
16991  3406 7E                  LD      A,(HL)          ; reload the first byte
16992  3407 E6 3F               AND     $3F             ; mask off to give possible exponent.
16993  3409 20 02               JR      NZ,L33DE        ; forward to FORM-EXP if it was possible to
16994  340B                                             ; include the exponent.
16995  340B             
16996  340B             ; else byte is just a byte count and exponent comes next.
16997  340B             
16998  340B 23                  INC     HL              ; address next byte and
16999  340C 7E                  LD      A,(HL)          ; pick up the exponent ( - $50).
17000  340D             
17001  340D             ;; FORM-EXP
17002  340D C6 50       L33DE:  ADD     A,$50           ; now add $50 to form actual exponent
17003  340F 12                  LD      (DE),A          ; and load into first destination byte.
17004  3410 3E 05               LD      A,$05           ; load accumulator with $05 and
17005  3412 91                  SUB     C               ; subtract C to give count of trailing
17006  3413                                             ; zeros plus one.
17007  3413 23                  INC     HL              ; increment source
17008  3414 13                  INC     DE              ; increment destination
17009  3415 06 00               LD      B,$00           ; prepare to copy
17010  3417 ED B0               LDIR                    ; copy C bytes
17011  3419             
17012  3419 C1                  POP     BC              ; restore 5 counter to BC ??.
17013  341A             
17014  341A E3                  EX      (SP),HL         ; put HL on stack as next literal pointer
17015  341B                                             ; and the stack value - result pointer -
17016  341B                                             ; to HL.
17017  341B             
17018  341B D9                  EXX                     ; switch to alternate set.
17019  341C E1                  POP     HL              ; restore next literal pointer from stack
17020  341D                                             ; to H'L'.
17021  341D D9                  EXX                     ; switch back to main set.
17022  341E             
17023  341E 47                  LD      B,A             ; zero count to B
17024  341F AF                  XOR     A               ; clear accumulator
17025  3420             
17026  3420             ;; STK-ZEROS
17027  3420 05          L33F1:  DEC     B               ; decrement B counter
17028  3421 C8                  RET     Z               ; return if zero.          >>
17029  3422                                             ; DE points to new STKEND
17030  3422                                             ; HL to new number.
17031  3422             
17032  3422 12                  LD      (DE),A          ; else load zero to destination
17033  3423 13                  INC     DE              ; increase destination
17034  3424 18 FA               JR      L33F1           ; loop back to STK-ZEROS until done.
17035  3426             
17036  3426             ; -------------------------------
17037  3426             ; THE 'SKIP CONSTANTS' SUBROUTINE
17038  3426             ; -------------------------------
17039  3426             ;   This routine traverses variable-length entries in the table of constants,
17040  3426             ;   stacking intermediate, unwanted constants onto a dummy calculator stack,
17041  3426             ;   in the first five bytes of ROM.  The destination DE normally points to the
17042  3426             ;   end of the calculator stack which might be in the normal place or in the
17043  3426             ;   system variables area during E-LINE-NO; INT-TO-FP; stk-ten.  In any case,
17044  3426             ;   it would be simpler all round if the routine just shoved unwanted values 
17045  3426             ;   where it is going to stick the wanted value.  The instruction LD DE, $0000 
17046  3426             ;   can be removed.
17047  3426             
17048  3426             ;; SKIP-CONS
17049  3426 A7          L33F7:  AND     A               ; test if initially zero.
17050  3427             
17051  3427             ;; SKIP-NEXT
17052  3427 C8          L33F8:  RET     Z               ; return if zero.          >>
17053  3428             
17054  3428 F5                  PUSH    AF              ; save count.
17055  3429 D5                  PUSH    DE              ; and normal STKEND
17056  342A             
17057  342A 11 00 00            LD      DE,$0000        ; dummy value for STKEND at start of ROM
17058  342D                                             ; Note. not a fault but this has to be
17059  342D                                             ; moved elsewhere when running in RAM.
17060  342D                                             ; e.g. with Expandor Systems 'Soft ROM'.
17061  342D                                             ; Better still, write to the normal place.
17062  342D CD F7 33            CALL    L33C8           ; routine STK-CONST works through variable
17063  3430                                             ; length records.
17064  3430             
17065  3430 D1                  POP     DE              ; restore real STKEND
17066  3431 F1                  POP     AF              ; restore count
17067  3432 3D                  DEC     A               ; decrease
17068  3433 18 F2               JR      L33F8           ; loop back to SKIP-NEXT
17069  3435             
17070  3435             ; ------------------------------
17071  3435             ; THE 'LOCATE MEMORY' SUBROUTINE
17072  3435             ; ------------------------------
17073  3435             ;   This routine, when supplied with a base address in HL and an index in A,
17074  3435             ;   will calculate the address of the A'th entry, where each entry occupies
17075  3435             ;   five bytes.  It is used for reading the semi-tone table and addressing
17076  3435             ;   floating-point numbers in the calculator's memory area.
17077  3435             ;   It is not possible to use this routine for the table of constants as these
17078  3435             ;   six values are held in compressed format.
17079  3435             
17080  3435             ;; LOC-MEM
17081  3435 4F          L3406:  LD      C,A             ; store the original number $00-$1F.
17082  3436 07                  RLCA                    ; X2 - double.
17083  3437 07                  RLCA                    ; X4 - quadruple.
17084  3438 81                  ADD     A,C             ; X5 - now add original to multiply by five.
17085  3439             
17086  3439 4F                  LD      C,A             ; place the result in the low byte.
17087  343A 06 00               LD      B,$00           ; set high byte to zero.
17088  343C 09                  ADD     HL,BC           ; add to form address of start of number in HL.
17089  343D             
17090  343D C9                  RET                     ; return.
17091  343E             
17092  343E             ; ------------------------------
17093  343E             ; Get from memory area ($E0 etc.)
17094  343E             ; ------------------------------
17095  343E             ; Literals $E0 to $FF
17096  343E             ; A holds $00-$1F offset.
17097  343E             ; The calculator stack increases by 5 bytes.
17098  343E             
17099  343E             ;; get-mem-xx
17100  343E D5          L340F:  PUSH    DE              ; save STKEND
17101  343F 2A 68 5C            LD      HL,($5C68)      ; MEM is base address of the memory cells.
17102  3442 CD 35 34            CALL    L3406           ; routine LOC-MEM so that HL = first byte
17103  3445 CD EF 33            CALL    L33C0           ; routine MOVE-FP moves 5 bytes with memory
17104  3448                                             ; check.
17105  3448                                             ; DE now points to new STKEND.
17106  3448 E1                  POP     HL              ; original STKEND is now RESULT pointer.
17107  3449 C9                  RET                     ; return.
17108  344A             
17109  344A             ; --------------------------
17110  344A             ; Stack a constant (A0 etc.)
17111  344A             ; --------------------------
17112  344A             ; This routine allows a one-byte instruction to stack up to 32 constants
17113  344A             ; held in short form in a table of constants. In fact only 5 constants are
17114  344A             ; required. On entry the A register holds the literal ANDed with 1F.
17115  344A             ; It isn't very efficient and it would have been better to hold the
17116  344A             ; numbers in full, five byte form and stack them in a similar manner
17117  344A             ; to that used for semi-tone table values.
17118  344A             
17119  344A             ;; stk-const-xx
17120  344A 62          L341B:  LD      H,D             ; save STKEND - required for result
17121  344B 6B                  LD      L,E             ;
17122  344C D9                  EXX                     ; swap
17123  344D E5                  PUSH    HL              ; save pointer to next literal
17124  344E 21 F4 32            LD      HL,L32C5        ; Address: stk-zero - start of table of
17125  3451                                             ; constants
17126  3451 D9                  EXX                     ;
17127  3452 CD 26 34            CALL    L33F7           ; routine SKIP-CONS
17128  3455 CD F7 33            CALL    L33C8           ; routine STK-CONST
17129  3458 D9                  EXX                     ;
17130  3459 E1                  POP     HL              ; restore pointer to next literal.
17131  345A D9                  EXX                     ;
17132  345B C9                  RET                     ; return.
17133  345C             
17134  345C             ; --------------------------------
17135  345C             ; Store in a memory area ($C0 etc.)
17136  345C             ; --------------------------------
17137  345C             ; Offsets $C0 to $DF
17138  345C             ; Although 32 memory storage locations can be addressed, only six
17139  345C             ; $C0 to $C5 are required by the ROM and only the thirty bytes (6*5)
17140  345C             ; required for these are allocated. Spectrum programmers who wish to
17141  345C             ; use the floating point routines from assembly language may wish to
17142  345C             ; alter the system variable MEM to point to 160 bytes of RAM to have 
17143  345C             ; use the full range available.
17144  345C             ; A holds the derived offset $00-$1F.
17145  345C             ; This is a unary operation, so on entry HL points to the last value and DE 
17146  345C             ; points to STKEND.
17147  345C             
17148  345C             ;; st-mem-xx
17149  345C E5          L342D:  PUSH    HL              ; save the result pointer.
17150  345D EB                  EX      DE,HL           ; transfer to DE.
17151  345E 2A 68 5C            LD      HL,($5C68)      ; fetch MEM the base of memory area.
17152  3461 CD 35 34            CALL    L3406           ; routine LOC-MEM sets HL to the destination.
17153  3464 EB                  EX      DE,HL           ; swap - HL is start, DE is destination.
17154  3465 CD EF 33            CALL    L33C0           ; routine MOVE-FP.
17155  3468                                             ; note. a short ld bc,5; ldir
17156  3468                                             ; the embedded memory check is not required
17157  3468                                             ; so these instructions would be faster.
17158  3468 EB                  EX      DE,HL           ; DE = STKEND
17159  3469 E1                  POP     HL              ; restore original result pointer
17160  346A C9                  RET                     ; return.
17161  346B             
17162  346B             ; -------------------------
17163  346B             ; THE 'EXCHANGE' SUBROUTINE
17164  346B             ; -------------------------
17165  346B             ; (offset: $01 'exchange')
17166  346B             ;   This routine swaps the last two values on the calculator stack.
17167  346B             ;   On entry, as always with binary operations,
17168  346B             ;   HL=first number, DE=second number
17169  346B             ;   On exit, HL=result, DE=stkend.
17170  346B             
17171  346B             ;; exchange
17172  346B 06 05       L343C:  LD      B,$05           ; there are five bytes to be swapped
17173  346D             
17174  346D             ; start of loop.
17175  346D             
17176  346D             ;; SWAP-BYTE
17177  346D 1A          L343E:  LD      A,(DE)          ; each byte of second
17178  346E 4E                  LD      C,(HL)          ; each byte of first
17179  346F EB                  EX      DE,HL           ; swap pointers
17180  3470 12                  LD      (DE),A          ; store each byte of first
17181  3471 71                  LD      (HL),C          ; store each byte of second
17182  3472 23                  INC     HL              ; advance both
17183  3473 13                  INC     DE              ; pointers.
17184  3474 10 F7               DJNZ    L343E           ; loop back to SWAP-BYTE until all 5 done.
17185  3476             
17186  3476 EB                  EX      DE,HL           ; even up the exchanges so that DE addresses 
17187  3477                                             ; STKEND.
17188  3477             
17189  3477 C9                  RET                     ; return.
17190  3478             
17191  3478             ; ------------------------------
17192  3478             ; THE 'SERIES GENERATOR' ROUTINE
17193  3478             ; ------------------------------
17194  3478             ; (offset: $86 'series-06')
17195  3478             ; (offset: $88 'series-08')
17196  3478             ; (offset: $8C 'series-0C')
17197  3478             ;   The Spectrum uses Chebyshev polynomials to generate approximations for
17198  3478             ;   SIN, ATN, LN and EXP.  These are named after the Russian mathematician
17199  3478             ;   Pafnuty Chebyshev, born in 1821, who did much pioneering work on numerical
17200  3478             ;   series.  As far as calculators are concerned, Chebyshev polynomials have an
17201  3478             ;   advantage over other series, for example the Taylor series, as they can
17202  3478             ;   reach an approximation in just six iterations for SIN, eight for EXP and
17203  3478             ;   twelve for LN and ATN.  The mechanics of the routine are interesting but
17204  3478             ;   for full treatment of how these are generated with demonstrations in
17205  3478             ;   Sinclair BASIC see "The Complete Spectrum ROM Disassembly" by Dr Ian Logan
17206  3478             ;   and Dr Frank O'Hara, published 1983 by Melbourne House.
17207  3478             
17208  3478             ;; series-xx
17209  3478 47          L3449:  LD      B,A             ; parameter $00 - $1F to B counter
17210  3479 CD 8D 33            CALL    L335E           ; routine GEN-ENT-1 is called.
17211  347C                                             ; A recursive call to a special entry point
17212  347C                                             ; in the calculator that puts the B register
17213  347C                                             ; in the system variable BREG. The return
17214  347C                                             ; address is the next location and where
17215  347C                                             ; the calculator will expect its first
17216  347C                                             ; instruction - now pointed to by HL'.
17217  347C                                             ; The previous pointer to the series of
17218  347C                                             ; five-byte numbers goes on the machine stack.
17219  347C             
17220  347C             ; The initialization phase.
17221  347C             
17222  347C 31                  DEFB    $31             ;;duplicate       x,x
17223  347D 0F                  DEFB    $0F             ;;addition        x+x
17224  347E C0                  DEFB    $C0             ;;st-mem-0        x+x
17225  347F 02                  DEFB    $02             ;;delete          .
17226  3480 A0                  DEFB    $A0             ;;stk-zero        0
17227  3481 C2                  DEFB    $C2             ;;st-mem-2        0
17228  3482             
17229  3482             ; a loop is now entered to perform the algebraic calculation for each of
17230  3482             ; the numbers in the series
17231  3482             
17232  3482             ;; G-LOOP
17233  3482 31          L3453:  DEFB    $31             ;;duplicate       v,v.
17234  3483 E0                  DEFB    $E0             ;;get-mem-0       v,v,x+2
17235  3484 04                  DEFB    $04             ;;multiply        v,v*x+2
17236  3485 E2                  DEFB    $E2             ;;get-mem-2       v,v*x+2,v
17237  3486 C1                  DEFB    $C1             ;;st-mem-1
17238  3487 03                  DEFB    $03             ;;subtract
17239  3488 38                  DEFB    $38             ;;end-calc
17240  3489             
17241  3489             ; the previous pointer is fetched from the machine stack to H'L' where it
17242  3489             ; addresses one of the numbers of the series following the series literal.
17243  3489             
17244  3489 CD F5 33            CALL    L33C6           ; routine STK-DATA is called directly to
17245  348C                                             ; push a value and advance H'L'.
17246  348C CD 91 33            CALL    L3362           ; routine GEN-ENT-2 recursively re-enters
17247  348F                                             ; the calculator without disturbing
17248  348F                                             ; system variable BREG
17249  348F                                             ; H'L' value goes on the machine stack and is
17250  348F                                             ; then loaded as usual with the next address.
17251  348F             
17252  348F 0F                  DEFB    $0F             ;;addition
17253  3490 01                  DEFB    $01             ;;exchange
17254  3491 C2                  DEFB    $C2             ;;st-mem-2
17255  3492 02                  DEFB    $02             ;;delete
17256  3493             
17257  3493 35                  DEFB    $35             ;;dec-jr-nz
17258  3494 EE                  DEFB    $EE             ;;back to L3453, G-LOOP
17259  3495             
17260  3495             ; when the counted loop is complete the final subtraction yields the result
17261  3495             ; for example SIN X.
17262  3495             
17263  3495 E1                  DEFB    $E1             ;;get-mem-1
17264  3496 03                  DEFB    $03             ;;subtract
17265  3497 38                  DEFB    $38             ;;end-calc
17266  3498             
17267  3498 C9                  RET                     ; return with H'L' pointing to location
17268  3499                                             ; after last number in series.
17269  3499             
17270  3499             ; ---------------------------------
17271  3499             ; THE 'ABSOLUTE MAGNITUDE' FUNCTION
17272  3499             ; ---------------------------------
17273  3499             ; (offset: $2A 'abs')
17274  3499             ;   This calculator literal finds the absolute value of the last value,
17275  3499             ;   integer or floating point, on calculator stack.
17276  3499             
17277  3499             ;; abs
17278  3499 06 FF       L346A:  LD      B,$FF           ; signal abs
17279  349B 18 06               JR      L3474           ; forward to NEG-TEST
17280  349D             
17281  349D             ; ---------------------------
17282  349D             ; THE 'UNARY MINUS' OPERATION
17283  349D             ; ---------------------------
17284  349D             ; (offset: $1B 'negate')
17285  349D             ;   Unary so on entry HL points to last value, DE to STKEND.
17286  349D             
17287  349D             ;; NEGATE
17288  349D             ;; negate
17289  349D CD 18 35    L346E:  CALL    L34E9           ; call routine TEST-ZERO and
17290  34A0 D8                  RET     C               ; return if so leaving zero unchanged.
17291  34A1             
17292  34A1 06 00               LD      B,$00           ; signal negate required before joining
17293  34A3                                             ; common code.
17294  34A3             
17295  34A3             ;; NEG-TEST
17296  34A3 7E          L3474:  LD      A,(HL)          ; load first byte and 
17297  34A4 A7                  AND     A               ; test for zero
17298  34A5 28 0B               JR      Z,L3483         ; forward to INT-CASE if a small integer
17299  34A7             
17300  34A7             ; for floating point numbers a single bit denotes the sign.
17301  34A7             
17302  34A7 23                  INC     HL              ; address the first byte of mantissa.
17303  34A8 78                  LD      A,B             ; action flag $FF=abs, $00=neg.
17304  34A9 E6 80               AND     $80             ; now         $80      $00
17305  34AB B6                  OR      (HL)            ; sets bit 7 for abs
17306  34AC 17                  RLA                     ; sets carry for abs and if number negative
17307  34AD 3F                  CCF                     ; complement carry flag
17308  34AE 1F                  RRA                     ; and rotate back in altering sign
17309  34AF 77                  LD      (HL),A          ; put the altered adjusted number back
17310  34B0 2B                  DEC     HL              ; HL points to result
17311  34B1 C9                  RET                     ; return with DE unchanged
17312  34B2             
17313  34B2             ; ---
17314  34B2             
17315  34B2             ; for integer numbers an entire byte denotes the sign.
17316  34B2             
17317  34B2             ;; INT-CASE
17318  34B2 D5          L3483:  PUSH    DE              ; save STKEND.
17319  34B3             
17320  34B3 E5                  PUSH    HL              ; save pointer to the last value/result.
17321  34B4             
17322  34B4 CD AE 2D            CALL    L2D7F           ; routine INT-FETCH puts integer in DE
17323  34B7                                             ; and the sign in C.
17324  34B7             
17325  34B7 E1                  POP     HL              ; restore the result pointer.
17326  34B8             
17327  34B8 78                  LD      A,B             ; $FF=abs, $00=neg
17328  34B9 B1                  OR      C               ; $FF for abs, no change neg
17329  34BA 2F                  CPL                     ; $00 for abs, switched for neg
17330  34BB 4F                  LD      C,A             ; transfer result to sign byte.
17331  34BC             
17332  34BC CD BD 2D            CALL    L2D8E           ; routine INT-STORE to re-write the integer.
17333  34BF             
17334  34BF D1                  POP     DE              ; restore STKEND.
17335  34C0 C9                  RET                     ; return.
17336  34C1             
17337  34C1             ; ---------------------
17338  34C1             ; THE 'SIGNUM' FUNCTION
17339  34C1             ; ---------------------
17340  34C1             ; (offset: $29 'sgn')
17341  34C1             ;   This routine replaces the last value on the calculator stack,
17342  34C1             ;   which may be in floating point or integer form, with the integer values
17343  34C1             ;   zero if zero, with one if positive and  with -minus one if negative.
17344  34C1             
17345  34C1             ;; sgn
17346  34C1 CD 18 35    L3492:  CALL    L34E9           ; call routine TEST-ZERO and
17347  34C4 D8                  RET     C               ; exit if so as no change is required.
17348  34C5             
17349  34C5 D5                  PUSH    DE              ; save pointer to STKEND.
17350  34C6             
17351  34C6 11 01 00            LD      DE,$0001        ; the result will be 1.
17352  34C9 23                  INC     HL              ; skip over the exponent.
17353  34CA CB 16               RL      (HL)            ; rotate the sign bit into the carry flag.
17354  34CC 2B                  DEC     HL              ; step back to point to the result.
17355  34CD 9F                  SBC     A,A             ; byte will be $FF if negative, $00 if positive.
17356  34CE 4F                  LD      C,A             ; store the sign byte in the C register.
17357  34CF CD BD 2D            CALL    L2D8E           ; routine INT-STORE to overwrite the last
17358  34D2                                             ; value with 0001 and sign.
17359  34D2             
17360  34D2 D1                  POP     DE              ; restore STKEND.
17361  34D3 C9                  RET                     ; return.
17362  34D4             
17363  34D4             ; -----------------
17364  34D4             ; THE 'IN' FUNCTION
17365  34D4             ; -----------------
17366  34D4             ; (offset: $2C 'in')
17367  34D4             ;   This function reads a byte from an input port.
17368  34D4             
17369  34D4             ;; in
17370  34D4 CD C8 1E    L34A5:  CALL    L1E99           ; Routine FIND-INT2 puts port address in BC.
17371  34D7                                             ; All 16 bits are put on the address line.
17372  34D7             
17373  34D7 ED 78               IN      A,(C)           ; Read the port.
17374  34D9             
17375  34D9 18 04               JR      L34B0           ; exit to STACK-A (via IN-PK-STK to save a byte 
17376  34DB                                             ; of instruction code).
17377  34DB             
17378  34DB             ; -------------------
17379  34DB             ; THE 'PEEK' FUNCTION
17380  34DB             ; -------------------
17381  34DB             ; (offset: $2B 'peek')
17382  34DB             ;   This function returns the contents of a memory address.
17383  34DB             ;   The entire address space can be peeked including the ROM.
17384  34DB             
17385  34DB             ;; peek
17386  34DB CD C8 1E    L34AC:  CALL    L1E99           ; routine FIND-INT2 puts address in BC.
17387  34DE 0A                  LD      A,(BC)          ; load contents into A register.
17388  34DF             
17389  34DF             ;; IN-PK-STK
17390  34DF C3 57 2D    L34B0:  JP      L2D28           ; exit via STACK-A to put the value on the 
17391  34E2                                             ; calculator stack.
17392  34E2             
17393  34E2             ; ------------------
17394  34E2             ; THE 'USR' FUNCTION
17395  34E2             ; ------------------
17396  34E2             ; (offset: $2d 'usr-no')
17397  34E2             ;   The USR function followed by a number 0-65535 is the method by which
17398  34E2             ;   the Spectrum invokes machine code programs. This function returns the
17399  34E2             ;   contents of the BC register pair.
17400  34E2             ;   Note. that STACK-BC re-initializes the IY register if a user-written
17401  34E2             ;   program has altered it.
17402  34E2             
17403  34E2             ;; usr-no
17404  34E2 CD C8 1E    L34B3:  CALL    L1E99           ; routine FIND-INT2 to fetch the
17405  34E5                                             ; supplied address into BC.
17406  34E5             
17407  34E5 21 5A 2D            LD      HL,L2D2B        ; address: STACK-BC is
17408  34E8 E5                  PUSH    HL              ; pushed onto the machine stack.
17409  34E9 C5                  PUSH    BC              ; then the address of the machine code
17410  34EA                                             ; routine.
17411  34EA             
17412  34EA C9                  RET                     ; make an indirect jump to the routine
17413  34EB                                             ; and, hopefully, to STACK-BC also.
17414  34EB             
17415  34EB             ; -------------------------
17416  34EB             ; THE 'USR STRING' FUNCTION
17417  34EB             ; -------------------------
17418  34EB             ; (offset: $19 'usr-$')
17419  34EB             ;   The user function with a one-character string argument, calculates the
17420  34EB             ;   address of the User Defined Graphic character that is in the string.
17421  34EB             ;   As an alternative, the ASCII equivalent, upper or lower case,
17422  34EB             ;   may be supplied. This provides a user-friendly method of redefining
17423  34EB             ;   the 21 User Definable Graphics e.g.
17424  34EB             ;   POKE USR "a", BIN 10000000 will put a dot in the top left corner of the
17425  34EB             ;   character 144.
17426  34EB             ;   Note. the curious double check on the range. With 26 UDGs the first check
17427  34EB             ;   only is necessary. With anything less the second check only is required.
17428  34EB             ;   It is highly likely that the first check was written by Steven Vickers.
17429  34EB             
17430  34EB             ;; usr-$
17431  34EB CD 20 2C    L34BC:  CALL    L2BF1           ; routine STK-FETCH fetches the string
17432  34EE                                             ; parameters.
17433  34EE 0B                  DEC     BC              ; decrease BC by
17434  34EF 78                  LD      A,B             ; one to test
17435  34F0 B1                  OR      C               ; the length.
17436  34F1 20 23               JR      NZ,L34E7        ; to REPORT-A if not a single character.
17437  34F3             
17438  34F3 1A                  LD      A,(DE)          ; fetch the character
17439  34F4 CD BC 2C            CALL    L2C8D           ; routine ALPHA sets carry if 'A-Z' or 'a-z'.
17440  34F7 38 09               JR      C,L34D3         ; forward to USR-RANGE if ASCII.
17441  34F9             
17442  34F9 D6 90               SUB     $90             ; make UDGs range 0-20d
17443  34FB 38 19               JR      C,L34E7         ; to REPORT-A if too low. e.g. usr " ".
17444  34FD             
17445  34FD FE 15               CP      $15             ; Note. this test is not necessary.
17446  34FF 30 15               JR      NC,L34E7        ; to REPORT-A if higher than 20.
17447  3501             
17448  3501 3C                  INC     A               ; make range 1-21d to match LSBs of ASCII
17449  3502             
17450  3502             ;; USR-RANGE
17451  3502 3D          L34D3:  DEC     A               ; make range of bits 0-4 start at zero
17452  3503 87                  ADD     A,A             ; multiply by eight
17453  3504 87                  ADD     A,A             ; and lose any set bits
17454  3505 87                  ADD     A,A             ; range now 0 - 25*8
17455  3506 FE A8               CP      $A8             ; compare to 21*8
17456  3508 30 0C               JR      NC,L34E7        ; to REPORT-A if originally higher 
17457  350A                                             ; than 'U','u' or graphics U.
17458  350A             
17459  350A ED 4B 7B 5C         LD      BC,($5C7B)      ; fetch the UDG system variable value.
17460  350E 81                  ADD     A,C             ; add the offset to character
17461  350F 4F                  LD      C,A             ; and store back in register C.
17462  3510 30 01               JR      NC,L34E4        ; forward to USR-STACK if no overflow.
17463  3512             
17464  3512 04                  INC     B               ; increment high byte.
17465  3513             
17466  3513             ;; USR-STACK
17467  3513 C3 5A 2D    L34E4:  JP      L2D2B           ; jump back and exit via STACK-BC to store
17468  3516             
17469  3516             ; ---
17470  3516             
17471  3516             ;; REPORT-A
17472  3516 CF          L34E7:  RST     08H             ; ERROR-1
17473  3517 09                  DEFB    $09             ; Error Report: Invalid argument
17474  3518             
17475  3518             ; ------------------------------
17476  3518             ; THE 'TEST FOR ZERO' SUBROUTINE
17477  3518             ; ------------------------------
17478  3518             ;   Test if top value on calculator stack is zero.  The carry flag is set if 
17479  3518             ;   the last value is zero but no registers are altered.
17480  3518             ;   All five bytes will be zero but first four only need be tested.
17481  3518             ;   On entry, HL points to the exponent the first byte of the value.
17482  3518             
17483  3518             ;; TEST-ZERO
17484  3518 E5          L34E9:  PUSH    HL              ; preserve HL which is used to address.
17485  3519 C5                  PUSH    BC              ; preserve BC which is used as a store.
17486  351A 47                  LD      B,A             ; preserve A in B.
17487  351B             
17488  351B 7E                  LD      A,(HL)          ; load first byte to accumulator
17489  351C 23                  INC     HL              ; advance.
17490  351D B6                  OR      (HL)            ; OR with second byte and clear carry.
17491  351E 23                  INC     HL              ; advance.
17492  351F B6                  OR      (HL)            ; OR with third byte.
17493  3520 23                  INC     HL              ; advance.
17494  3521 B6                  OR      (HL)            ; OR with fourth byte.
17495  3522             
17496  3522 78                  LD      A,B             ; restore A without affecting flags.
17497  3523 C1                  POP     BC              ; restore the saved
17498  3524 E1                  POP     HL              ; registers.
17499  3525             
17500  3525 C0                  RET     NZ              ; return if not zero and with carry reset.
17501  3526             
17502  3526 37                  SCF                     ; set the carry flag.
17503  3527 C9                  RET                     ; return with carry set if zero.
17504  3528             
17505  3528             ; --------------------------------
17506  3528             ; THE 'GREATER THAN ZERO' OPERATOR
17507  3528             ; --------------------------------
17508  3528             ; (offset: $37 'greater-0' )
17509  3528             ;   Test if the last value on the calculator stack is greater than zero.
17510  3528             ;   This routine is also called directly from the end-tests of the comparison 
17511  3528             ;   routine.
17512  3528             
17513  3528             ;; GREATER-0
17514  3528             ;; greater-0
17515  3528 CD 18 35    L34F9:  CALL    L34E9           ; routine TEST-ZERO
17516  352B D8                  RET     C               ; return if was zero as this
17517  352C                                             ; is also the Boolean 'false' value.
17518  352C             
17519  352C 3E FF               LD      A,$FF           ; prepare XOR mask for sign bit
17520  352E 18 06               JR      L3507           ; forward to SIGN-TO-C
17521  3530                                             ; to put sign in carry
17522  3530                                             ; (carry will become set if sign is positive)
17523  3530                                             ; and then overwrite location with 1 or 0 
17524  3530                                             ; as appropriate.
17525  3530             
17526  3530             ; ------------------
17527  3530             ; THE 'NOT' FUNCTION
17528  3530             ; ------------------
17529  3530             ; (offset: $30 'not')
17530  3530             ;   This overwrites the last value with 1 if it was zero else with zero
17531  3530             ;   if it was any other value.
17532  3530             ;
17533  3530             ;   e.g. NOT 0 returns 1, NOT 1 returns 0, NOT -3 returns 0.
17534  3530             ;
17535  3530             ;   The subroutine is also called directly from the end-tests of the comparison
17536  3530             ;   operator.
17537  3530             
17538  3530             ;; NOT
17539  3530             ;; not
17540  3530 CD 18 35    L3501:  CALL    L34E9           ; routine TEST-ZERO sets carry if zero
17541  3533             
17542  3533 18 05               JR      L350B           ; to FP-0/1 to overwrite operand with
17543  3535                                             ; 1 if carry is set else to overwrite with zero.
17544  3535             
17545  3535             ; ------------------------------
17546  3535             ; THE 'LESS THAN ZERO' OPERATION
17547  3535             ; ------------------------------
17548  3535             ; (offset: $36 'less-0' )
17549  3535             ;   Destructively test if last value on calculator stack is less than zero.
17550  3535             ;   Bit 7 of second byte will be set if so.
17551  3535             
17552  3535             ;; less-0
17553  3535 AF          L3506:  XOR     A               ; set XOR mask to zero
17554  3536                                             ; (carry will become set if sign is negative).
17555  3536             
17556  3536             ;   transfer sign of mantissa to Carry Flag.
17557  3536             
17558  3536             ;; SIGN-TO-C
17559  3536 23          L3507:  INC     HL              ; address 2nd byte.
17560  3537 AE                  XOR     (HL)            ; bit 7 of HL will be set if number is negative.
17561  3538 2B                  DEC     HL              ; address 1st byte again.
17562  3539 07                  RLCA                    ; rotate bit 7 of A to carry.
17563  353A             
17564  353A             ; ----------------------------
17565  353A             ; THE 'ZERO OR ONE' SUBROUTINE
17566  353A             ; ----------------------------
17567  353A             ;   This routine places an integer value of zero or one at the addressed 
17568  353A             ;   location of the calculator stack or MEM area.  The value one is written if 
17569  353A             ;   carry is set on entry else zero.
17570  353A             
17571  353A             ;; FP-0/1
17572  353A E5          L350B:  PUSH    HL              ; save pointer to the first byte
17573  353B 3E 00               LD      A,$00           ; load accumulator with zero - without
17574  353D                                             ; disturbing flags.
17575  353D 77                  LD      (HL),A          ; zero to first byte
17576  353E 23                  INC     HL              ; address next
17577  353F 77                  LD      (HL),A          ; zero to 2nd byte
17578  3540 23                  INC     HL              ; address low byte of integer
17579  3541 17                  RLA                     ; carry to bit 0 of A
17580  3542 77                  LD      (HL),A          ; load one or zero to low byte.
17581  3543 1F                  RRA                     ; restore zero to accumulator.
17582  3544 23                  INC     HL              ; address high byte of integer.
17583  3545 77                  LD      (HL),A          ; put a zero there.
17584  3546 23                  INC     HL              ; address fifth byte.
17585  3547 77                  LD      (HL),A          ; put a zero there.
17586  3548 E1                  POP     HL              ; restore pointer to the first byte.
17587  3549 C9                  RET                     ; return.
17588  354A             
17589  354A             ; -----------------
17590  354A             ; THE 'OR' OPERATOR
17591  354A             ; -----------------
17592  354A             ; (offset: $07 'or' )
17593  354A             ; The Boolean OR operator. e.g. X OR Y
17594  354A             ; The result is zero if both values are zero else a non-zero value.
17595  354A             ;
17596  354A             ; e.g.    0 OR 0  returns 0.
17597  354A             ;        -3 OR 0  returns -3.
17598  354A             ;         0 OR -3 returns 1.
17599  354A             ;        -3 OR 2  returns 1.
17600  354A             ;
17601  354A             ; A binary operation.
17602  354A             ; On entry HL points to first operand (X) and DE to second operand (Y).
17603  354A             
17604  354A             ;; or
17605  354A EB          L351B:  EX      DE,HL           ; make HL point to second number
17606  354B CD 18 35            CALL    L34E9           ; routine TEST-ZERO
17607  354E EB                  EX      DE,HL           ; restore pointers
17608  354F D8                  RET     C               ; return if result was zero - first operand, 
17609  3550                                             ; now the last value, is the result.
17610  3550             
17611  3550 37                  SCF                     ; set carry flag
17612  3551 18 E7               JR      L350B           ; back to FP-0/1 to overwrite the first operand
17613  3553                                             ; with the value 1.
17614  3553             
17615  3553             
17616  3553             ; ---------------------------------
17617  3553             ; THE 'NUMBER AND NUMBER' OPERATION
17618  3553             ; ---------------------------------
17619  3553             ; (offset: $08 'no-&-no')
17620  3553             ;   The Boolean AND operator.
17621  3553             ;
17622  3553             ;   e.g.    -3 AND 2  returns -3.
17623  3553             ;           -3 AND 0  returns 0.
17624  3553             ;            0 and -2 returns 0.
17625  3553             ;            0 and 0  returns 0.
17626  3553             ;
17627  3553             ;   Compare with OR routine above.
17628  3553             
17629  3553             ;; no-&-no
17630  3553 EB          L3524:  EX      DE,HL           ; make HL address second operand.
17631  3554             
17632  3554 CD 18 35            CALL    L34E9           ; routine TEST-ZERO sets carry if zero.
17633  3557             
17634  3557 EB                  EX      DE,HL           ; restore pointers.
17635  3558 D0                  RET     NC              ; return if second non-zero, first is result.
17636  3559             
17637  3559             ;
17638  3559             
17639  3559 A7                  AND     A               ; else clear carry.
17640  355A 18 DE               JR      L350B           ; back to FP-0/1 to overwrite first operand
17641  355C                                             ; with zero for return value.
17642  355C             
17643  355C             ; ---------------------------------
17644  355C             ; THE 'STRING AND NUMBER' OPERATION
17645  355C             ; ---------------------------------
17646  355C             ; (offset: $10 'str-&-no')
17647  355C             ;   e.g. "You Win" AND score>99 will return the string if condition is true
17648  355C             ;   or the null string if false.
17649  355C             
17650  355C             ;; str-&-no
17651  355C EB          L352D:  EX      DE,HL           ; make HL point to the number.
17652  355D CD 18 35            CALL    L34E9           ; routine TEST-ZERO.
17653  3560 EB                  EX      DE,HL           ; restore pointers. 
17654  3561 D0                  RET     NC              ; return if number was not zero - the string 
17655  3562                                             ; is the result.
17656  3562             
17657  3562             ;   if the number was zero (false) then the null string must be returned by
17658  3562             ;   altering the length of the string on the calculator stack to zero.
17659  3562             
17660  3562 D5                  PUSH    DE              ; save pointer to the now obsolete number 
17661  3563                                             ; (which will become the new STKEND)
17662  3563             
17663  3563 1B                  DEC     DE              ; point to the 5th byte of string descriptor.
17664  3564 AF                  XOR     A               ; clear the accumulator.
17665  3565 12                  LD      (DE),A          ; place zero in high byte of length.
17666  3566 1B                  DEC     DE              ; address low byte of length.
17667  3567 12                  LD      (DE),A          ; place zero there - now the null string.
17668  3568             
17669  3568 D1                  POP     DE              ; restore pointer - new STKEND.
17670  3569 C9                  RET                     ; return.
17671  356A             
17672  356A             ; ---------------------------
17673  356A             ; THE 'COMPARISON' OPERATIONS
17674  356A             ; ---------------------------
17675  356A             ; (offset: $0A 'no-gr-eql')
17676  356A             ; (offset: $0B 'nos-neql')
17677  356A             ; (offset: $0C 'no-grtr')
17678  356A             ; (offset: $0D 'no-less')
17679  356A             ; (offset: $0E 'nos-eql')
17680  356A             ; (offset: $11 'str-l-eql')
17681  356A             ; (offset: $12 'str-gr-eql')
17682  356A             ; (offset: $13 'strs-neql')
17683  356A             ; (offset: $14 'str-grtr')
17684  356A             ; (offset: $15 'str-less')
17685  356A             ; (offset: $16 'strs-eql')
17686  356A             
17687  356A             ;   True binary operations.
17688  356A             ;   A single entry point is used to evaluate six numeric and six string
17689  356A             ;   comparisons. On entry, the calculator literal is in the B register and
17690  356A             ;   the two numeric values, or the two string parameters, are on the 
17691  356A             ;   calculator stack.
17692  356A             ;   The individual bits of the literal are manipulated to group similar
17693  356A             ;   operations although the SUB 8 instruction does nothing useful and merely
17694  356A             ;   alters the string test bit.
17695  356A             ;   Numbers are compared by subtracting one from the other, strings are 
17696  356A             ;   compared by comparing every character until a mismatch, or the end of one
17697  356A             ;   or both, is reached.
17698  356A             ;
17699  356A             ;   Numeric Comparisons.
17700  356A             ;   --------------------
17701  356A             ;   The 'x>y' example is the easiest as it employs straight-thru logic.
17702  356A             ;   Number y is subtracted from x and the result tested for greater-0 yielding
17703  356A             ;   a final value 1 (true) or 0 (false). 
17704  356A             ;   For 'x<y' the same logic is used but the two values are first swapped on the
17705  356A             ;   calculator stack. 
17706  356A             ;   For 'x=y' NOT is applied to the subtraction result yielding true if the
17707  356A             ;   difference was zero and false with anything else. 
17708  356A             ;   The first three numeric comparisons are just the opposite of the last three
17709  356A             ;   so the same processing steps are used and then a final NOT is applied.
17710  356A             ;
17711  356A             ; literal    Test   No  sub 8       ExOrNot  1st RRCA  exch sub  ?   End-Tests
17712  356A             ; =========  ====   == ======== === ======== ========  ==== ===  =  === === ===
17713  356A             ; no-l-eql   x<=y   09 00000001 dec 00000000 00000000  ---- x-y  ?  --- >0? NOT
17714  356A             ; no-gr-eql  x>=y   0A 00000010 dec 00000001 10000000c swap y-x  ?  --- >0? NOT
17715  356A             ; nos-neql   x<>y   0B 00000011 dec 00000010 00000001  ---- x-y  ?  NOT --- NOT
17716  356A             ; no-grtr    x>y    0C 00000100  -  00000100 00000010  ---- x-y  ?  --- >0? ---
17717  356A             ; no-less    x<y    0D 00000101  -  00000101 10000010c swap y-x  ?  --- >0? ---
17718  356A             ; nos-eql    x=y    0E 00000110  -  00000110 00000011  ---- x-y  ?  NOT --- ---
17719  356A             ;
17720  356A             ;                                                           comp -> C/F
17721  356A             ;                                                           ====    ===
17722  356A             ; str-l-eql  x$<=y$ 11 00001001 dec 00001000 00000100  ---- x$y$ 0  !or >0? NOT
17723  356A             ; str-gr-eql x$>=y$ 12 00001010 dec 00001001 10000100c swap y$x$ 0  !or >0? NOT
17724  356A             ; strs-neql  x$<>y$ 13 00001011 dec 00001010 00000101  ---- x$y$ 0  !or >0? NOT
17725  356A             ; str-grtr   x$>y$  14 00001100  -  00001100 00000110  ---- x$y$ 0  !or >0? ---
17726  356A             ; str-less   x$<y$  15 00001101  -  00001101 10000110c swap y$x$ 0  !or >0? ---
17727  356A             ; strs-eql   x$=y$  16 00001110  -  00001110 00000111  ---- x$y$ 0  !or >0? ---
17728  356A             ;
17729  356A             ;   String comparisons are a little different in that the eql/neql carry flag
17730  356A             ;   from the 2nd RRCA is, as before, fed into the first of the end tests but
17731  356A             ;   along the way it gets modified by the comparison process. The result on the
17732  356A             ;   stack always starts off as zero and the carry fed in determines if NOT is 
17733  356A             ;   applied to it. So the only time the greater-0 test is applied is if the
17734  356A             ;   stack holds zero which is not very efficient as the test will always yield
17735  356A             ;   zero. The most likely explanation is that there were once separate end tests
17736  356A             ;   for numbers and strings.
17737  356A             
17738  356A             ;; no-l-eql,etc.
17739  356A 78          L353B:  LD      A,B             ; transfer literal to accumulator.
17740  356B D6 08               SUB     $08             ; subtract eight - which is not useful. 
17741  356D             
17742  356D CB 57               BIT     2,A             ; isolate '>', '<', '='.
17743  356F             
17744  356F 20 01               JR      NZ,L3543        ; skip to EX-OR-NOT with these.
17745  3571             
17746  3571 3D                  DEC     A               ; else make $00-$02, $08-$0A to match bits 0-2.
17747  3572             
17748  3572             ;; EX-OR-NOT
17749  3572 0F          L3543:  RRCA                    ; the first RRCA sets carry for a swap. 
17750  3573 30 08               JR      NC,L354E        ; forward to NU-OR-STR with other 8 cases
17751  3575             
17752  3575             ; for the other 4 cases the two values on the calculator stack are exchanged.
17753  3575             
17754  3575 F5                  PUSH    AF              ; save A and carry.
17755  3576 E5                  PUSH    HL              ; save HL - pointer to first operand.
17756  3577                                             ; (DE points to second operand).
17757  3577             
17758  3577 CD 6B 34            CALL    L343C           ; routine exchange swaps the two values.
17759  357A                                             ; (HL = second operand, DE = STKEND)
17760  357A             
17761  357A D1                  POP     DE              ; DE = first operand
17762  357B EB                  EX      DE,HL           ; as we were.
17763  357C F1                  POP     AF              ; restore A and carry.
17764  357D             
17765  357D             ; Note. it would be better if the 2nd RRCA preceded the string test.
17766  357D             ; It would save two duplicate bytes and if we also got rid of that sub 8 
17767  357D             ; at the beginning we wouldn't have to alter which bit we test.
17768  357D             
17769  357D             ;; NU-OR-STR
17770  357D CB 57       L354E:  BIT     2,A             ; test if a string comparison.
17771  357F 20 07               JR      NZ,L3559        ; forward to STRINGS if so.
17772  3581             
17773  3581             ; continue with numeric comparisons.
17774  3581             
17775  3581 0F                  RRCA                    ; 2nd RRCA causes eql/neql to set carry.
17776  3582 F5                  PUSH    AF              ; save A and carry
17777  3583             
17778  3583 CD 3E 30            CALL    L300F           ; routine subtract leaves result on stack.
17779  3586 18 33               JR      L358C           ; forward to END-TESTS
17780  3588             
17781  3588             ; ---
17782  3588             
17783  3588             ;; STRINGS
17784  3588 0F          L3559:  RRCA                    ; 2nd RRCA causes eql/neql to set carry.
17785  3589 F5                  PUSH    AF              ; save A and carry.
17786  358A             
17787  358A CD 20 2C            CALL    L2BF1           ; routine STK-FETCH gets 2nd string params
17788  358D D5                  PUSH    DE              ; save start2 *.
17789  358E C5                  PUSH    BC              ; and the length.
17790  358F             
17791  358F CD 20 2C            CALL    L2BF1           ; routine STK-FETCH gets 1st string 
17792  3592                                             ; parameters - start in DE, length in BC.
17793  3592 E1                  POP     HL              ; restore length of second to HL.
17794  3593             
17795  3593             ; A loop is now entered to compare, by subtraction, each corresponding character
17796  3593             ; of the strings. For each successful match, the pointers are incremented and 
17797  3593             ; the lengths decreased and the branch taken back to here. If both string 
17798  3593             ; remainders become null at the same time, then an exact match exists.
17799  3593             
17800  3593             ;; BYTE-COMP
17801  3593 7C          L3564:  LD      A,H             ; test if the second string
17802  3594 B5                  OR      L               ; is the null string and hold flags.
17803  3595             
17804  3595 E3                  EX      (SP),HL         ; put length2 on stack, bring start2 to HL *.
17805  3596 78                  LD      A,B             ; hi byte of length1 to A
17806  3597             
17807  3597 20 0B               JR      NZ,L3575        ; forward to SEC-PLUS if second not null.
17808  3599             
17809  3599 B1                  OR      C               ; test length of first string.
17810  359A             
17811  359A             ;; SECND-LOW
17812  359A C1          L356B:  POP     BC              ; pop the second length off stack.
17813  359B 28 04               JR      Z,L3572         ; forward to BOTH-NULL if first string is also
17814  359D                                             ; of zero length.
17815  359D             
17816  359D             ; the true condition - first is longer than second (SECND-LESS)
17817  359D             
17818  359D F1                  POP     AF              ; restore carry (set if eql/neql)
17819  359E 3F                  CCF                     ; complement carry flag.
17820  359F                                             ; Note. equality becomes false.
17821  359F                                             ; Inequality is true. By swapping or applying
17822  359F                                             ; a terminal 'not', all comparisons have been
17823  359F                                             ; manipulated so that this is success path. 
17824  359F 18 16               JR      L3588           ; forward to leave via STR-TEST
17825  35A1             
17826  35A1             ; ---
17827  35A1             ; the branch was here with a match
17828  35A1             
17829  35A1             ;; BOTH-NULL
17830  35A1 F1          L3572:  POP     AF              ; restore carry - set for eql/neql
17831  35A2 18 13               JR      L3588           ; forward to STR-TEST
17832  35A4             
17833  35A4             ; ---  
17834  35A4             ; the branch was here when 2nd string not null and low byte of first is yet
17835  35A4             ; to be tested.
17836  35A4             
17837  35A4             
17838  35A4             ;; SEC-PLUS
17839  35A4 B1          L3575:  OR      C               ; test the length of first string.
17840  35A5 28 0D               JR      Z,L3585         ; forward to FRST-LESS if length is zero.
17841  35A7             
17842  35A7             ; both strings have at least one character left.
17843  35A7             
17844  35A7 1A                  LD      A,(DE)          ; fetch character of first string. 
17845  35A8 96                  SUB     (HL)            ; subtract with that of 2nd string.
17846  35A9 38 09               JR      C,L3585         ; forward to FRST-LESS if carry set
17847  35AB             
17848  35AB 20 ED               JR      NZ,L356B        ; back to SECND-LOW and then STR-TEST
17849  35AD                                             ; if not exact match.
17850  35AD             
17851  35AD 0B                  DEC     BC              ; decrease length of 1st string.
17852  35AE 13                  INC     DE              ; increment 1st string pointer.
17853  35AF             
17854  35AF 23                  INC     HL              ; increment 2nd string pointer.
17855  35B0 E3                  EX      (SP),HL         ; swap with length on stack
17856  35B1 2B                  DEC     HL              ; decrement 2nd string length
17857  35B2 18 DF               JR      L3564           ; back to BYTE-COMP
17858  35B4             
17859  35B4             ; ---
17860  35B4             ; the false condition.
17861  35B4             
17862  35B4             ;; FRST-LESS
17863  35B4 C1          L3585:  POP     BC              ; discard length
17864  35B5 F1                  POP     AF              ; pop A
17865  35B6 A7                  AND     A               ; clear the carry for false result.
17866  35B7             
17867  35B7             ; ---
17868  35B7             ; exact match and x$>y$ rejoin here
17869  35B7             
17870  35B7             ;; STR-TEST
17871  35B7 F5          L3588:  PUSH    AF              ; save A and carry
17872  35B8             
17873  35B8 EF                  RST     28H             ;; FP-CALC
17874  35B9 A0                  DEFB    $A0             ;;stk-zero      an initial false value.
17875  35BA 38                  DEFB    $38             ;;end-calc
17876  35BB             
17877  35BB             ; both numeric and string paths converge here.
17878  35BB             
17879  35BB             ;; END-TESTS
17880  35BB F1          L358C:  POP     AF              ; pop carry  - will be set if eql/neql
17881  35BC F5                  PUSH    AF              ; save it again.
17882  35BD             
17883  35BD DC 30 35            CALL    C,L3501         ; routine NOT sets true(1) if equal(0)
17884  35C0                                             ; or, for strings, applies true result.
17885  35C0             
17886  35C0 F1                  POP     AF              ; pop carry and
17887  35C1 F5                  PUSH    AF              ; save A
17888  35C2             
17889  35C2 D4 28 35            CALL    NC,L34F9        ; routine GREATER-0 tests numeric subtraction 
17890  35C5                                             ; result but also needlessly tests the string 
17891  35C5                                             ; value for zero - it must be.
17892  35C5             
17893  35C5 F1                  POP     AF              ; pop A 
17894  35C6 0F                  RRCA                    ; the third RRCA - test for '<=', '>=' or '<>'.
17895  35C7 D4 30 35            CALL    NC,L3501        ; apply a terminal NOT if so.
17896  35CA C9                  RET                     ; return.
17897  35CB             
17898  35CB             ; ------------------------------------
17899  35CB             ; THE 'STRING CONCATENATION' OPERATION
17900  35CB             ; ------------------------------------
17901  35CB             ; (offset: $17 'strs-add')
17902  35CB             ;   This literal combines two strings into one e.g. LET a$ = b$ + c$
17903  35CB             ;   The two parameters of the two strings to be combined are on the stack.
17904  35CB             
17905  35CB             ;; strs-add
17906  35CB CD 20 2C    L359C:  CALL    L2BF1           ; routine STK-FETCH fetches string parameters
17907  35CE                                             ; and deletes calculator stack entry.
17908  35CE D5                  PUSH    DE              ; save start address.
17909  35CF C5                  PUSH    BC              ; and length.
17910  35D0             
17911  35D0 CD 20 2C            CALL    L2BF1           ; routine STK-FETCH for first string
17912  35D3 E1                  POP     HL              ; re-fetch first length
17913  35D4 E5                  PUSH    HL              ; and save again
17914  35D5 D5                  PUSH    DE              ; save start of second string
17915  35D6 C5                  PUSH    BC              ; and its length.
17916  35D7             
17917  35D7 09                  ADD     HL,BC           ; add the two lengths.
17918  35D8 44                  LD      B,H             ; transfer to BC
17919  35D9 4D                  LD      C,L             ; and create
17920  35DA F7                  RST     30H             ; BC-SPACES in workspace.
17921  35DB                                             ; DE points to start of space.
17922  35DB             
17923  35DB CD E1 2A            CALL    L2AB2           ; routine STK-STO-$ stores parameters
17924  35DE                                             ; of new string updating STKEND.
17925  35DE             
17926  35DE C1                  POP     BC              ; length of first
17927  35DF E1                  POP     HL              ; address of start
17928  35E0 78                  LD      A,B             ; test for
17929  35E1 B1                  OR      C               ; zero length.
17930  35E2 28 02               JR      Z,L35B7         ; to OTHER-STR if null string
17931  35E4             
17932  35E4 ED B0               LDIR                    ; copy string to workspace.
17933  35E6             
17934  35E6             ;; OTHER-STR
17935  35E6 C1          L35B7:  POP     BC              ; now second length
17936  35E7 E1                  POP     HL              ; and start of string
17937  35E8 78                  LD      A,B             ; test this one
17938  35E9 B1                  OR      C               ; for zero length
17939  35EA 28 02               JR      Z,L35BF         ; skip forward to STK-PNTRS if so as complete.
17940  35EC             
17941  35EC ED B0               LDIR                    ; else copy the bytes.
17942  35EE                                             ; and continue into next routine which
17943  35EE                                             ; sets the calculator stack pointers.
17944  35EE             
17945  35EE             ; -----------------------------------
17946  35EE             ; THE 'SET STACK POINTERS' SUBROUTINE
17947  35EE             ; -----------------------------------
17948  35EE             ;   Register DE is set to STKEND and HL, the result pointer, is set to five 
17949  35EE             ;   locations below this.
17950  35EE             ;   This routine is used when it is inconvenient to save these values at the
17951  35EE             ;   time the calculator stack is manipulated due to other activity on the 
17952  35EE             ;   machine stack.
17953  35EE             ;   This routine is also used to terminate the VAL and READ-IN  routines for
17954  35EE             ;   the same reason and to initialize the calculator stack at the start of
17955  35EE             ;   the CALCULATE routine.
17956  35EE             
17957  35EE             ;; STK-PNTRS
17958  35EE 2A 65 5C    L35BF:  LD      HL,($5C65)      ; fetch STKEND value from system variable.
17959  35F1 11 FB FF            LD      DE,$FFFB        ; the value -5
17960  35F4 E5                  PUSH    HL              ; push STKEND value.
17961  35F5             
17962  35F5 19                  ADD     HL,DE           ; subtract 5 from HL.
17963  35F6             
17964  35F6 D1                  POP     DE              ; pop STKEND to DE.
17965  35F7 C9                  RET                     ; return.
17966  35F8             
17967  35F8             ; -------------------
17968  35F8             ; THE 'CHR$' FUNCTION
17969  35F8             ; -------------------
17970  35F8             ; (offset: $2f 'chr$')
17971  35F8             ;   This function returns a single character string that is a result of 
17972  35F8             ;   converting a number in the range 0-255 to a string e.g. CHR$ 65 = "A".
17973  35F8             
17974  35F8             ;; chrs
17975  35F8 CD 04 2E    L35C9:  CALL    L2DD5           ; routine FP-TO-A puts the number in A.
17976  35FB             
17977  35FB 38 0E               JR      C,L35DC         ; forward to REPORT-Bd if overflow
17978  35FD 20 0C               JR      NZ,L35DC        ; forward to REPORT-Bd if negative
17979  35FF             
17980  35FF F5                  PUSH    AF              ; save the argument.
17981  3600             
17982  3600 01 01 00            LD      BC,$0001        ; one space required.
17983  3603 F7                  RST     30H             ; BC-SPACES makes DE point to start
17984  3604             
17985  3604 F1                  POP     AF              ; restore the number.
17986  3605             
17987  3605 12                  LD      (DE),A          ; and store in workspace
17988  3606             
17989  3606 CD E1 2A            CALL    L2AB2           ; routine STK-STO-$ stacks descriptor.
17990  3609             
17991  3609 EB                  EX      DE,HL           ; make HL point to result and DE to STKEND.
17992  360A C9                  RET                     ; return.
17993  360B             
17994  360B             ; ---
17995  360B             
17996  360B             ;; REPORT-Bd
17997  360B CF          L35DC:  RST     08H             ; ERROR-1
17998  360C 0A                  DEFB    $0A             ; Error Report: Integer out of range
17999  360D             
18000  360D             ; ----------------------------
18001  360D             ; THE 'VAL and VAL$' FUNCTIONS
18002  360D             ; ----------------------------
18003  360D             ; (offset: $1d 'val')
18004  360D             ; (offset: $18 'val$')
18005  360D             ;   VAL treats the characters in a string as a numeric expression.
18006  360D             ;   e.g. VAL "2.3" = 2.3, VAL "2+4" = 6, VAL ("2" + "4") = 24.
18007  360D             ;   VAL$ treats the characters in a string as a string expression.
18008  360D             ;   e.g. VAL$ (z$+"(2)") = a$(2) if z$ happens to be "a$".
18009  360D             
18010  360D             ;; val
18011  360D             ;; val$
18012  360D 2A 5D 5C    L35DE:  LD      HL,($5C5D)      ; fetch value of system variable CH_ADD
18013  3610 E5                  PUSH    HL              ; and save on the machine stack.
18014  3611 78                  LD      A,B             ; fetch the literal (either $1D or $18).
18015  3612 C6 E3               ADD     A,$E3           ; add $E3 to form $00 (setting carry) or $FB.
18016  3614 9F                  SBC     A,A             ; now form $FF bit 6 = numeric result
18017  3615                                             ; or $00 bit 6 = string result.
18018  3615 F5                  PUSH    AF              ; save this mask on the stack
18019  3616             
18020  3616 CD 20 2C            CALL    L2BF1           ; routine STK-FETCH fetches the string operand
18021  3619                                             ; from calculator stack.
18022  3619             
18023  3619 D5                  PUSH    DE              ; save the address of the start of the string.
18024  361A 03                  INC     BC              ; increment the length for a carriage return.
18025  361B             
18026  361B F7                  RST     30H             ; BC-SPACES creates the space in workspace.
18027  361C E1                  POP     HL              ; restore start of string to HL.
18028  361D ED 53 5D 5C         LD      ($5C5D),DE      ; load CH_ADD with start DE in workspace.
18029  3621             
18030  3621 D5                  PUSH    DE              ; save the start in workspace
18031  3622 ED B0               LDIR                    ; copy string from program or variables or
18032  3624                                             ; workspace to the workspace area.
18033  3624 EB                  EX      DE,HL           ; end of string + 1 to HL
18034  3625 2B                  DEC     HL              ; decrement HL to point to end of new area.
18035  3626 36 0D               LD      (HL),$0D        ; insert a carriage return at end.
18036  3628 FD CB 01 BE         RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax.
18037  362C CD 2A 25            CALL    L24FB           ; routine SCANNING evaluates string
18038  362F                                             ; expression and result.
18039  362F             
18040  362F DF                  RST     18H             ; GET-CHAR fetches next character.
18041  3630 FE 0D               CP      $0D             ; is it the expected carriage return ?
18042  3632 20 07               JR      NZ,L360C        ; forward to V-RPORT-C if not
18043  3634                                             ; 'Nonsense in BASIC'.
18044  3634             
18045  3634 E1                  POP     HL              ; restore start of string in workspace.
18046  3635 F1                  POP     AF              ; restore expected result flag (bit 6).
18047  3636 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS now updated by SCANNING.
18048  3639 E6 40               AND     $40             ; test bit 6 - should be zero if result types
18049  363B                                             ; match.
18050  363B             
18051  363B             ;; V-RPORT-C
18052  363B C2 B9 1C    L360C:  JP      NZ,L1C8A        ; jump back to REPORT-C with a result mismatch.
18053  363E             
18054  363E 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to the start of the string again.
18055  3641 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS  - signal running program.
18056  3645 CD 2A 25            CALL    L24FB           ; routine SCANNING evaluates the string
18057  3648                                             ; in full leaving result on calculator stack.
18058  3648             
18059  3648 E1                  POP     HL              ; restore saved character address in program.
18060  3649 22 5D 5C            LD      ($5C5D),HL      ; and reset the system variable CH_ADD.
18061  364C             
18062  364C 18 A0               JR      L35BF           ; back to exit via STK-PNTRS.
18063  364E                                             ; resetting the calculator stack pointers
18064  364E                                             ; HL and DE from STKEND as it wasn't possible 
18065  364E                                             ; to preserve them during this routine.
18066  364E             
18067  364E             ; -------------------
18068  364E             ; THE 'STR$' FUNCTION
18069  364E             ; -------------------
18070  364E             ; (offset: $2e 'str$')
18071  364E             ;   This function produces a string comprising the characters that would appear
18072  364E             ;   if the numeric argument were printed.
18073  364E             ;   e.g. STR$ (1/10) produces "0.1".
18074  364E             
18075  364E             ;; str$
18076  364E 01 01 00    L361F:  LD      BC,$0001        ; create an initial byte in workspace
18077  3651 F7                  RST     30H             ; using BC-SPACES restart.
18078  3652             
18079  3652 22 5B 5C            LD      ($5C5B),HL      ; set system variable K_CUR to new location.
18080  3655 E5                  PUSH    HL              ; and save start on machine stack also.
18081  3656             
18082  3656 2A 51 5C            LD      HL,($5C51)      ; fetch value of system variable CURCHL
18083  3659 E5                  PUSH    HL              ; and save that too.
18084  365A             
18085  365A 3E FF               LD      A,$FF           ; select system channel 'R'.
18086  365C CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens it.
18087  365F CD 12 2E            CALL    L2DE3           ; routine PRINT-FP outputs the number to
18088  3662                                             ; workspace updating K-CUR.
18089  3662             
18090  3662 E1                  POP     HL              ; restore current channel.
18091  3663 CD 44 16            CALL    L1615           ; routine CHAN-FLAG resets flags.
18092  3666             
18093  3666 D1                  POP     DE              ; fetch saved start of string to DE.
18094  3667 2A 5B 5C            LD      HL,($5C5B)      ; load HL with end of string from K_CUR.
18095  366A             
18096  366A A7                  AND     A               ; prepare for true subtraction.
18097  366B ED 52               SBC     HL,DE           ; subtract start from end to give length.
18098  366D 44                  LD      B,H             ; transfer the length to
18099  366E 4D                  LD      C,L             ; the BC register pair.
18100  366F             
18101  366F CD E1 2A            CALL    L2AB2           ; routine STK-STO-$ stores string parameters
18102  3672                                             ; on the calculator stack.
18103  3672             
18104  3672 EB                  EX      DE,HL           ; HL = last value, DE = STKEND.
18105  3673 C9                  RET                     ; return.
18106  3674             
18107  3674             ; ------------------------
18108  3674             ; THE 'READ-IN' SUBROUTINE
18109  3674             ; ------------------------
18110  3674             ; (offset: $1a 'read-in')
18111  3674             ;   This is the calculator literal used by the INKEY$ function when a '#'
18112  3674             ;   is encountered after the keyword.
18113  3674             ;   INKEY$ # does not interact correctly with the keyboard, #0 or #1, and
18114  3674             ;   its uses are for other channels.
18115  3674             
18116  3674             ;; read-in
18117  3674 CD C3 1E    L3645:  CALL    L1E94           ; routine FIND-INT1 fetches stream to A
18118  3677 FE 10               CP      $10             ; compare with 16 decimal.
18119  3679 D2 CE 1E            JP      NC,L1E9F        ; JUMP to REPORT-Bb if not in range 0 - 15.
18120  367C                                             ; 'Integer out of range'
18121  367C                                             ; (REPORT-Bd is within range)
18122  367C             
18123  367C 2A 51 5C            LD      HL,($5C51)      ; fetch current channel CURCHL
18124  367F E5                  PUSH    HL              ; save it
18125  3680             
18126  3680 CD 30 16            CALL    L1601           ; routine CHAN-OPEN opens channel
18127  3683             
18128  3683 CD 15 16            CALL    L15E6           ; routine INPUT-AD - the channel must have an
18129  3686                                             ; input stream or else error here from stream
18130  3686                                             ; stub.
18131  3686 01 00 00            LD      BC,$0000        ; initialize length of string to zero
18132  3689 30 03               JR      NC,L365F        ; forward to R-I-STORE if no key detected.
18133  368B             
18134  368B 0C                  INC     C               ; increase length to one.
18135  368C             
18136  368C F7                  RST     30H             ; BC-SPACES creates space for one character
18137  368D                                             ; in workspace.
18138  368D 12                  LD      (DE),A          ; the character is inserted.
18139  368E             
18140  368E             ;; R-I-STORE
18141  368E CD E1 2A    L365F:  CALL    L2AB2           ; routine STK-STO-$ stacks the string
18142  3691                                             ; parameters.
18143  3691 E1                  POP     HL              ; restore current channel address
18144  3692             
18145  3692 CD 44 16            CALL    L1615           ; routine CHAN-FLAG resets current channel
18146  3695                                             ; system variable and flags.
18147  3695             
18148  3695 C3 EE 35            JP      L35BF           ; jump back to STK-PNTRS
18149  3698             
18150  3698             ; -------------------
18151  3698             ; THE 'CODE' FUNCTION
18152  3698             ; -------------------
18153  3698             ; (offset: $1c 'code')
18154  3698             ;   Returns the ASCII code of a character or first character of a string
18155  3698             ;   e.g. CODE "Aardvark" = 65, CODE "" = 0.
18156  3698             
18157  3698             ;; code
18158  3698 CD 20 2C    L3669:  CALL    L2BF1           ; routine STK-FETCH to fetch and delete the
18159  369B                                             ; string parameters.
18160  369B                                             ; DE points to the start, BC holds the length.
18161  369B             
18162  369B 78                  LD      A,B             ; test length
18163  369C B1                  OR      C               ; of the string.
18164  369D 28 01               JR      Z,L3671         ; skip to STK-CODE with zero if the null string.
18165  369F             
18166  369F 1A                  LD      A,(DE)          ; else fetch the first character.
18167  36A0             
18168  36A0             ;; STK-CODE
18169  36A0 C3 57 2D    L3671:  JP      L2D28           ; jump back to STACK-A (with memory check)
18170  36A3             
18171  36A3             ; ------------------
18172  36A3             ; THE 'LEN' FUNCTION
18173  36A3             ; ------------------
18174  36A3             ; (offset: $1e 'len')
18175  36A3             ;   Returns the length of a string.
18176  36A3             ;   In Sinclair BASIC strings can be more than twenty thousand characters long
18177  36A3             ;   so a sixteen-bit register is required to store the length
18178  36A3             
18179  36A3             ;; len
18180  36A3 CD 20 2C    L3674:  CALL    L2BF1           ; Routine STK-FETCH to fetch and delete the
18181  36A6                                             ; string parameters from the calculator stack.
18182  36A6                                             ; Register BC now holds the length of string.
18183  36A6             
18184  36A6 C3 5A 2D            JP      L2D2B           ; Jump back to STACK-BC to save result on the
18185  36A9                                             ; calculator stack (with memory check).
18186  36A9             
18187  36A9             ; -------------------------------------
18188  36A9             ; THE 'DECREASE THE COUNTER' SUBROUTINE
18189  36A9             ; -------------------------------------
18190  36A9             ; (offset: $35 'dec-jr-nz')
18191  36A9             ;   The calculator has an instruction that decrements a single-byte
18192  36A9             ;   pseudo-register and makes consequential relative jumps just like
18193  36A9             ;   the Z80's DJNZ instruction.
18194  36A9             
18195  36A9             ;; dec-jr-nz
18196  36A9 D9          L367A:  EXX                     ; switch in set that addresses code
18197  36AA             
18198  36AA E5                  PUSH    HL              ; save pointer to offset byte
18199  36AB 21 67 5C            LD      HL,$5C67        ; address BREG in system variables
18200  36AE 35                  DEC     (HL)            ; decrement it
18201  36AF E1                  POP     HL              ; restore pointer
18202  36B0             
18203  36B0 20 04               JR      NZ,L3687        ; to JUMP-2 if not zero
18204  36B2             
18205  36B2 23                  INC     HL              ; step past the jump length.
18206  36B3 D9                  EXX                     ; switch in the main set.
18207  36B4 C9                  RET                     ; return.
18208  36B5             
18209  36B5             ; Note. as a general rule the calculator avoids using the IY register
18210  36B5             ; otherwise the cumbersome 4 instructions in the middle could be replaced by
18211  36B5             ; dec (iy+$2d) - three bytes instead of six.
18212  36B5             
18213  36B5             
18214  36B5             ; ---------------------
18215  36B5             ; THE 'JUMP' SUBROUTINE
18216  36B5             ; ---------------------
18217  36B5             ; (offset: $33 'jump')
18218  36B5             ;   This enables the calculator to perform relative jumps just like the Z80 
18219  36B5             ;   chip's JR instruction.
18220  36B5             
18221  36B5             ;; jump
18222  36B5             ;; JUMP
18223  36B5 D9          L3686:  EXX                     ; switch in pointer set
18224  36B6             
18225  36B6             ;; JUMP-2
18226  36B6 5E          L3687:  LD      E,(HL)          ; the jump byte 0-127 forward, 128-255 back.
18227  36B7 7B                  LD      A,E             ; transfer to accumulator.
18228  36B8 17                  RLA                     ; if backward jump, carry is set.
18229  36B9 9F                  SBC     A,A             ; will be $FF if backward or $00 if forward.
18230  36BA 57                  LD      D,A             ; transfer to high byte.
18231  36BB 19                  ADD     HL,DE           ; advance calculator pointer forward or back.
18232  36BC             
18233  36BC D9                  EXX                     ; switch back.
18234  36BD C9                  RET                     ; return.
18235  36BE             
18236  36BE             ; --------------------------
18237  36BE             ; THE 'JUMP-TRUE' SUBROUTINE
18238  36BE             ; --------------------------
18239  36BE             ; (offset: $00 'jump-true')
18240  36BE             ;   This enables the calculator to perform conditional relative jumps dependent
18241  36BE             ;   on whether the last test gave a true result.
18242  36BE             
18243  36BE             ;; jump-true
18244  36BE 13          L368F:  INC     DE              ; Collect the 
18245  36BF 13                  INC     DE              ; third byte
18246  36C0 1A                  LD      A,(DE)          ; of the test
18247  36C1 1B                  DEC     DE              ; result and
18248  36C2 1B                  DEC     DE              ; backtrack.
18249  36C3             
18250  36C3 A7                  AND     A               ; Is result 0 or 1 ? 
18251  36C4 20 EF               JR      NZ,L3686        ; Back to JUMP if true (1).
18252  36C6             
18253  36C6 D9                  EXX                     ; Else switch in the pointer set.
18254  36C7 23                  INC     HL              ; Step past the jump length.
18255  36C8 D9                  EXX                     ; Switch in the main set.
18256  36C9 C9                  RET                     ; Return.
18257  36CA             
18258  36CA             ; -------------------------
18259  36CA             ; THE 'END-CALC' SUBROUTINE
18260  36CA             ; -------------------------
18261  36CA             ; (offset: $38 'end-calc')
18262  36CA             ;   The end-calc literal terminates a mini-program written in the Spectrum's
18263  36CA             ;   internal language.
18264  36CA             
18265  36CA             ;; end-calc
18266  36CA F1          L369B:  POP     AF              ; Drop the calculator return address RE-ENTRY
18267  36CB D9                  EXX                     ; Switch to the other set.
18268  36CC             
18269  36CC E3                  EX      (SP),HL         ; Transfer H'L' to machine stack for the
18270  36CD                                             ; return address.
18271  36CD                                             ; When exiting recursion, then the previous
18272  36CD                                             ; pointer is transferred to H'L'.
18273  36CD             
18274  36CD D9                  EXX                     ; Switch back to main set.
18275  36CE C9                  RET                     ; Return.
18276  36CF             
18277  36CF             
18278  36CF             ; ------------------------
18279  36CF             ; THE 'MODULUS' SUBROUTINE 
18280  36CF             ; ------------------------
18281  36CF             ; (offset: $32 'n-mod-m')
18282  36CF             ; (n1,n2 -- r,q)  
18283  36CF             ;   Similar to FORTH's 'divide mod' /MOD
18284  36CF             ;   On the Spectrum, this is only used internally by the RND function and could
18285  36CF             ;   have been implemented inline.  On the ZX81, this calculator routine was also
18286  36CF             ;   used by PRINT-FP.
18287  36CF             
18288  36CF             ;; n-mod-m
18289  36CF EF          L36A0:  RST     28H             ;; FP-CALC          17, 3.
18290  36D0 C0                  DEFB    $C0             ;;st-mem-0          17, 3.
18291  36D1 02                  DEFB    $02             ;;delete            17.
18292  36D2 31                  DEFB    $31             ;;duplicate         17, 17.
18293  36D3 E0                  DEFB    $E0             ;;get-mem-0         17, 17, 3.
18294  36D4 05                  DEFB    $05             ;;division          17, 17/3.
18295  36D5 27                  DEFB    $27             ;;int               17, 5.
18296  36D6 E0                  DEFB    $E0             ;;get-mem-0         17, 5, 3.
18297  36D7 01                  DEFB    $01             ;;exchange          17, 3, 5.
18298  36D8 C0                  DEFB    $C0             ;;st-mem-0          17, 3, 5.
18299  36D9 04                  DEFB    $04             ;;multiply          17, 15.
18300  36DA 03                  DEFB    $03             ;;subtract          2.
18301  36DB E0                  DEFB    $E0             ;;get-mem-0         2, 5.
18302  36DC 38                  DEFB    $38             ;;end-calc          2, 5.
18303  36DD             
18304  36DD C9                  RET                     ; return.
18305  36DE             
18306  36DE             
18307  36DE             ; ------------------
18308  36DE             ; THE 'INT' FUNCTION
18309  36DE             ; ------------------
18310  36DE             ; (offset $27: 'int' )
18311  36DE             ; This function returns the integer of x, which is just the same as truncate
18312  36DE             ; for positive numbers. The truncate literal truncates negative numbers
18313  36DE             ; upwards so that -3.4 gives -3 whereas the BASIC INT function has to
18314  36DE             ; truncate negative numbers down so that INT -3.4 is -4.
18315  36DE             ; It is best to work through using, say, +-3.4 as examples.
18316  36DE             
18317  36DE             ;; int
18318  36DE EF          L36AF:  RST     28H             ;; FP-CALC              x.    (= 3.4 or -3.4).
18319  36DF 31                  DEFB    $31             ;;duplicate             x, x.
18320  36E0 36                  DEFB    $36             ;;less-0                x, (1/0)
18321  36E1 00                  DEFB    $00             ;;jump-true             x, (1/0)
18322  36E2 04                  DEFB    $04             ;;to L36B7, X-NEG
18323  36E3             
18324  36E3 3A                  DEFB    $3A             ;;truncate              trunc 3.4 = 3.
18325  36E4 38                  DEFB    $38             ;;end-calc              3.
18326  36E5             
18327  36E5 C9                  RET                     ; return with + int x on stack.
18328  36E6             
18329  36E6             ; ---
18330  36E6             
18331  36E6             
18332  36E6             ;; X-NEG
18333  36E6 31          L36B7:  DEFB    $31             ;;duplicate             -3.4, -3.4.
18334  36E7 3A                  DEFB    $3A             ;;truncate              -3.4, -3.
18335  36E8 C0                  DEFB    $C0             ;;st-mem-0              -3.4, -3.
18336  36E9 03                  DEFB    $03             ;;subtract              -.4
18337  36EA E0                  DEFB    $E0             ;;get-mem-0             -.4, -3.
18338  36EB 01                  DEFB    $01             ;;exchange              -3, -.4.
18339  36EC 30                  DEFB    $30             ;;not                   -3, (0).
18340  36ED 00                  DEFB    $00             ;;jump-true             -3.
18341  36EE 03                  DEFB    $03             ;;to L36C2, EXIT        -3.
18342  36EF             
18343  36EF A1                  DEFB    $A1             ;;stk-one               -3, 1.
18344  36F0 03                  DEFB    $03             ;;subtract              -4.
18345  36F1             
18346  36F1             ;; EXIT
18347  36F1 38          L36C2:  DEFB    $38             ;;end-calc              -4.
18348  36F2             
18349  36F2 C9                  RET                     ; return.
18350  36F3             
18351  36F3             
18352  36F3             ; ------------------
18353  36F3             ; THE 'EXP' FUNCTION
18354  36F3             ; ------------------
18355  36F3             ; (offset $26: 'exp')
18356  36F3             ;   The exponential function EXP x is equal to e^x, where e is the mathematical
18357  36F3             ;   name for a number approximated to 2.718281828.
18358  36F3             ;   ERROR 6 if argument is more than about 88.
18359  36F3             
18360  36F3             ;; EXP
18361  36F3             ;; exp
18362  36F3 EF          L36C4:  RST     28H             ;; FP-CALC
18363  36F4 3D                  DEFB    $3D             ;;re-stack      (not required - mult will do)
18364  36F5 34                  DEFB    $34             ;;stk-data
18365  36F6 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
18366  36F7 38 AA 3B 29         DEFB    $38,$AA,$3B,$29 ;;
18367  36FB 04                  DEFB    $04             ;;multiply
18368  36FC 31                  DEFB    $31             ;;duplicate
18369  36FD 27                  DEFB    $27             ;;int
18370  36FE C3                  DEFB    $C3             ;;st-mem-3
18371  36FF 03                  DEFB    $03             ;;subtract
18372  3700 31                  DEFB    $31             ;;duplicate
18373  3701 0F                  DEFB    $0F             ;;addition
18374  3702 A1                  DEFB    $A1             ;;stk-one
18375  3703 03                  DEFB    $03             ;;subtract
18376  3704 88                  DEFB    $88             ;;series-08
18377  3705 13                  DEFB    $13             ;;Exponent: $63, Bytes: 1
18378  3706 36                  DEFB    $36             ;;(+00,+00,+00)
18379  3707 58                  DEFB    $58             ;;Exponent: $68, Bytes: 2
18380  3708 65 66               DEFB    $65,$66         ;;(+00,+00)
18381  370A 9D                  DEFB    $9D             ;;Exponent: $6D, Bytes: 3
18382  370B 78 65 40            DEFB    $78,$65,$40     ;;(+00)
18383  370E A2                  DEFB    $A2             ;;Exponent: $72, Bytes: 3
18384  370F 60 32 C9            DEFB    $60,$32,$C9     ;;(+00)
18385  3712 E7                  DEFB    $E7             ;;Exponent: $77, Bytes: 4
18386  3713 21 F7 AF 24         DEFB    $21,$F7,$AF,$24 ;;
18387  3717 EB                  DEFB    $EB             ;;Exponent: $7B, Bytes: 4
18388  3718 2F B0 B0 14         DEFB    $2F,$B0,$B0,$14 ;;
18389  371C EE                  DEFB    $EE             ;;Exponent: $7E, Bytes: 4
18390  371D 7E BB 94 58         DEFB    $7E,$BB,$94,$58 ;;
18391  3721 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
18392  3722 3A 7E F8 CF         DEFB    $3A,$7E,$F8,$CF ;;
18393  3726 E3                  DEFB    $E3             ;;get-mem-3
18394  3727 38                  DEFB    $38             ;;end-calc
18395  3728             
18396  3728 CD 04 2E            CALL    L2DD5           ; routine FP-TO-A
18397  372B 20 07               JR      NZ,L3705        ; to N-NEGTV
18398  372D             
18399  372D 38 03               JR      C,L3703         ; to REPORT-6b
18400  372F                                             ; 'Number too big'
18401  372F             
18402  372F 86                  ADD     A,(HL)          ;
18403  3730 30 09               JR      NC,L370C        ; to RESULT-OK
18404  3732             
18405  3732             
18406  3732             ;; REPORT-6b
18407  3732 CF          L3703:  RST     08H             ; ERROR-1
18408  3733 05                  DEFB    $05             ; Error Report: Number too big
18409  3734             
18410  3734             ; ---
18411  3734             
18412  3734             ;; N-NEGTV
18413  3734 38 07       L3705:  JR      C,L370E         ; to RSLT-ZERO
18414  3736             
18415  3736 96                  SUB     (HL)            ;
18416  3737 30 04               JR      NC,L370E        ; to RSLT-ZERO
18417  3739             
18418  3739 ED 44               NEG                     ; Negate
18419  373B             
18420  373B             ;; RESULT-OK
18421  373B 77          L370C:  LD      (HL),A          ;
18422  373C C9                  RET                     ; return.
18423  373D             
18424  373D             ; ---
18425  373D             
18426  373D             
18427  373D             ;; RSLT-ZERO
18428  373D EF          L370E:  RST     28H             ;; FP-CALC
18429  373E 02                  DEFB    $02             ;;delete
18430  373F A0                  DEFB    $A0             ;;stk-zero
18431  3740 38                  DEFB    $38             ;;end-calc
18432  3741             
18433  3741 C9                  RET                     ; return.
18434  3742             
18435  3742             
18436  3742             ; --------------------------------
18437  3742             ; THE 'NATURAL LOGARITHM' FUNCTION 
18438  3742             ; --------------------------------
18439  3742             ; (offset $25: 'ln')
18440  3742             ;   Function to calculate the natural logarithm (to the base e ). 
18441  3742             ;   Natural logarithms were devised in 1614 by well-traveled Scotsman John 
18442  3742             ;   Napier who noted
18443  3742             ;   "Nothing doth more molest and hinder calculators than the multiplications,
18444  3742             ;    divisions, square and cubical extractions of great numbers".
18445  3742             ;
18446  3742             ;   Napier's logarithms enabled the above operations to be accomplished by 
18447  3742             ;   simple addition and subtraction simplifying the navigational and 
18448  3742             ;   astronomical calculations which beset his age.
18449  3742             ;   Napier's logarithms were quickly overtaken by logarithms to the base 10
18450  3742             ;   devised, in conjunction with Napier, by Henry Briggs a Cambridge-educated 
18451  3742             ;   professor of Geometry at Oxford University. These simplified the layout
18452  3742             ;   of the tables enabling humans to easily scale calculations.
18453  3742             ;
18454  3742             ;   It is only recently with the introduction of pocket calculators and machines
18455  3742             ;   like the ZX Spectrum that natural logarithms are once more at the fore,
18456  3742             ;   although some computers retain logarithms to the base ten.
18457  3742             ;
18458  3742             ;   'Natural' logarithms are powers to the base 'e', which like 'pi' is a 
18459  3742             ;   naturally occurring number in branches of mathematics.
18460  3742             ;   Like 'pi' also, 'e' is an irrational number and starts 2.718281828...
18461  3742             ;
18462  3742             ;   The tabular use of logarithms was that to multiply two numbers one looked
18463  3742             ;   up their two logarithms in the tables, added them together and then looked 
18464  3742             ;   for the result in a table of antilogarithms to give the desired product.
18465  3742             ;
18466  3742             ;   The EXP function is the BASIC equivalent of a calculator's 'antiln' function 
18467  3742             ;   and by picking any two numbers, 1.72 and 6.89 say,
18468  3742             ;     10 PRINT EXP ( LN 1.72 + LN 6.89 ) 
18469  3742             ;   will give just the same result as
18470  3742             ;     20 PRINT 1.72 * 6.89.
18471  3742             ;   Division is accomplished by subtracting the two logs.
18472  3742             ;
18473  3742             ;   Napier also mentioned "square and cubicle extractions". 
18474  3742             ;   To raise a number to the power 3, find its 'ln', multiply by 3 and find the 
18475  3742             ;   'antiln'.  e.g. PRINT EXP( LN 4 * 3 )  gives 64.
18476  3742             ;   Similarly to find the n'th root divide the logarithm by 'n'.
18477  3742             ;   The ZX81 ROM used PRINT EXP ( LN 9 / 2 ) to find the square root of the 
18478  3742             ;   number 9. The Napieran square root function is just a special case of 
18479  3742             ;   the 'to_power' function. A cube root or indeed any root/power would be just
18480  3742             ;   as simple.
18481  3742             
18482  3742             ;   First test that the argument to LN is a positive, non-zero number.
18483  3742             ;   Error A if the argument is 0 or negative.
18484  3742             
18485  3742             ;; ln
18486  3742 EF          L3713:  RST     28H             ;; FP-CALC
18487  3743 3D                  DEFB    $3D             ;;re-stack
18488  3744 31                  DEFB    $31             ;;duplicate
18489  3745 37                  DEFB    $37             ;;greater-0
18490  3746 00                  DEFB    $00             ;;jump-true
18491  3747 04                  DEFB    $04             ;;to L371C, VALID
18492  3748             
18493  3748 38                  DEFB    $38             ;;end-calc
18494  3749             
18495  3749             
18496  3749             ;; REPORT-Ab
18497  3749 CF          L371A:  RST     08H             ; ERROR-1
18498  374A 09                  DEFB    $09             ; Error Report: Invalid argument
18499  374B             
18500  374B             ;; VALID
18501  374B A0          L371C:  DEFB    $A0             ;;stk-zero              Note. not 
18502  374C 02                  DEFB    $02             ;;delete                necessary.
18503  374D 38                  DEFB    $38             ;;end-calc
18504  374E 7E                  LD      A,(HL)          ;
18505  374F             
18506  374F 36 80               LD      (HL),$80        ;
18507  3751 CD 57 2D            CALL    L2D28           ; routine STACK-A
18508  3754             
18509  3754 EF                  RST     28H             ;; FP-CALC
18510  3755 34                  DEFB    $34             ;;stk-data
18511  3756 38                  DEFB    $38             ;;Exponent: $88, Bytes: 1
18512  3757 00                  DEFB    $00             ;;(+00,+00,+00)
18513  3758 03                  DEFB    $03             ;;subtract
18514  3759 01                  DEFB    $01             ;;exchange
18515  375A 31                  DEFB    $31             ;;duplicate
18516  375B 34                  DEFB    $34             ;;stk-data
18517  375C F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18518  375D 4C CC CC CD         DEFB    $4C,$CC,$CC,$CD ;;
18519  3761 03                  DEFB    $03             ;;subtract
18520  3762 37                  DEFB    $37             ;;greater-0
18521  3763 00                  DEFB    $00             ;;jump-true
18522  3764 08                  DEFB    $08             ;;to L373D, GRE.8
18523  3765             
18524  3765 01                  DEFB    $01             ;;exchange
18525  3766 A1                  DEFB    $A1             ;;stk-one
18526  3767 03                  DEFB    $03             ;;subtract
18527  3768 01                  DEFB    $01             ;;exchange
18528  3769 38                  DEFB    $38             ;;end-calc
18529  376A             
18530  376A 34                  INC     (HL)            ;
18531  376B             
18532  376B EF                  RST     28H             ;; FP-CALC
18533  376C             
18534  376C             ;; GRE.8
18535  376C 01          L373D:  DEFB    $01             ;;exchange
18536  376D 34                  DEFB    $34             ;;stk-data
18537  376E F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18538  376F 31 72 17 F8         DEFB    $31,$72,$17,$F8 ;;
18539  3773 04                  DEFB    $04             ;;multiply
18540  3774 01                  DEFB    $01             ;;exchange
18541  3775 A2                  DEFB    $A2             ;;stk-half
18542  3776 03                  DEFB    $03             ;;subtract
18543  3777 A2                  DEFB    $A2             ;;stk-half
18544  3778 03                  DEFB    $03             ;;subtract
18545  3779 31                  DEFB    $31             ;;duplicate
18546  377A 34                  DEFB    $34             ;;stk-data
18547  377B 32                  DEFB    $32             ;;Exponent: $82, Bytes: 1
18548  377C 20                  DEFB    $20             ;;(+00,+00,+00)
18549  377D 04                  DEFB    $04             ;;multiply
18550  377E A2                  DEFB    $A2             ;;stk-half
18551  377F 03                  DEFB    $03             ;;subtract
18552  3780 8C                  DEFB    $8C             ;;series-0C
18553  3781 11                  DEFB    $11             ;;Exponent: $61, Bytes: 1
18554  3782 AC                  DEFB    $AC             ;;(+00,+00,+00)
18555  3783 14                  DEFB    $14             ;;Exponent: $64, Bytes: 1
18556  3784 09                  DEFB    $09             ;;(+00,+00,+00)
18557  3785 56                  DEFB    $56             ;;Exponent: $66, Bytes: 2
18558  3786 DA A5               DEFB    $DA,$A5         ;;(+00,+00)
18559  3788 59                  DEFB    $59             ;;Exponent: $69, Bytes: 2
18560  3789 30 C5               DEFB    $30,$C5         ;;(+00,+00)
18561  378B 5C                  DEFB    $5C             ;;Exponent: $6C, Bytes: 2
18562  378C 90 AA               DEFB    $90,$AA         ;;(+00,+00)
18563  378E 9E                  DEFB    $9E             ;;Exponent: $6E, Bytes: 3
18564  378F 70 6F 61            DEFB    $70,$6F,$61     ;;(+00)
18565  3792 A1                  DEFB    $A1             ;;Exponent: $71, Bytes: 3
18566  3793 CB DA 96            DEFB    $CB,$DA,$96     ;;(+00)
18567  3796 A4                  DEFB    $A4             ;;Exponent: $74, Bytes: 3
18568  3797 31 9F B4            DEFB    $31,$9F,$B4     ;;(+00)
18569  379A E7                  DEFB    $E7             ;;Exponent: $77, Bytes: 4
18570  379B A0 FE 5C FC         DEFB    $A0,$FE,$5C,$FC ;;
18571  379F EA                  DEFB    $EA             ;;Exponent: $7A, Bytes: 4
18572  37A0 1B 43 CA 36         DEFB    $1B,$43,$CA,$36 ;;
18573  37A4 ED                  DEFB    $ED             ;;Exponent: $7D, Bytes: 4
18574  37A5 A7 9C 7E 5E         DEFB    $A7,$9C,$7E,$5E ;;
18575  37A9 F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18576  37AA 6E 23 80 93         DEFB    $6E,$23,$80,$93 ;;
18577  37AE 04                  DEFB    $04             ;;multiply
18578  37AF 0F                  DEFB    $0F             ;;addition
18579  37B0 38                  DEFB    $38             ;;end-calc
18580  37B1             
18581  37B1 C9                  RET                     ; return.
18582  37B2             
18583  37B2             
18584  37B2             ; -----------------------------
18585  37B2             ; THE 'TRIGONOMETRIC' FUNCTIONS
18586  37B2             ; -----------------------------
18587  37B2             ; Trigonometry is rocket science. It is also used by carpenters and pyramid
18588  37B2             ; builders. 
18589  37B2             ; Some uses can be quite abstract but the principles can be seen in simple
18590  37B2             ; right-angled triangles. Triangles have some special properties -
18591  37B2             ;
18592  37B2             ; 1) The sum of the three angles is always PI radians (180 degrees).
18593  37B2             ;    Very helpful if you know two angles and wish to find the third.
18594  37B2             ; 2) In any right-angled triangle the sum of the squares of the two shorter
18595  37B2             ;    sides is equal to the square of the longest side opposite the right-angle.
18596  37B2             ;    Very useful if you know the length of two sides and wish to know the
18597  37B2             ;    length of the third side.
18598  37B2             ; 3) Functions sine, cosine and tangent enable one to calculate the length 
18599  37B2             ;    of an unknown side when the length of one other side and an angle is 
18600  37B2             ;    known.
18601  37B2             ; 4) Functions arcsin, arccosine and arctan enable one to calculate an unknown
18602  37B2             ;    angle when the length of two of the sides is known.
18603  37B2             
18604  37B2             ; --------------------------------
18605  37B2             ; THE 'REDUCE ARGUMENT' SUBROUTINE
18606  37B2             ; --------------------------------
18607  37B2             ; (offset $39: 'get-argt')
18608  37B2             ;
18609  37B2             ; This routine performs two functions on the angle, in radians, that forms
18610  37B2             ; the argument to the sine and cosine functions.
18611  37B2             ; First it ensures that the angle 'wraps round'. That if a ship turns through 
18612  37B2             ; an angle of, say, 3*PI radians (540 degrees) then the net effect is to turn 
18613  37B2             ; through an angle of PI radians (180 degrees).
18614  37B2             ; Secondly it converts the angle in radians to a fraction of a right angle,
18615  37B2             ; depending within which quadrant the angle lies, with the periodicity 
18616  37B2             ; resembling that of the desired sine value.
18617  37B2             ; The result lies in the range -1 to +1.              
18618  37B2             ;
18619  37B2             ;                     90 deg.
18620  37B2             ; 
18621  37B2             ;                     (pi/2)
18622  37B2             ;              II       +1        I
18623  37B2             ;                       |
18624  37B2             ;        sin+      |\   |   /|    sin+
18625  37B2             ;        cos-      | \  |  / |    cos+
18626  37B2             ;        tan-      |  \ | /  |    tan+
18627  37B2             ;                  |   \|/)  |           
18628  37B2             ; 180 deg. (pi) 0 -|----+----|-- 0  (0)   0 degrees
18629  37B2             ;                  |   /|\   |
18630  37B2             ;        sin-      |  / | \  |    sin-
18631  37B2             ;        cos-      | /  |  \ |    cos+
18632  37B2             ;        tan+      |/   |   \|    tan-
18633  37B2             ;                       |
18634  37B2             ;              III      -1       IV
18635  37B2             ;                     (3pi/2)
18636  37B2             ;
18637  37B2             ;                     270 deg.
18638  37B2             ;
18639  37B2             
18640  37B2             ;; get-argt
18641  37B2 EF          L3783:  RST     28H             ;; FP-CALC      X.
18642  37B3 3D                  DEFB    $3D             ;;re-stack      (not rquired done by mult)
18643  37B4 34                  DEFB    $34             ;;stk-data
18644  37B5 EE                  DEFB    $EE             ;;Exponent: $7E, 
18645  37B6                                             ;;Bytes: 4
18646  37B6 22 F9 83 6E         DEFB    $22,$F9,$83,$6E ;;              X, 1/(2*PI)
18647  37BA 04                  DEFB    $04             ;;multiply      X/(2*PI) = fraction
18648  37BB 31                  DEFB    $31             ;;duplicate
18649  37BC A2                  DEFB    $A2             ;;stk-half
18650  37BD 0F                  DEFB    $0F             ;;addition
18651  37BE 27                  DEFB    $27             ;;int
18652  37BF             
18653  37BF 03                  DEFB    $03             ;;subtract      now range -.5 to .5
18654  37C0             
18655  37C0 31                  DEFB    $31             ;;duplicate
18656  37C1 0F                  DEFB    $0F             ;;addition      now range -1 to 1.
18657  37C2 31                  DEFB    $31             ;;duplicate
18658  37C3 0F                  DEFB    $0F             ;;addition      now range -2 to +2.
18659  37C4             
18660  37C4             ; quadrant I (0 to +1) and quadrant IV (-1 to 0) are now correct.
18661  37C4             ; quadrant II ranges +1 to +2.
18662  37C4             ; quadrant III ranges -2 to -1.
18663  37C4             
18664  37C4 31                  DEFB    $31             ;;duplicate     Y, Y.
18665  37C5 2A                  DEFB    $2A             ;;abs           Y, abs(Y).    range 1 to 2
18666  37C6 A1                  DEFB    $A1             ;;stk-one       Y, abs(Y), 1.
18667  37C7 03                  DEFB    $03             ;;subtract      Y, abs(Y)-1.  range 0 to 1
18668  37C8 31                  DEFB    $31             ;;duplicate     Y, Z, Z.
18669  37C9 37                  DEFB    $37             ;;greater-0     Y, Z, (1/0).
18670  37CA             
18671  37CA C0                  DEFB    $C0             ;;st-mem-0         store as possible sign 
18672  37CB                                             ;;                 for cosine function.
18673  37CB             
18674  37CB 00                  DEFB    $00             ;;jump-true
18675  37CC 04                  DEFB    $04             ;;to L37A1, ZPLUS  with quadrants II and III.
18676  37CD             
18677  37CD             ; else the angle lies in quadrant I or IV and value Y is already correct.
18678  37CD             
18679  37CD 02                  DEFB    $02             ;;delete        Y.   delete the test value.
18680  37CE 38                  DEFB    $38             ;;end-calc      Y.
18681  37CF             
18682  37CF C9                  RET                     ; return.       with Q1 and Q4           >>>
18683  37D0             
18684  37D0             ; ---
18685  37D0             
18686  37D0             ; the branch was here with quadrants II (0 to 1) and III (1 to 0).
18687  37D0             ; Y will hold -2 to -1 if this is quadrant III.
18688  37D0             
18689  37D0             ;; ZPLUS
18690  37D0 A1          L37A1:  DEFB    $A1             ;;stk-one         Y, Z, 1.
18691  37D1 03                  DEFB    $03             ;;subtract        Y, Z-1.       Q3 = 0 to -1
18692  37D2 01                  DEFB    $01             ;;exchange        Z-1, Y.
18693  37D3 36                  DEFB    $36             ;;less-0          Z-1, (1/0).
18694  37D4 00                  DEFB    $00             ;;jump-true       Z-1.
18695  37D5 02                  DEFB    $02             ;;to L37A8, YNEG
18696  37D6                                             ;;if angle in quadrant III
18697  37D6             
18698  37D6             ; else angle is within quadrant II (-1 to 0)
18699  37D6             
18700  37D6 1B                  DEFB    $1B             ;;negate          range +1 to 0.
18701  37D7             
18702  37D7             ;; YNEG
18703  37D7 38          L37A8:  DEFB    $38             ;;end-calc        quadrants II and III correct.
18704  37D8             
18705  37D8 C9                  RET                     ; return.
18706  37D9             
18707  37D9             
18708  37D9             ; ---------------------
18709  37D9             ; THE 'COSINE' FUNCTION
18710  37D9             ; ---------------------
18711  37D9             ; (offset $20: 'cos')
18712  37D9             ; Cosines are calculated as the sine of the opposite angle rectifying the 
18713  37D9             ; sign depending on the quadrant rules. 
18714  37D9             ;
18715  37D9             ;
18716  37D9             ;           /|
18717  37D9             ;        h /y|
18718  37D9             ;         /  |o
18719  37D9             ;        /x  |
18720  37D9             ;       /----|    
18721  37D9             ;         a
18722  37D9             ;
18723  37D9             ; The cosine of angle x is the adjacent side (a) divided by the hypotenuse 1.
18724  37D9             ; However if we examine angle y then a/h is the sine of that angle.
18725  37D9             ; Since angle x plus angle y equals a right-angle, we can find angle y by 
18726  37D9             ; subtracting angle x from pi/2.
18727  37D9             ; However it's just as easy to reduce the argument first and subtract the
18728  37D9             ; reduced argument from the value 1 (a reduced right-angle).
18729  37D9             ; It's even easier to subtract 1 from the angle and rectify the sign.
18730  37D9             ; In fact, after reducing the argument, the absolute value of the argument
18731  37D9             ; is used and rectified using the test result stored in mem-0 by 'get-argt'
18732  37D9             ; for that purpose.
18733  37D9             ;
18734  37D9             
18735  37D9             ;; cos
18736  37D9 EF          L37AA:  RST     28H             ;; FP-CALC              angle in radians.
18737  37DA 39                  DEFB    $39             ;;get-argt              X     reduce -1 to +1 
18738  37DB             
18739  37DB 2A                  DEFB    $2A             ;;abs                   ABS X.   0 to 1
18740  37DC A1                  DEFB    $A1             ;;stk-one               ABS X, 1.
18741  37DD 03                  DEFB    $03             ;;subtract              now opposite angle
18742  37DE                                             ;;                      although sign is -ve.
18743  37DE             
18744  37DE E0                  DEFB    $E0             ;;get-mem-0             fetch the sign indicator
18745  37DF 00                  DEFB    $00             ;;jump-true
18746  37E0 06                  DEFB    $06             ;;fwd to L37B7, C-ENT
18747  37E1                                             ;;forward to common code if in QII or QIII.
18748  37E1             
18749  37E1 1B                  DEFB    $1B             ;;negate                else make sign +ve.
18750  37E2 33                  DEFB    $33             ;;jump
18751  37E3 03                  DEFB    $03             ;;fwd to L37B7, C-ENT
18752  37E4                                             ;; with quadrants I and IV.
18753  37E4             
18754  37E4             ; -------------------
18755  37E4             ; THE 'SINE' FUNCTION
18756  37E4             ; -------------------
18757  37E4             ; (offset $1F: 'sin')
18758  37E4             ; This is a fundamental transcendental function from which others such as cos
18759  37E4             ; and tan are directly, or indirectly, derived.
18760  37E4             ; It uses the series generator to produce Chebyshev polynomials.
18761  37E4             ;
18762  37E4             ;
18763  37E4             ;           /|
18764  37E4             ;        1 / |
18765  37E4             ;         /  |x
18766  37E4             ;        /a  |
18767  37E4             ;       /----|    
18768  37E4             ;         y
18769  37E4             ;
18770  37E4             ; The 'get-argt' function is designed to modify the angle and its sign 
18771  37E4             ; in line with the desired sine value and afterwards it can launch straight
18772  37E4             ; into common code.
18773  37E4             
18774  37E4             ;; sin
18775  37E4 EF          L37B5:  RST     28H             ;; FP-CALC      angle in radians
18776  37E5 39                  DEFB    $39             ;;get-argt      reduce - sign now correct.
18777  37E6             
18778  37E6             ;; C-ENT
18779  37E6 31          L37B7:  DEFB    $31             ;;duplicate
18780  37E7 31                  DEFB    $31             ;;duplicate
18781  37E8 04                  DEFB    $04             ;;multiply
18782  37E9 31                  DEFB    $31             ;;duplicate
18783  37EA 0F                  DEFB    $0F             ;;addition
18784  37EB A1                  DEFB    $A1             ;;stk-one
18785  37EC 03                  DEFB    $03             ;;subtract
18786  37ED             
18787  37ED 86                  DEFB    $86             ;;series-06
18788  37EE 14                  DEFB    $14             ;;Exponent: $64, Bytes: 1
18789  37EF E6                  DEFB    $E6             ;;(+00,+00,+00)
18790  37F0 5C                  DEFB    $5C             ;;Exponent: $6C, Bytes: 2
18791  37F1 1F 0B               DEFB    $1F,$0B         ;;(+00,+00)
18792  37F3 A3                  DEFB    $A3             ;;Exponent: $73, Bytes: 3
18793  37F4 8F 38 EE            DEFB    $8F,$38,$EE     ;;(+00)
18794  37F7 E9                  DEFB    $E9             ;;Exponent: $79, Bytes: 4
18795  37F8 15 63 BB 23         DEFB    $15,$63,$BB,$23 ;;
18796  37FC EE                  DEFB    $EE             ;;Exponent: $7E, Bytes: 4
18797  37FD 92 0D CD ED         DEFB    $92,$0D,$CD,$ED ;;
18798  3801 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
18799  3802 23 5D 1B EA         DEFB    $23,$5D,$1B,$EA ;;
18800  3806 04                  DEFB    $04             ;;multiply
18801  3807 38                  DEFB    $38             ;;end-calc
18802  3808             
18803  3808 C9                  RET                     ; return.
18804  3809             
18805  3809             ; ----------------------
18806  3809             ; THE 'TANGENT' FUNCTION
18807  3809             ; ----------------------
18808  3809             ; (offset $21: 'tan')
18809  3809             ;
18810  3809             ; Evaluates tangent x as    sin(x) / cos(x).
18811  3809             ;
18812  3809             ;
18813  3809             ;           /|
18814  3809             ;        h / |
18815  3809             ;         /  |o
18816  3809             ;        /x  |
18817  3809             ;       /----|    
18818  3809             ;         a
18819  3809             ;
18820  3809             ; the tangent of angle x is the ratio of the length of the opposite side 
18821  3809             ; divided by the length of the adjacent side. As the opposite length can 
18822  3809             ; be calculates using sin(x) and the adjacent length using cos(x) then 
18823  3809             ; the tangent can be defined in terms of the previous two functions.
18824  3809             
18825  3809             ; Error 6 if the argument, in radians, is too close to one like pi/2
18826  3809             ; which has an infinite tangent. e.g. PRINT TAN (PI/2)  evaluates as 1/0.
18827  3809             ; Similarly PRINT TAN (3*PI/2), TAN (5*PI/2) etc.
18828  3809             
18829  3809             ;; tan
18830  3809 EF          L37DA:  RST     28H             ;; FP-CALC          x.
18831  380A 31                  DEFB    $31             ;;duplicate         x, x.
18832  380B 1F                  DEFB    $1F             ;;sin               x, sin x.
18833  380C 01                  DEFB    $01             ;;exchange          sin x, x.
18834  380D 20                  DEFB    $20             ;;cos               sin x, cos x.
18835  380E 05                  DEFB    $05             ;;division          sin x/cos x (= tan x).
18836  380F 38                  DEFB    $38             ;;end-calc          tan x.
18837  3810             
18838  3810 C9                  RET                     ; return.
18839  3811             
18840  3811             ; ---------------------
18841  3811             ; THE 'ARCTAN' FUNCTION
18842  3811             ; ---------------------
18843  3811             ; (Offset $24: 'atn')
18844  3811             ; the inverse tangent function with the result in radians.
18845  3811             ; This is a fundamental transcendental function from which others such as asn
18846  3811             ; and acs are directly, or indirectly, derived.
18847  3811             ; It uses the series generator to produce Chebyshev polynomials.
18848  3811             
18849  3811             ;; atn
18850  3811 CD C6 32    L37E2:  CALL    L3297           ; routine re-stack
18851  3814 7E                  LD      A,(HL)          ; fetch exponent byte.
18852  3815 FE 81               CP      $81             ; compare to that for 'one'
18853  3817 38 0E               JR      C,L37F8         ; forward, if less, to SMALL
18854  3819             
18855  3819 EF                  RST     28H             ;; FP-CALC
18856  381A A1                  DEFB    $A1             ;;stk-one
18857  381B 1B                  DEFB    $1B             ;;negate
18858  381C 01                  DEFB    $01             ;;exchange
18859  381D 05                  DEFB    $05             ;;division
18860  381E 31                  DEFB    $31             ;;duplicate
18861  381F 36                  DEFB    $36             ;;less-0
18862  3820 A3                  DEFB    $A3             ;;stk-pi/2
18863  3821 01                  DEFB    $01             ;;exchange
18864  3822 00                  DEFB    $00             ;;jump-true
18865  3823 06                  DEFB    $06             ;;to L37FA, CASES
18866  3824             
18867  3824 1B                  DEFB    $1B             ;;negate
18868  3825 33                  DEFB    $33             ;;jump
18869  3826 03                  DEFB    $03             ;;to L37FA, CASES
18870  3827             
18871  3827             ;; SMALL
18872  3827 EF          L37F8:  RST     28H             ;; FP-CALC
18873  3828 A0                  DEFB    $A0             ;;stk-zero
18874  3829             
18875  3829             ;; CASES
18876  3829 01          L37FA:  DEFB    $01             ;;exchange
18877  382A 31                  DEFB    $31             ;;duplicate
18878  382B 31                  DEFB    $31             ;;duplicate
18879  382C 04                  DEFB    $04             ;;multiply
18880  382D 31                  DEFB    $31             ;;duplicate
18881  382E 0F                  DEFB    $0F             ;;addition
18882  382F A1                  DEFB    $A1             ;;stk-one
18883  3830 03                  DEFB    $03             ;;subtract
18884  3831 8C                  DEFB    $8C             ;;series-0C
18885  3832 10                  DEFB    $10             ;;Exponent: $60, Bytes: 1
18886  3833 B2                  DEFB    $B2             ;;(+00,+00,+00)
18887  3834 13                  DEFB    $13             ;;Exponent: $63, Bytes: 1
18888  3835 0E                  DEFB    $0E             ;;(+00,+00,+00)
18889  3836 55                  DEFB    $55             ;;Exponent: $65, Bytes: 2
18890  3837 E4 8D               DEFB    $E4,$8D         ;;(+00,+00)
18891  3839 58                  DEFB    $58             ;;Exponent: $68, Bytes: 2
18892  383A 39 BC               DEFB    $39,$BC         ;;(+00,+00)
18893  383C 5B                  DEFB    $5B             ;;Exponent: $6B, Bytes: 2
18894  383D 98 FD               DEFB    $98,$FD         ;;(+00,+00)
18895  383F 9E                  DEFB    $9E             ;;Exponent: $6E, Bytes: 3
18896  3840 00 36 75            DEFB    $00,$36,$75     ;;(+00)
18897  3843 A0                  DEFB    $A0             ;;Exponent: $70, Bytes: 3
18898  3844 DB E8 B4            DEFB    $DB,$E8,$B4     ;;(+00)
18899  3847 63                  DEFB    $63             ;;Exponent: $73, Bytes: 2
18900  3848 42 C4               DEFB    $42,$C4         ;;(+00,+00)
18901  384A E6                  DEFB    $E6             ;;Exponent: $76, Bytes: 4
18902  384B B5 09 36 BE         DEFB    $B5,$09,$36,$BE ;;
18903  384F E9                  DEFB    $E9             ;;Exponent: $79, Bytes: 4
18904  3850 36 73 1B 5D         DEFB    $36,$73,$1B,$5D ;;
18905  3854 EC                  DEFB    $EC             ;;Exponent: $7C, Bytes: 4
18906  3855 D8 DE 63 BE         DEFB    $D8,$DE,$63,$BE ;;
18907  3859 F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18908  385A 61 A1 B3 0C         DEFB    $61,$A1,$B3,$0C ;;
18909  385E 04                  DEFB    $04             ;;multiply
18910  385F 0F                  DEFB    $0F             ;;addition
18911  3860 38                  DEFB    $38             ;;end-calc
18912  3861             
18913  3861 C9                  RET                     ; return.
18914  3862             
18915  3862             
18916  3862             ; ---------------------
18917  3862             ; THE 'ARCSIN' FUNCTION
18918  3862             ; ---------------------
18919  3862             ; (Offset $22: 'asn')
18920  3862             ;   The inverse sine function with result in radians.
18921  3862             ;   Derived from arctan function above.
18922  3862             ;   Error A unless the argument is between -1 and +1 inclusive.
18923  3862             ;   Uses an adaptation of the formula asn(x) = atn(x/sqr(1-x*x))
18924  3862             ;
18925  3862             ;
18926  3862             ;                 /|
18927  3862             ;                / |
18928  3862             ;              1/  |x
18929  3862             ;              /a  |
18930  3862             ;             /----|    
18931  3862             ;               y
18932  3862             ;
18933  3862             ;   e.g. We know the opposite side (x) and hypotenuse (1) 
18934  3862             ;   and we wish to find angle a in radians.
18935  3862             ;   We can derive length y by Pythagoras and then use ATN instead. 
18936  3862             ;   Since y*y + x*x = 1*1 (Pythagoras Theorem) then
18937  3862             ;   y=sqr(1-x*x)                         - no need to multiply 1 by itself.
18938  3862             ;   So, asn(a) = atn(x/y)
18939  3862             ;   or more fully,
18940  3862             ;   asn(a) = atn(x/sqr(1-x*x))
18941  3862             
18942  3862             ;   Close but no cigar.
18943  3862             
18944  3862             ;   While PRINT ATN (x/SQR (1-x*x)) gives the same results as PRINT ASN x,
18945  3862             ;   it leads to division by zero when x is 1 or -1.
18946  3862             ;   To overcome this, 1 is added to y giving half the required angle and the 
18947  3862             ;   result is then doubled. 
18948  3862             ;   That is, PRINT ATN (x/(SQR (1-x*x) +1)) *2
18949  3862             ;
18950  3862             ;   GEOMETRIC PROOF.
18951  3862             ;
18952  3862             ;
18953  3862             ;               . /|
18954  3862             ;            .  c/ |
18955  3862             ;         .     /1 |x
18956  3862             ;      . c   b /a  |
18957  3862             ;    ---------/----|    
18958  3862             ;      1      y
18959  3862             ;
18960  3862             ;   By creating an isosceles triangle with two equal sides of 1, angles c and 
18961  3862             ;   c are also equal. If b+c+c = 180 degrees and b+a = 180 degrees then c=a/2.
18962  3862             ;
18963  3862             ;   A value higher than 1 gives the required error as attempting to find  the
18964  3862             ;   square root of a negative number generates an error in Sinclair BASIC.
18965  3862             
18966  3862             ;; asn
18967  3862 EF          L3833:  RST     28H             ;; FP-CALC      x.
18968  3863 31                  DEFB    $31             ;;duplicate     x, x.
18969  3864 31                  DEFB    $31             ;;duplicate     x, x, x.
18970  3865 04                  DEFB    $04             ;;multiply      x, x*x.
18971  3866 A1                  DEFB    $A1             ;;stk-one       x, x*x, 1.
18972  3867 03                  DEFB    $03             ;;subtract      x, x*x-1.
18973  3868 1B                  DEFB    $1B             ;;negate        x, 1-x*x.
18974  3869 28                  DEFB    $28             ;;sqr           x, sqr(1-x*x) = y
18975  386A A1                  DEFB    $A1             ;;stk-one       x, y, 1.
18976  386B 0F                  DEFB    $0F             ;;addition      x, y+1.
18977  386C 05                  DEFB    $05             ;;division      x/y+1.
18978  386D 24                  DEFB    $24             ;;atn           a/2       (half the angle)
18979  386E 31                  DEFB    $31             ;;duplicate     a/2, a/2.
18980  386F 0F                  DEFB    $0F             ;;addition      a.
18981  3870 38                  DEFB    $38             ;;end-calc      a.
18982  3871             
18983  3871 C9                  RET                     ; return.
18984  3872             
18985  3872             
18986  3872             ; ---------------------
18987  3872             ; THE 'ARCCOS' FUNCTION
18988  3872             ; ---------------------
18989  3872             ; (Offset $23: 'acs')
18990  3872             ; the inverse cosine function with the result in radians.
18991  3872             ; Error A unless the argument is between -1 and +1.
18992  3872             ; Result in range 0 to pi.
18993  3872             ; Derived from asn above which is in turn derived from the preceding atn.
18994  3872             ; It could have been derived directly from atn using acs(x) = atn(sqr(1-x*x)/x).
18995  3872             ; However, as sine and cosine are horizontal translations of each other,
18996  3872             ; uses acs(x) = pi/2 - asn(x)
18997  3872             
18998  3872             ; e.g. the arccosine of a known x value will give the required angle b in 
18999  3872             ; radians.
19000  3872             ; We know, from above, how to calculate the angle a using asn(x). 
19001  3872             ; Since the three angles of any triangle add up to 180 degrees, or pi radians,
19002  3872             ; and the largest angle in this case is a right-angle (pi/2 radians), then
19003  3872             ; we can calculate angle b as pi/2 (both angles) minus asn(x) (angle a).
19004  3872             ; 
19005  3872             ;
19006  3872             ;           /|
19007  3872             ;        1 /b|
19008  3872             ;         /  |x
19009  3872             ;        /a  |
19010  3872             ;       /----|    
19011  3872             ;         y
19012  3872             ;
19013  3872             
19014  3872             ;; acs
19015  3872 EF          L3843:  RST     28H             ;; FP-CALC      x.
19016  3873 22                  DEFB    $22             ;;asn           asn(x).
19017  3874 A3                  DEFB    $A3             ;;stk-pi/2      asn(x), pi/2.
19018  3875 03                  DEFB    $03             ;;subtract      asn(x) - pi/2.
19019  3876 1B                  DEFB    $1B             ;;negate        pi/2 -asn(x)  =  acs(x).
19020  3877 38                  DEFB    $38             ;;end-calc      acs(x).
19021  3878             
19022  3878 C9                  RET                     ; return.
19023  3879             
19024  3879             
19025  3879             ; --------------------------
19026  3879             ; THE 'SQUARE ROOT' FUNCTION
19027  3879             ; --------------------------
19028  3879             ; (Offset $28: 'sqr')
19029  3879             ; This routine is remarkable for its brevity - 7 bytes.
19030  3879             ; It wasn't written here but in the ZX81 where the programmers had to squeeze
19031  3879             ; a bulky operating system into an 8K ROM. It simply calculates 
19032  3879             ; the square root by stacking the value .5 and continuing into the 'to-power'
19033  3879             ; routine. With more space available the much faster Newton-Raphson method
19034  3879             ; could have been used as on the Jupiter Ace.
19035  3879             
19036  3879             ;; sqr
19037  3879 EF          L384A:  RST     28H             ;; FP-CALC
19038  387A 31                  DEFB    $31             ;;duplicate
19039  387B 30                  DEFB    $30             ;;not
19040  387C 00                  DEFB    $00             ;;jump-true
19041  387D 1E                  DEFB    $1E             ;;to L386C, LAST
19042  387E             
19043  387E A2                  DEFB    $A2             ;;stk-half
19044  387F 38                  DEFB    $38             ;;end-calc
19045  3880             
19046  3880             
19047  3880             ; ------------------------------
19048  3880             ; THE 'EXPONENTIATION' OPERATION
19049  3880             ; ------------------------------
19050  3880             ; (Offset $06: 'to-power')
19051  3880             ; This raises the first number X to the power of the second number Y.
19052  3880             ; As with the ZX80,
19053  3880             ; 0 ^ 0 = 1.
19054  3880             ; 0 ^ +n = 0.
19055  3880             ; 0 ^ -n = arithmetic overflow.
19056  3880             ;
19057  3880             
19058  3880             ;; to-power
19059  3880 EF          L3851:  RST     28H             ;; FP-CALC              X, Y.
19060  3881 01                  DEFB    $01             ;;exchange              Y, X.
19061  3882 31                  DEFB    $31             ;;duplicate             Y, X, X.
19062  3883 30                  DEFB    $30             ;;not                   Y, X, (1/0).
19063  3884 00                  DEFB    $00             ;;jump-true
19064  3885 07                  DEFB    $07             ;;to L385D, XIS0   if X is zero.
19065  3886             
19066  3886             ;   else X is non-zero. Function 'ln' will catch a negative value of X.
19067  3886             
19068  3886 25                  DEFB    $25             ;;ln                    Y, LN X.
19069  3887 04                  DEFB    $04             ;;multiply              Y * LN X.
19070  3888 38                  DEFB    $38             ;;end-calc
19071  3889             
19072  3889 C3 F3 36            JP      L36C4           ; jump back to EXP routine   ->
19073  388C             
19074  388C             ; ---
19075  388C             
19076  388C             ;   these routines form the three simple results when the number is zero.
19077  388C             ;   begin by deleting the known zero to leave Y the power factor.
19078  388C             
19079  388C             ;; XIS0
19080  388C 02          L385D:  DEFB    $02             ;;delete                Y.
19081  388D 31                  DEFB    $31             ;;duplicate             Y, Y.
19082  388E 30                  DEFB    $30             ;;not                   Y, (1/0).
19083  388F 00                  DEFB    $00             ;;jump-true
19084  3890 09                  DEFB    $09             ;;to L386A, ONE         if Y is zero.
19085  3891             
19086  3891 A0                  DEFB    $A0             ;;stk-zero              Y, 0.
19087  3892 01                  DEFB    $01             ;;exchange              0, Y.
19088  3893 37                  DEFB    $37             ;;greater-0             0, (1/0).
19089  3894 00                  DEFB    $00             ;;jump-true             0.
19090  3895 06                  DEFB    $06             ;;to L386C, LAST        if Y was any positive 
19091  3896                                             ;;                      number.
19092  3896             
19093  3896             ;   else force division by zero thereby raising an Arithmetic overflow error.
19094  3896             ;   There are some one and two-byte alternatives but perhaps the most formal
19095  3896             ;   might have been to use end-calc; rst 08; defb 05.
19096  3896             
19097  3896 A1                  DEFB    $A1             ;;stk-one               0, 1.
19098  3897 01                  DEFB    $01             ;;exchange              1, 0.
19099  3898 05                  DEFB    $05             ;;division              1/0        ouch!
19100  3899             
19101  3899             ; ---
19102  3899             
19103  3899             ;; ONE
19104  3899 02          L386A:  DEFB    $02             ;;delete                .
19105  389A A1                  DEFB    $A1             ;;stk-one               1.
19106  389B             
19107  389B             ;; LAST
19108  389B 38          L386C:  DEFB    $38             ;;end-calc              last value is 1 or 0.
19109  389C             
19110  389C C9                  RET                     ; return.               
19111  389D             
19112  389D             ;   "Everything should be made as simple as possible, but not simpler"
19113  389D             ;   - Albert Einstein, 1879-1955.
19114  389D             
19115  389D             ; ---------------------
19116  389D             ; THE 'SPARE' LOCATIONS
19117  389D             ; ---------------------
19118  389D             
19119  389D             ;; spare
19120  389D FF FF       L386E:  DEFB    $FF, $FF        ;
19121  389F             
19122  389F             
19123  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19124  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19125  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19126  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19127  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19128  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19129  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19130  389F                     ; DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19131  389F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19131  38A3 FF FF FF FF 
19132  38A7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19132  38AB FF FF FF FF 
19133  38AF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19133  38B3 FF FF FF FF 
19134  38B7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19134  38BB FF FF FF FF 
19135  38BF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19135  38C3 FF FF FF FF 
19136  38C7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19136  38CB FF FF FF FF 
19137  38CF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19137  38D3 FF FF FF FF 
19138  38D7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19138  38DB FF FF FF FF 
19139  38DF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19139  38E3 FF FF FF FF 
19140  38E7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19140  38EB FF FF FF FF 
19141  38EF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19141  38F3 FF FF FF FF 
19142  38F7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19142  38FB FF FF FF FF 
19143  38FF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19143  3903 FF FF FF FF 
19144  3907 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19144  390B FF FF FF FF 
19145  390F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19145  3913 FF FF FF FF 
19146  3917 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19146  391B FF FF FF FF 
19147  391F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19147  3923 FF FF FF FF 
19148  3927 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19148  392B FF FF FF FF 
19149  392F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19149  3933 FF FF FF FF 
19150  3937 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19150  393B FF FF FF FF 
19151  393F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19151  3943 FF FF FF FF 
19152  3947 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19152  394B FF FF FF FF 
19153  394F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19153  3953 FF FF FF FF 
19154  3957 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19154  395B FF FF FF FF 
19155  395F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19155  3963 FF FF FF FF 
19156  3967 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19156  396B FF FF FF FF 
19157  396F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19157  3973 FF FF FF FF 
19158  3977 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19158  397B FF FF FF FF 
19159  397F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19159  3983 FF FF FF FF 
19160  3987 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19160  398B FF FF FF FF 
19161  398F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19161  3993 FF FF FF FF 
19162  3997 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19162  399B FF FF FF FF 
19163  399F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19163  39A3 FF FF FF FF 
19164  39A7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19164  39AB FF FF FF FF 
19165  39AF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19165  39B3 FF FF FF FF 
19166  39B7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19166  39BB FF FF FF FF 
19167  39BF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19167  39C3 FF FF FF FF 
19168  39C7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19168  39CB FF FF FF FF 
19169  39CF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19169  39D3 FF FF FF FF 
19170  39D7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19170  39DB FF FF FF FF 
19171  39DF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19171  39E3 FF FF FF FF 
19172  39E7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19172  39EB FF FF FF FF 
19173  39EF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19173  39F3 FF FF FF FF 
19174  39F7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19174  39FB FF FF FF FF 
19175  39FF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19175  3A03 FF FF FF FF 
19176  3A07 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19176  3A0B FF FF FF FF 
19177  3A0F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19177  3A13 FF FF FF FF 
19178  3A17 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19178  3A1B FF FF FF FF 
19179  3A1F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19179  3A23 FF FF FF FF 
19180  3A27 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19180  3A2B FF FF FF FF 
19181  3A2F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19181  3A33 FF FF FF FF 
19182  3A37 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19182  3A3B FF FF FF FF 
19183  3A3F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19183  3A43 FF FF FF FF 
19184  3A47 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19184  3A4B FF FF FF FF 
19185  3A4F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19185  3A53 FF FF FF FF 
19186  3A57 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19186  3A5B FF FF FF FF 
19187  3A5F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19187  3A63 FF FF FF FF 
19188  3A67 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19188  3A6B FF FF FF FF 
19189  3A6F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19189  3A73 FF FF FF FF 
19190  3A77 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19190  3A7B FF FF FF FF 
19191  3A7F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19191  3A83 FF FF FF FF 
19192  3A87 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19192  3A8B FF FF FF FF 
19193  3A8F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19193  3A93 FF FF FF FF 
19194  3A97 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19194  3A9B FF FF FF FF 
19195  3A9F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19195  3AA3 FF FF FF FF 
19196  3AA7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19196  3AAB FF FF FF FF 
19197  3AAF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19197  3AB3 FF FF FF FF 
19198  3AB7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19198  3ABB FF FF FF FF 
19199  3ABF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19199  3AC3 FF FF FF FF 
19200  3AC7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19200  3ACB FF FF FF FF 
19201  3ACF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19201  3AD3 FF FF FF FF 
19202  3AD7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19202  3ADB FF FF FF FF 
19203  3ADF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19203  3AE3 FF FF FF FF 
19204  3AE7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19204  3AEB FF FF FF FF 
19205  3AEF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19205  3AF3 FF FF FF FF 
19206  3AF7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19206  3AFB FF FF FF FF 
19207  3AFF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19207  3B03 FF FF FF FF 
19208  3B07 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19208  3B0B FF FF FF FF 
19209  3B0F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19209  3B13 FF FF FF FF 
19210  3B17 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19210  3B1B FF FF FF FF 
19211  3B1F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19211  3B23 FF FF FF FF 
19212  3B27 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19212  3B2B FF FF FF FF 
19213  3B2F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19213  3B33 FF FF FF FF 
19214  3B37 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19214  3B3B FF FF FF FF 
19215  3B3F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19215  3B43 FF FF FF FF 
19216  3B47 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19216  3B4B FF FF FF FF 
19217  3B4F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19217  3B53 FF FF FF FF 
19218  3B57 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19218  3B5B FF FF FF FF 
19219  3B5F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19219  3B63 FF FF FF FF 
19220  3B67 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19220  3B6B FF FF FF FF 
19221  3B6F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19221  3B73 FF FF FF FF 
19222  3B77 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19222  3B7B FF FF FF FF 
19223  3B7F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19223  3B83 FF FF FF FF 
19224  3B87 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19224  3B8B FF FF FF FF 
19225  3B8F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19225  3B93 FF FF FF FF 
19226  3B97 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19226  3B9B FF FF FF FF 
19227  3B9F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19227  3BA3 FF FF FF FF 
19228  3BA7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19228  3BAB FF FF FF FF 
19229  3BAF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19229  3BB3 FF FF FF FF 
19230  3BB7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19230  3BBB FF FF FF FF 
19231  3BBF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19231  3BC3 FF FF FF FF 
19232  3BC7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19232  3BCB FF FF FF FF 
19233  3BCF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19233  3BD3 FF FF FF FF 
19234  3BD7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19234  3BDB FF FF FF FF 
19235  3BDF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19235  3BE3 FF FF FF FF 
19236  3BE7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19236  3BEB FF FF FF FF 
19237  3BEF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19237  3BF3 FF FF FF FF 
19238  3BF7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19238  3BFB FF FF FF FF 
19239  3BFF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19239  3C03 FF FF FF FF 
19240  3C07 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19240  3C0B FF FF FF FF 
19241  3C0F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19241  3C13 FF FF FF FF 
19242  3C17 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19242  3C1B FF FF FF FF 
19243  3C1F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19243  3C23 FF FF FF FF 
19244  3C27 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19244  3C2B FF FF FF FF 
19245  3C2F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19245  3C33 FF FF FF FF 
19246  3C37 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19246  3C3B FF FF FF FF 
19247  3C3F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19247  3C43 FF FF FF FF 
19248  3C47 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19248  3C4B FF FF FF FF 
19249  3C4F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19249  3C53 FF FF FF FF 
19250  3C57 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19250  3C5B FF FF FF FF 
19251  3C5F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19251  3C63 FF FF FF FF 
19252  3C67 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19252  3C6B FF FF FF FF 
19253  3C6F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19253  3C73 FF FF FF FF 
19254  3C77 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19254  3C7B FF FF FF FF 
19255  3C7F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19255  3C83 FF FF FF FF 
19256  3C87 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19256  3C8B FF FF FF FF 
19257  3C8F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19257  3C93 FF FF FF FF 
19258  3C97 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19258  3C9B FF FF FF FF 
19259  3C9F FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19259  3CA3 FF FF FF FF 
19260  3CA7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19260  3CAB FF FF FF FF 
19261  3CAF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19261  3CB3 FF FF FF FF 
19262  3CB7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19262  3CBB FF FF FF FF 
19263  3CBF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19263  3CC3 FF FF FF FF 
19264  3CC7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19264  3CCB FF FF FF FF 
19265  3CCF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19265  3CD3 FF FF FF FF 
19266  3CD7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19266  3CDB FF FF FF FF 
19267  3CDF FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19267  3CE3 FF FF FF FF 
19268  3CE7 FF FF FF FF         DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19268  3CEB FF FF FF FF 
19269  3CEF             
19270  3D00             ORG $3D00
19271  3D00             
19272  3D00             ; -------------------------------
19273  3D00             ; THE 'ZX SPECTRUM CHARACTER SET'
19274  3D00             ; -------------------------------
19275  3D00             
19276  3D00             ;; char-set
19277  3D00             
19278  3D00             ; $20 - Character: ' '          CHR$(32)
19279  3D00             
19280  3D00 00          L3D00:  DEFB    %00000000
19281  3D01 00                  DEFB    %00000000
19282  3D02 00                  DEFB    %00000000
19283  3D03 00                  DEFB    %00000000
19284  3D04 00                  DEFB    %00000000
19285  3D05 00                  DEFB    %00000000
19286  3D06 00                  DEFB    %00000000
19287  3D07 00                  DEFB    %00000000
19288  3D08             
19289  3D08             ; $21 - Character: '!'          CHR$(33)
19290  3D08             
19291  3D08 00                  DEFB    %00000000
19292  3D09 10                  DEFB    %00010000
19293  3D0A 10                  DEFB    %00010000
19294  3D0B 10                  DEFB    %00010000
19295  3D0C 10                  DEFB    %00010000
19296  3D0D 00                  DEFB    %00000000
19297  3D0E 10                  DEFB    %00010000
19298  3D0F 00                  DEFB    %00000000
19299  3D10             
19300  3D10             ; $22 - Character: '"'          CHR$(34)
19301  3D10             
19302  3D10 00                  DEFB    %00000000
19303  3D11 24                  DEFB    %00100100
19304  3D12 24                  DEFB    %00100100
19305  3D13 00                  DEFB    %00000000
19306  3D14 00                  DEFB    %00000000
19307  3D15 00                  DEFB    %00000000
19308  3D16 00                  DEFB    %00000000
19309  3D17 00                  DEFB    %00000000
19310  3D18             
19311  3D18             ; $23 - Character: '#'          CHR$(35)
19312  3D18             
19313  3D18 00                  DEFB    %00000000
19314  3D19 24                  DEFB    %00100100
19315  3D1A 7E                  DEFB    %01111110
19316  3D1B 24                  DEFB    %00100100
19317  3D1C 24                  DEFB    %00100100
19318  3D1D 7E                  DEFB    %01111110
19319  3D1E 24                  DEFB    %00100100
19320  3D1F 00                  DEFB    %00000000
19321  3D20             
19322  3D20             ; $24 - Character: '$'          CHR$(36)
19323  3D20             
19324  3D20 00                  DEFB    %00000000
19325  3D21 08                  DEFB    %00001000
19326  3D22 3E                  DEFB    %00111110
19327  3D23 28                  DEFB    %00101000
19328  3D24 3E                  DEFB    %00111110
19329  3D25 0A                  DEFB    %00001010
19330  3D26 3E                  DEFB    %00111110
19331  3D27 08                  DEFB    %00001000
19332  3D28             
19333  3D28             ; $25 - Character: '%'          CHR$(37)
19334  3D28             
19335  3D28 00                  DEFB    %00000000
19336  3D29 62                  DEFB    %01100010
19337  3D2A 64                  DEFB    %01100100
19338  3D2B 08                  DEFB    %00001000
19339  3D2C 10                  DEFB    %00010000
19340  3D2D 26                  DEFB    %00100110
19341  3D2E 46                  DEFB    %01000110
19342  3D2F 00                  DEFB    %00000000
19343  3D30             
19344  3D30             ; $26 - Character: '&'          CHR$(38)
19345  3D30             
19346  3D30 00                  DEFB    %00000000
19347  3D31 10                  DEFB    %00010000
19348  3D32 28                  DEFB    %00101000
19349  3D33 10                  DEFB    %00010000
19350  3D34 2A                  DEFB    %00101010
19351  3D35 44                  DEFB    %01000100
19352  3D36 3A                  DEFB    %00111010
19353  3D37 00                  DEFB    %00000000
19354  3D38             
19355  3D38             ; $27 - Character: '''          CHR$(39)
19356  3D38             
19357  3D38 00                  DEFB    %00000000
19358  3D39 08                  DEFB    %00001000
19359  3D3A 10                  DEFB    %00010000
19360  3D3B 00                  DEFB    %00000000
19361  3D3C 00                  DEFB    %00000000
19362  3D3D 00                  DEFB    %00000000
19363  3D3E 00                  DEFB    %00000000
19364  3D3F 00                  DEFB    %00000000
19365  3D40             
19366  3D40             ; $28 - Character: '('          CHR$(40)
19367  3D40             
19368  3D40 00                  DEFB    %00000000
19369  3D41 04                  DEFB    %00000100
19370  3D42 08                  DEFB    %00001000
19371  3D43 08                  DEFB    %00001000
19372  3D44 08                  DEFB    %00001000
19373  3D45 08                  DEFB    %00001000
19374  3D46 04                  DEFB    %00000100
19375  3D47 00                  DEFB    %00000000
19376  3D48             
19377  3D48             ; $29 - Character: ')'          CHR$(41)
19378  3D48             
19379  3D48 00                  DEFB    %00000000
19380  3D49 20                  DEFB    %00100000
19381  3D4A 10                  DEFB    %00010000
19382  3D4B 10                  DEFB    %00010000
19383  3D4C 10                  DEFB    %00010000
19384  3D4D 10                  DEFB    %00010000
19385  3D4E 20                  DEFB    %00100000
19386  3D4F 00                  DEFB    %00000000
19387  3D50             
19388  3D50             ; $2A - Character: '*'          CHR$(42)
19389  3D50             
19390  3D50 00                  DEFB    %00000000
19391  3D51 00                  DEFB    %00000000
19392  3D52 14                  DEFB    %00010100
19393  3D53 08                  DEFB    %00001000
19394  3D54 3E                  DEFB    %00111110
19395  3D55 08                  DEFB    %00001000
19396  3D56 14                  DEFB    %00010100
19397  3D57 00                  DEFB    %00000000
19398  3D58             
19399  3D58             ; $2B - Character: '+'          CHR$(43)
19400  3D58             
19401  3D58 00                  DEFB    %00000000
19402  3D59 00                  DEFB    %00000000
19403  3D5A 08                  DEFB    %00001000
19404  3D5B 08                  DEFB    %00001000
19405  3D5C 3E                  DEFB    %00111110
19406  3D5D 08                  DEFB    %00001000
19407  3D5E 08                  DEFB    %00001000
19408  3D5F 00                  DEFB    %00000000
19409  3D60             
19410  3D60             ; $2C - Character: ','          CHR$(44)
19411  3D60             
19412  3D60 00                  DEFB    %00000000
19413  3D61 00                  DEFB    %00000000
19414  3D62 00                  DEFB    %00000000
19415  3D63 00                  DEFB    %00000000
19416  3D64 00                  DEFB    %00000000
19417  3D65 08                  DEFB    %00001000
19418  3D66 08                  DEFB    %00001000
19419  3D67 10                  DEFB    %00010000
19420  3D68             
19421  3D68             ; $2D - Character: '-'          CHR$(45)
19422  3D68             
19423  3D68 00                  DEFB    %00000000
19424  3D69 00                  DEFB    %00000000
19425  3D6A 00                  DEFB    %00000000
19426  3D6B 00                  DEFB    %00000000
19427  3D6C 3E                  DEFB    %00111110
19428  3D6D 00                  DEFB    %00000000
19429  3D6E 00                  DEFB    %00000000
19430  3D6F 00                  DEFB    %00000000
19431  3D70             
19432  3D70             ; $2E - Character: '.'          CHR$(46)
19433  3D70             
19434  3D70 00                  DEFB    %00000000
19435  3D71 00                  DEFB    %00000000
19436  3D72 00                  DEFB    %00000000
19437  3D73 00                  DEFB    %00000000
19438  3D74 00                  DEFB    %00000000
19439  3D75 18                  DEFB    %00011000
19440  3D76 18                  DEFB    %00011000
19441  3D77 00                  DEFB    %00000000
19442  3D78             
19443  3D78             ; $2F - Character: '/'          CHR$(47)
19444  3D78             
19445  3D78 00                  DEFB    %00000000
19446  3D79 00                  DEFB    %00000000
19447  3D7A 02                  DEFB    %00000010
19448  3D7B 04                  DEFB    %00000100
19449  3D7C 08                  DEFB    %00001000
19450  3D7D 10                  DEFB    %00010000
19451  3D7E 20                  DEFB    %00100000
19452  3D7F 00                  DEFB    %00000000
19453  3D80             
19454  3D80             ; $30 - Character: '0'          CHR$(48)
19455  3D80             
19456  3D80 00                  DEFB    %00000000
19457  3D81 3C                  DEFB    %00111100
19458  3D82 46                  DEFB    %01000110
19459  3D83 4A                  DEFB    %01001010
19460  3D84 52                  DEFB    %01010010
19461  3D85 62                  DEFB    %01100010
19462  3D86 3C                  DEFB    %00111100
19463  3D87 00                  DEFB    %00000000
19464  3D88             
19465  3D88             ; $31 - Character: '1'          CHR$(49)
19466  3D88             
19467  3D88 00                  DEFB    %00000000
19468  3D89 18                  DEFB    %00011000
19469  3D8A 28                  DEFB    %00101000
19470  3D8B 08                  DEFB    %00001000
19471  3D8C 08                  DEFB    %00001000
19472  3D8D 08                  DEFB    %00001000
19473  3D8E 3E                  DEFB    %00111110
19474  3D8F 00                  DEFB    %00000000
19475  3D90             
19476  3D90             ; $32 - Character: '2'          CHR$(50)
19477  3D90             
19478  3D90 00                  DEFB    %00000000
19479  3D91 3C                  DEFB    %00111100
19480  3D92 42                  DEFB    %01000010
19481  3D93 02                  DEFB    %00000010
19482  3D94 3C                  DEFB    %00111100
19483  3D95 40                  DEFB    %01000000
19484  3D96 7E                  DEFB    %01111110
19485  3D97 00                  DEFB    %00000000
19486  3D98             
19487  3D98             ; $33 - Character: '3'          CHR$(51)
19488  3D98             
19489  3D98 00                  DEFB    %00000000
19490  3D99 3C                  DEFB    %00111100
19491  3D9A 42                  DEFB    %01000010
19492  3D9B 0C                  DEFB    %00001100
19493  3D9C 02                  DEFB    %00000010
19494  3D9D 42                  DEFB    %01000010
19495  3D9E 3C                  DEFB    %00111100
19496  3D9F 00                  DEFB    %00000000
19497  3DA0             
19498  3DA0             ; $34 - Character: '4'          CHR$(52)
19499  3DA0             
19500  3DA0 00                  DEFB    %00000000
19501  3DA1 08                  DEFB    %00001000
19502  3DA2 18                  DEFB    %00011000
19503  3DA3 28                  DEFB    %00101000
19504  3DA4 48                  DEFB    %01001000
19505  3DA5 7E                  DEFB    %01111110
19506  3DA6 08                  DEFB    %00001000
19507  3DA7 00                  DEFB    %00000000
19508  3DA8             
19509  3DA8             ; $35 - Character: '5'          CHR$(53)
19510  3DA8             
19511  3DA8 00                  DEFB    %00000000
19512  3DA9 7E                  DEFB    %01111110
19513  3DAA 40                  DEFB    %01000000
19514  3DAB 7C                  DEFB    %01111100
19515  3DAC 02                  DEFB    %00000010
19516  3DAD 42                  DEFB    %01000010
19517  3DAE 3C                  DEFB    %00111100
19518  3DAF 00                  DEFB    %00000000
19519  3DB0             
19520  3DB0             ; $36 - Character: '6'          CHR$(54)
19521  3DB0             
19522  3DB0 00                  DEFB    %00000000
19523  3DB1 3C                  DEFB    %00111100
19524  3DB2 40                  DEFB    %01000000
19525  3DB3 7C                  DEFB    %01111100
19526  3DB4 42                  DEFB    %01000010
19527  3DB5 42                  DEFB    %01000010
19528  3DB6 3C                  DEFB    %00111100
19529  3DB7 00                  DEFB    %00000000
19530  3DB8             
19531  3DB8             ; $37 - Character: '7'          CHR$(55)
19532  3DB8             
19533  3DB8 00                  DEFB    %00000000
19534  3DB9 7E                  DEFB    %01111110
19535  3DBA 02                  DEFB    %00000010
19536  3DBB 04                  DEFB    %00000100
19537  3DBC 08                  DEFB    %00001000
19538  3DBD 10                  DEFB    %00010000
19539  3DBE 10                  DEFB    %00010000
19540  3DBF 00                  DEFB    %00000000
19541  3DC0             
19542  3DC0             ; $38 - Character: '8'          CHR$(56)
19543  3DC0             
19544  3DC0 00                  DEFB    %00000000
19545  3DC1 3C                  DEFB    %00111100
19546  3DC2 42                  DEFB    %01000010
19547  3DC3 3C                  DEFB    %00111100
19548  3DC4 42                  DEFB    %01000010
19549  3DC5 42                  DEFB    %01000010
19550  3DC6 3C                  DEFB    %00111100
19551  3DC7 00                  DEFB    %00000000
19552  3DC8             
19553  3DC8             ; $39 - Character: '9'          CHR$(57)
19554  3DC8             
19555  3DC8 00                  DEFB    %00000000
19556  3DC9 3C                  DEFB    %00111100
19557  3DCA 42                  DEFB    %01000010
19558  3DCB 42                  DEFB    %01000010
19559  3DCC 3E                  DEFB    %00111110
19560  3DCD 02                  DEFB    %00000010
19561  3DCE 3C                  DEFB    %00111100
19562  3DCF 00                  DEFB    %00000000
19563  3DD0             
19564  3DD0             ; $3A - Character: ':'          CHR$(58)
19565  3DD0             
19566  3DD0 00                  DEFB    %00000000
19567  3DD1 00                  DEFB    %00000000
19568  3DD2 00                  DEFB    %00000000
19569  3DD3 10                  DEFB    %00010000
19570  3DD4 00                  DEFB    %00000000
19571  3DD5 00                  DEFB    %00000000
19572  3DD6 10                  DEFB    %00010000
19573  3DD7 00                  DEFB    %00000000
19574  3DD8             
19575  3DD8             ; $3B - Character: ';'          CHR$(59)
19576  3DD8             
19577  3DD8 00                  DEFB    %00000000
19578  3DD9 00                  DEFB    %00000000
19579  3DDA 10                  DEFB    %00010000
19580  3DDB 00                  DEFB    %00000000
19581  3DDC 00                  DEFB    %00000000
19582  3DDD 10                  DEFB    %00010000
19583  3DDE 10                  DEFB    %00010000
19584  3DDF 20                  DEFB    %00100000
19585  3DE0             
19586  3DE0             ; $3C - Character: '<'          CHR$(60)
19587  3DE0             
19588  3DE0 00                  DEFB    %00000000
19589  3DE1 00                  DEFB    %00000000
19590  3DE2 04                  DEFB    %00000100
19591  3DE3 08                  DEFB    %00001000
19592  3DE4 10                  DEFB    %00010000
19593  3DE5 08                  DEFB    %00001000
19594  3DE6 04                  DEFB    %00000100
19595  3DE7 00                  DEFB    %00000000
19596  3DE8             
19597  3DE8             ; $3D - Character: '='          CHR$(61)
19598  3DE8             
19599  3DE8 00                  DEFB    %00000000
19600  3DE9 00                  DEFB    %00000000
19601  3DEA 00                  DEFB    %00000000
19602  3DEB 3E                  DEFB    %00111110
19603  3DEC 00                  DEFB    %00000000
19604  3DED 3E                  DEFB    %00111110
19605  3DEE 00                  DEFB    %00000000
19606  3DEF 00                  DEFB    %00000000
19607  3DF0             
19608  3DF0             ; $3E - Character: '>'          CHR$(62)
19609  3DF0             
19610  3DF0 00                  DEFB    %00000000
19611  3DF1 00                  DEFB    %00000000
19612  3DF2 10                  DEFB    %00010000
19613  3DF3 08                  DEFB    %00001000
19614  3DF4 04                  DEFB    %00000100
19615  3DF5 08                  DEFB    %00001000
19616  3DF6 10                  DEFB    %00010000
19617  3DF7 00                  DEFB    %00000000
19618  3DF8             
19619  3DF8             ; $3F - Character: '?'          CHR$(63)
19620  3DF8             
19621  3DF8 00                  DEFB    %00000000
19622  3DF9 3C                  DEFB    %00111100
19623  3DFA 42                  DEFB    %01000010
19624  3DFB 04                  DEFB    %00000100
19625  3DFC 08                  DEFB    %00001000
19626  3DFD 00                  DEFB    %00000000
19627  3DFE 08                  DEFB    %00001000
19628  3DFF 00                  DEFB    %00000000
19629  3E00             
19630  3E00             ; $40 - Character: '@'          CHR$(64)
19631  3E00             
19632  3E00 00                  DEFB    %00000000
19633  3E01 3C                  DEFB    %00111100
19634  3E02 4A                  DEFB    %01001010
19635  3E03 56                  DEFB    %01010110
19636  3E04 5E                  DEFB    %01011110
19637  3E05 40                  DEFB    %01000000
19638  3E06 3C                  DEFB    %00111100
19639  3E07 00                  DEFB    %00000000
19640  3E08             
19641  3E08             ; $41 - Character: 'A'          CHR$(65)
19642  3E08             
19643  3E08 00                  DEFB    %00000000
19644  3E09 3C                  DEFB    %00111100
19645  3E0A 42                  DEFB    %01000010
19646  3E0B 42                  DEFB    %01000010
19647  3E0C 7E                  DEFB    %01111110
19648  3E0D 42                  DEFB    %01000010
19649  3E0E 42                  DEFB    %01000010
19650  3E0F 00                  DEFB    %00000000
19651  3E10             
19652  3E10             ; $42 - Character: 'B'          CHR$(66)
19653  3E10             
19654  3E10 00                  DEFB    %00000000
19655  3E11 7C                  DEFB    %01111100
19656  3E12 42                  DEFB    %01000010
19657  3E13 7C                  DEFB    %01111100
19658  3E14 42                  DEFB    %01000010
19659  3E15 42                  DEFB    %01000010
19660  3E16 7C                  DEFB    %01111100
19661  3E17 00                  DEFB    %00000000
19662  3E18             
19663  3E18             ; $43 - Character: 'C'          CHR$(67)
19664  3E18             
19665  3E18 00                  DEFB    %00000000
19666  3E19 3C                  DEFB    %00111100
19667  3E1A 42                  DEFB    %01000010
19668  3E1B 40                  DEFB    %01000000
19669  3E1C 40                  DEFB    %01000000
19670  3E1D 42                  DEFB    %01000010
19671  3E1E 3C                  DEFB    %00111100
19672  3E1F 00                  DEFB    %00000000
19673  3E20             
19674  3E20             ; $44 - Character: 'D'          CHR$(68)
19675  3E20             
19676  3E20 00                  DEFB    %00000000
19677  3E21 78                  DEFB    %01111000
19678  3E22 44                  DEFB    %01000100
19679  3E23 42                  DEFB    %01000010
19680  3E24 42                  DEFB    %01000010
19681  3E25 44                  DEFB    %01000100
19682  3E26 78                  DEFB    %01111000
19683  3E27 00                  DEFB    %00000000
19684  3E28             
19685  3E28             ; $45 - Character: 'E'          CHR$(69)
19686  3E28             
19687  3E28 00                  DEFB    %00000000
19688  3E29 7E                  DEFB    %01111110
19689  3E2A 40                  DEFB    %01000000
19690  3E2B 7C                  DEFB    %01111100
19691  3E2C 40                  DEFB    %01000000
19692  3E2D 40                  DEFB    %01000000
19693  3E2E 7E                  DEFB    %01111110
19694  3E2F 00                  DEFB    %00000000
19695  3E30             
19696  3E30             ; $46 - Character: 'F'          CHR$(70)
19697  3E30             
19698  3E30 00                  DEFB    %00000000
19699  3E31 7E                  DEFB    %01111110
19700  3E32 40                  DEFB    %01000000
19701  3E33 7C                  DEFB    %01111100
19702  3E34 40                  DEFB    %01000000
19703  3E35 40                  DEFB    %01000000
19704  3E36 40                  DEFB    %01000000
19705  3E37 00                  DEFB    %00000000
19706  3E38             
19707  3E38             ; $47 - Character: 'G'          CHR$(71)
19708  3E38             
19709  3E38 00                  DEFB    %00000000
19710  3E39 3C                  DEFB    %00111100
19711  3E3A 42                  DEFB    %01000010
19712  3E3B 40                  DEFB    %01000000
19713  3E3C 4E                  DEFB    %01001110
19714  3E3D 42                  DEFB    %01000010
19715  3E3E 3C                  DEFB    %00111100
19716  3E3F 00                  DEFB    %00000000
19717  3E40             
19718  3E40             ; $48 - Character: 'H'          CHR$(72)
19719  3E40             
19720  3E40 00                  DEFB    %00000000
19721  3E41 42                  DEFB    %01000010
19722  3E42 42                  DEFB    %01000010
19723  3E43 7E                  DEFB    %01111110
19724  3E44 42                  DEFB    %01000010
19725  3E45 42                  DEFB    %01000010
19726  3E46 42                  DEFB    %01000010
19727  3E47 00                  DEFB    %00000000
19728  3E48             
19729  3E48             ; $49 - Character: 'I'          CHR$(73)
19730  3E48             
19731  3E48 00                  DEFB    %00000000
19732  3E49 3E                  DEFB    %00111110
19733  3E4A 08                  DEFB    %00001000
19734  3E4B 08                  DEFB    %00001000
19735  3E4C 08                  DEFB    %00001000
19736  3E4D 08                  DEFB    %00001000
19737  3E4E 3E                  DEFB    %00111110
19738  3E4F 00                  DEFB    %00000000
19739  3E50             
19740  3E50             ; $4A - Character: 'J'          CHR$(74)
19741  3E50             
19742  3E50 00                  DEFB    %00000000
19743  3E51 02                  DEFB    %00000010
19744  3E52 02                  DEFB    %00000010
19745  3E53 02                  DEFB    %00000010
19746  3E54 42                  DEFB    %01000010
19747  3E55 42                  DEFB    %01000010
19748  3E56 3C                  DEFB    %00111100
19749  3E57 00                  DEFB    %00000000
19750  3E58             
19751  3E58             ; $4B - Character: 'K'          CHR$(75)
19752  3E58             
19753  3E58 00                  DEFB    %00000000
19754  3E59 44                  DEFB    %01000100
19755  3E5A 48                  DEFB    %01001000
19756  3E5B 70                  DEFB    %01110000
19757  3E5C 48                  DEFB    %01001000
19758  3E5D 44                  DEFB    %01000100
19759  3E5E 42                  DEFB    %01000010
19760  3E5F 00                  DEFB    %00000000
19761  3E60             
19762  3E60             ; $4C - Character: 'L'          CHR$(76)
19763  3E60             
19764  3E60 00                  DEFB    %00000000
19765  3E61 40                  DEFB    %01000000
19766  3E62 40                  DEFB    %01000000
19767  3E63 40                  DEFB    %01000000
19768  3E64 40                  DEFB    %01000000
19769  3E65 40                  DEFB    %01000000
19770  3E66 7E                  DEFB    %01111110
19771  3E67 00                  DEFB    %00000000
19772  3E68             
19773  3E68             ; $4D - Character: 'M'          CHR$(77)
19774  3E68             
19775  3E68 00                  DEFB    %00000000
19776  3E69 42                  DEFB    %01000010
19777  3E6A 66                  DEFB    %01100110
19778  3E6B 5A                  DEFB    %01011010
19779  3E6C 42                  DEFB    %01000010
19780  3E6D 42                  DEFB    %01000010
19781  3E6E 42                  DEFB    %01000010
19782  3E6F 00                  DEFB    %00000000
19783  3E70             
19784  3E70             ; $4E - Character: 'N'          CHR$(78)
19785  3E70             
19786  3E70 00                  DEFB    %00000000
19787  3E71 42                  DEFB    %01000010
19788  3E72 62                  DEFB    %01100010
19789  3E73 52                  DEFB    %01010010
19790  3E74 4A                  DEFB    %01001010
19791  3E75 46                  DEFB    %01000110
19792  3E76 42                  DEFB    %01000010
19793  3E77 00                  DEFB    %00000000
19794  3E78             
19795  3E78             ; $4F - Character: 'O'          CHR$(79)
19796  3E78             
19797  3E78 00                  DEFB    %00000000
19798  3E79 3C                  DEFB    %00111100
19799  3E7A 42                  DEFB    %01000010
19800  3E7B 42                  DEFB    %01000010
19801  3E7C 42                  DEFB    %01000010
19802  3E7D 42                  DEFB    %01000010
19803  3E7E 3C                  DEFB    %00111100
19804  3E7F 00                  DEFB    %00000000
19805  3E80             
19806  3E80             ; $50 - Character: 'P'          CHR$(80)
19807  3E80             
19808  3E80 00                  DEFB    %00000000
19809  3E81 7C                  DEFB    %01111100
19810  3E82 42                  DEFB    %01000010
19811  3E83 42                  DEFB    %01000010
19812  3E84 7C                  DEFB    %01111100
19813  3E85 40                  DEFB    %01000000
19814  3E86 40                  DEFB    %01000000
19815  3E87 00                  DEFB    %00000000
19816  3E88             
19817  3E88             ; $51 - Character: 'Q'          CHR$(81)
19818  3E88             
19819  3E88 00                  DEFB    %00000000
19820  3E89 3C                  DEFB    %00111100
19821  3E8A 42                  DEFB    %01000010
19822  3E8B 42                  DEFB    %01000010
19823  3E8C 52                  DEFB    %01010010
19824  3E8D 4A                  DEFB    %01001010
19825  3E8E 3C                  DEFB    %00111100
19826  3E8F 00                  DEFB    %00000000
19827  3E90             
19828  3E90             ; $52 - Character: 'R'          CHR$(82)
19829  3E90             
19830  3E90 00                  DEFB    %00000000
19831  3E91 7C                  DEFB    %01111100
19832  3E92 42                  DEFB    %01000010
19833  3E93 42                  DEFB    %01000010
19834  3E94 7C                  DEFB    %01111100
19835  3E95 44                  DEFB    %01000100
19836  3E96 42                  DEFB    %01000010
19837  3E97 00                  DEFB    %00000000
19838  3E98             
19839  3E98             ; $53 - Character: 'S'          CHR$(83)
19840  3E98             
19841  3E98 00                  DEFB    %00000000
19842  3E99 3C                  DEFB    %00111100
19843  3E9A 40                  DEFB    %01000000
19844  3E9B 3C                  DEFB    %00111100
19845  3E9C 02                  DEFB    %00000010
19846  3E9D 42                  DEFB    %01000010
19847  3E9E 3C                  DEFB    %00111100
19848  3E9F 00                  DEFB    %00000000
19849  3EA0             
19850  3EA0             ; $54 - Character: 'T'          CHR$(84)
19851  3EA0             
19852  3EA0 00                  DEFB    %00000000
19853  3EA1 FE                  DEFB    %11111110
19854  3EA2 10                  DEFB    %00010000
19855  3EA3 10                  DEFB    %00010000
19856  3EA4 10                  DEFB    %00010000
19857  3EA5 10                  DEFB    %00010000
19858  3EA6 10                  DEFB    %00010000
19859  3EA7 00                  DEFB    %00000000
19860  3EA8             
19861  3EA8             ; $55 - Character: 'U'          CHR$(85)
19862  3EA8             
19863  3EA8 00                  DEFB    %00000000
19864  3EA9 42                  DEFB    %01000010
19865  3EAA 42                  DEFB    %01000010
19866  3EAB 42                  DEFB    %01000010
19867  3EAC 42                  DEFB    %01000010
19868  3EAD 42                  DEFB    %01000010
19869  3EAE 3C                  DEFB    %00111100
19870  3EAF 00                  DEFB    %00000000
19871  3EB0             
19872  3EB0             ; $56 - Character: 'V'          CHR$(86)
19873  3EB0             
19874  3EB0 00                  DEFB    %00000000
19875  3EB1 42                  DEFB    %01000010
19876  3EB2 42                  DEFB    %01000010
19877  3EB3 42                  DEFB    %01000010
19878  3EB4 42                  DEFB    %01000010
19879  3EB5 24                  DEFB    %00100100
19880  3EB6 18                  DEFB    %00011000
19881  3EB7 00                  DEFB    %00000000
19882  3EB8             
19883  3EB8             ; $57 - Character: 'W'          CHR$(87)
19884  3EB8             
19885  3EB8 00                  DEFB    %00000000
19886  3EB9 42                  DEFB    %01000010
19887  3EBA 42                  DEFB    %01000010
19888  3EBB 42                  DEFB    %01000010
19889  3EBC 42                  DEFB    %01000010
19890  3EBD 5A                  DEFB    %01011010
19891  3EBE 24                  DEFB    %00100100
19892  3EBF 00                  DEFB    %00000000
19893  3EC0             
19894  3EC0             ; $58 - Character: 'X'          CHR$(88)
19895  3EC0             
19896  3EC0 00                  DEFB    %00000000
19897  3EC1 42                  DEFB    %01000010
19898  3EC2 24                  DEFB    %00100100
19899  3EC3 18                  DEFB    %00011000
19900  3EC4 18                  DEFB    %00011000
19901  3EC5 24                  DEFB    %00100100
19902  3EC6 42                  DEFB    %01000010
19903  3EC7 00                  DEFB    %00000000
19904  3EC8             
19905  3EC8             ; $59 - Character: 'Y'          CHR$(89)
19906  3EC8             
19907  3EC8 00                  DEFB    %00000000
19908  3EC9 82                  DEFB    %10000010
19909  3ECA 44                  DEFB    %01000100
19910  3ECB 28                  DEFB    %00101000
19911  3ECC 10                  DEFB    %00010000
19912  3ECD 10                  DEFB    %00010000
19913  3ECE 10                  DEFB    %00010000
19914  3ECF 00                  DEFB    %00000000
19915  3ED0             
19916  3ED0             ; $5A - Character: 'Z'          CHR$(90)
19917  3ED0             
19918  3ED0 00                  DEFB    %00000000
19919  3ED1 7E                  DEFB    %01111110
19920  3ED2 04                  DEFB    %00000100
19921  3ED3 08                  DEFB    %00001000
19922  3ED4 10                  DEFB    %00010000
19923  3ED5 20                  DEFB    %00100000
19924  3ED6 7E                  DEFB    %01111110
19925  3ED7 00                  DEFB    %00000000
19926  3ED8             
19927  3ED8             ; $5B - Character: '['          CHR$(91)
19928  3ED8             
19929  3ED8 00                  DEFB    %00000000
19930  3ED9 0E                  DEFB    %00001110
19931  3EDA 08                  DEFB    %00001000
19932  3EDB 08                  DEFB    %00001000
19933  3EDC 08                  DEFB    %00001000
19934  3EDD 08                  DEFB    %00001000
19935  3EDE 0E                  DEFB    %00001110
19936  3EDF 00                  DEFB    %00000000
19937  3EE0             
19938  3EE0             ; $5C - Character: '\'          CHR$(92)
19939  3EE0             
19940  3EE0 00                  DEFB    %00000000
19941  3EE1 00                  DEFB    %00000000
19942  3EE2 40                  DEFB    %01000000
19943  3EE3 20                  DEFB    %00100000
19944  3EE4 10                  DEFB    %00010000
19945  3EE5 08                  DEFB    %00001000
19946  3EE6 04                  DEFB    %00000100
19947  3EE7 00                  DEFB    %00000000
19948  3EE8             
19949  3EE8             ; $5D - Character: ']'          CHR$(93)
19950  3EE8             
19951  3EE8 00                  DEFB    %00000000
19952  3EE9 70                  DEFB    %01110000
19953  3EEA 10                  DEFB    %00010000
19954  3EEB 10                  DEFB    %00010000
19955  3EEC 10                  DEFB    %00010000
19956  3EED 10                  DEFB    %00010000
19957  3EEE 70                  DEFB    %01110000
19958  3EEF 00                  DEFB    %00000000
19959  3EF0             
19960  3EF0             ; $5E - Character: '^'          CHR$(94)
19961  3EF0             
19962  3EF0 00                  DEFB    %00000000
19963  3EF1 10                  DEFB    %00010000
19964  3EF2 38                  DEFB    %00111000
19965  3EF3 54                  DEFB    %01010100
19966  3EF4 10                  DEFB    %00010000
19967  3EF5 10                  DEFB    %00010000
19968  3EF6 10                  DEFB    %00010000
19969  3EF7 00                  DEFB    %00000000
19970  3EF8             
19971  3EF8             ; $5F - Character: '_'          CHR$(95)
19972  3EF8             
19973  3EF8 00                  DEFB    %00000000
19974  3EF9 00                  DEFB    %00000000
19975  3EFA 00                  DEFB    %00000000
19976  3EFB 00                  DEFB    %00000000
19977  3EFC 00                  DEFB    %00000000
19978  3EFD 00                  DEFB    %00000000
19979  3EFE 00                  DEFB    %00000000
19980  3EFF FF                  DEFB    %11111111
19981  3F00             
19982  3F00             ; $60 - Character: 'eur'        CHR$(96)
19983  3F00             
19984  3F00                     ; DEFB    %00000000
19985  3F00                     ; DEFB    %00011100
19986  3F00                     ; DEFB    %00100010
19987  3F00                     ; DEFB    %01111000
19988  3F00                     ; DEFB    %00100000
19989  3F00                     ; DEFB    %00100000
19990  3F00                     ; DEFB    %01111110
19991  3F00                     ; DEFB    %00000000
19992  3F00             
19993  3F00 00                  DEFB    %00000000
19994  3F01 3C                  DEFB    %00111100
19995  3F02 40                  DEFB    %01000000
19996  3F03 FC                  DEFB    %11111100
19997  3F04 FC                  DEFB    %11111100
19998  3F05 40                  DEFB    %01000000
19999  3F06 3C                  DEFB    %00111100
20000  3F07 00                  DEFB    %00000000
20001  3F08             
20002  3F08             
20003  3F08             ; $61 - Character: 'a'          CHR$(97)
20004  3F08             
20005  3F08 00                  DEFB    %00000000
20006  3F09 00                  DEFB    %00000000
20007  3F0A 38                  DEFB    %00111000
20008  3F0B 04                  DEFB    %00000100
20009  3F0C 3C                  DEFB    %00111100
20010  3F0D 44                  DEFB    %01000100
20011  3F0E 3C                  DEFB    %00111100
20012  3F0F 00                  DEFB    %00000000
20013  3F10             
20014  3F10             ; $62 - Character: 'b'          CHR$(98)
20015  3F10             
20016  3F10 00                  DEFB    %00000000
20017  3F11 20                  DEFB    %00100000
20018  3F12 20                  DEFB    %00100000
20019  3F13 3C                  DEFB    %00111100
20020  3F14 22                  DEFB    %00100010
20021  3F15 22                  DEFB    %00100010
20022  3F16 3C                  DEFB    %00111100
20023  3F17 00                  DEFB    %00000000
20024  3F18             
20025  3F18             ; $63 - Character: 'c'          CHR$(99)
20026  3F18             
20027  3F18 00                  DEFB    %00000000
20028  3F19 00                  DEFB    %00000000
20029  3F1A 1C                  DEFB    %00011100
20030  3F1B 20                  DEFB    %00100000
20031  3F1C 20                  DEFB    %00100000
20032  3F1D 20                  DEFB    %00100000
20033  3F1E 1C                  DEFB    %00011100
20034  3F1F 00                  DEFB    %00000000
20035  3F20             
20036  3F20             ; $64 - Character: 'd'          CHR$(100)
20037  3F20             
20038  3F20 00                  DEFB    %00000000
20039  3F21 04                  DEFB    %00000100
20040  3F22 04                  DEFB    %00000100
20041  3F23 3C                  DEFB    %00111100
20042  3F24 44                  DEFB    %01000100
20043  3F25 44                  DEFB    %01000100
20044  3F26 3C                  DEFB    %00111100
20045  3F27 00                  DEFB    %00000000
20046  3F28             
20047  3F28             ; $65 - Character: 'e'          CHR$(101)
20048  3F28             
20049  3F28 00                  DEFB    %00000000
20050  3F29 00                  DEFB    %00000000
20051  3F2A 38                  DEFB    %00111000
20052  3F2B 44                  DEFB    %01000100
20053  3F2C 78                  DEFB    %01111000
20054  3F2D 40                  DEFB    %01000000
20055  3F2E 3C                  DEFB    %00111100
20056  3F2F 00                  DEFB    %00000000
20057  3F30             
20058  3F30             ; $66 - Character: 'f'          CHR$(102)
20059  3F30             
20060  3F30 00                  DEFB    %00000000
20061  3F31 0C                  DEFB    %00001100
20062  3F32 10                  DEFB    %00010000
20063  3F33 18                  DEFB    %00011000
20064  3F34 10                  DEFB    %00010000
20065  3F35 10                  DEFB    %00010000
20066  3F36 10                  DEFB    %00010000
20067  3F37 00                  DEFB    %00000000
20068  3F38             
20069  3F38             ; $67 - Character: 'g'          CHR$(103)
20070  3F38             
20071  3F38 00                  DEFB    %00000000
20072  3F39 00                  DEFB    %00000000
20073  3F3A 3C                  DEFB    %00111100
20074  3F3B 44                  DEFB    %01000100
20075  3F3C 44                  DEFB    %01000100
20076  3F3D 3C                  DEFB    %00111100
20077  3F3E 04                  DEFB    %00000100
20078  3F3F 38                  DEFB    %00111000
20079  3F40             
20080  3F40             ; $68 - Character: 'h'          CHR$(104)
20081  3F40             
20082  3F40 00                  DEFB    %00000000
20083  3F41 40                  DEFB    %01000000
20084  3F42 40                  DEFB    %01000000
20085  3F43 78                  DEFB    %01111000
20086  3F44 44                  DEFB    %01000100
20087  3F45 44                  DEFB    %01000100
20088  3F46 44                  DEFB    %01000100
20089  3F47 00                  DEFB    %00000000
20090  3F48             
20091  3F48             ; $69 - Character: 'i'          CHR$(105)
20092  3F48             
20093  3F48 00                  DEFB    %00000000
20094  3F49 10                  DEFB    %00010000
20095  3F4A 00                  DEFB    %00000000
20096  3F4B 30                  DEFB    %00110000
20097  3F4C 10                  DEFB    %00010000
20098  3F4D 10                  DEFB    %00010000
20099  3F4E 38                  DEFB    %00111000
20100  3F4F 00                  DEFB    %00000000
20101  3F50             
20102  3F50             ; $6A - Character: 'j'          CHR$(106)
20103  3F50             
20104  3F50 00                  DEFB    %00000000
20105  3F51 04                  DEFB    %00000100
20106  3F52 00                  DEFB    %00000000
20107  3F53 04                  DEFB    %00000100
20108  3F54 04                  DEFB    %00000100
20109  3F55 04                  DEFB    %00000100
20110  3F56 24                  DEFB    %00100100
20111  3F57 18                  DEFB    %00011000
20112  3F58             
20113  3F58             ; $6B - Character: 'k'          CHR$(107)
20114  3F58             
20115  3F58 00                  DEFB    %00000000
20116  3F59 20                  DEFB    %00100000
20117  3F5A 28                  DEFB    %00101000
20118  3F5B 30                  DEFB    %00110000
20119  3F5C 30                  DEFB    %00110000
20120  3F5D 28                  DEFB    %00101000
20121  3F5E 24                  DEFB    %00100100
20122  3F5F 00                  DEFB    %00000000
20123  3F60             
20124  3F60             ; $6C - Character: 'l'          CHR$(108)
20125  3F60             
20126  3F60 00                  DEFB    %00000000
20127  3F61 10                  DEFB    %00010000
20128  3F62 10                  DEFB    %00010000
20129  3F63 10                  DEFB    %00010000
20130  3F64 10                  DEFB    %00010000
20131  3F65 10                  DEFB    %00010000
20132  3F66 0C                  DEFB    %00001100
20133  3F67 00                  DEFB    %00000000
20134  3F68             
20135  3F68             ; $6D - Character: 'm'          CHR$(109)
20136  3F68             
20137  3F68 00                  DEFB    %00000000
20138  3F69 00                  DEFB    %00000000
20139  3F6A 68                  DEFB    %01101000
20140  3F6B 54                  DEFB    %01010100
20141  3F6C 54                  DEFB    %01010100
20142  3F6D 54                  DEFB    %01010100
20143  3F6E 54                  DEFB    %01010100
20144  3F6F 00                  DEFB    %00000000
20145  3F70             
20146  3F70             ; $6E - Character: 'n'          CHR$(110)
20147  3F70             
20148  3F70 00                  DEFB    %00000000
20149  3F71 00                  DEFB    %00000000
20150  3F72 78                  DEFB    %01111000
20151  3F73 44                  DEFB    %01000100
20152  3F74 44                  DEFB    %01000100
20153  3F75 44                  DEFB    %01000100
20154  3F76 44                  DEFB    %01000100
20155  3F77 00                  DEFB    %00000000
20156  3F78             
20157  3F78             ; $6F - Character: 'o'          CHR$(111)
20158  3F78             
20159  3F78 00                  DEFB    %00000000
20160  3F79 00                  DEFB    %00000000
20161  3F7A 38                  DEFB    %00111000
20162  3F7B 44                  DEFB    %01000100
20163  3F7C 44                  DEFB    %01000100
20164  3F7D 44                  DEFB    %01000100
20165  3F7E 38                  DEFB    %00111000
20166  3F7F 00                  DEFB    %00000000
20167  3F80             
20168  3F80             ; $70 - Character: 'p'          CHR$(112)
20169  3F80             
20170  3F80 00                  DEFB    %00000000
20171  3F81 00                  DEFB    %00000000
20172  3F82 78                  DEFB    %01111000
20173  3F83 44                  DEFB    %01000100
20174  3F84 44                  DEFB    %01000100
20175  3F85 78                  DEFB    %01111000
20176  3F86 40                  DEFB    %01000000
20177  3F87 40                  DEFB    %01000000
20178  3F88             
20179  3F88             ; $71 - Character: 'q'          CHR$(113)
20180  3F88             
20181  3F88 00                  DEFB    %00000000
20182  3F89 00                  DEFB    %00000000
20183  3F8A 3C                  DEFB    %00111100
20184  3F8B 44                  DEFB    %01000100
20185  3F8C 44                  DEFB    %01000100
20186  3F8D 3C                  DEFB    %00111100
20187  3F8E 04                  DEFB    %00000100
20188  3F8F 06                  DEFB    %00000110
20189  3F90             
20190  3F90             ; $72 - Character: 'r'          CHR$(114)
20191  3F90             
20192  3F90 00                  DEFB    %00000000
20193  3F91 00                  DEFB    %00000000
20194  3F92 1C                  DEFB    %00011100
20195  3F93 20                  DEFB    %00100000
20196  3F94 20                  DEFB    %00100000
20197  3F95 20                  DEFB    %00100000
20198  3F96 20                  DEFB    %00100000
20199  3F97 00                  DEFB    %00000000
20200  3F98             
20201  3F98             ; $73 - Character: 's'          CHR$(115)
20202  3F98             
20203  3F98 00                  DEFB    %00000000
20204  3F99 00                  DEFB    %00000000
20205  3F9A 38                  DEFB    %00111000
20206  3F9B 40                  DEFB    %01000000
20207  3F9C 38                  DEFB    %00111000
20208  3F9D 04                  DEFB    %00000100
20209  3F9E 78                  DEFB    %01111000
20210  3F9F 00                  DEFB    %00000000
20211  3FA0             
20212  3FA0             ; $74 - Character: 't'          CHR$(116)
20213  3FA0             
20214  3FA0 00                  DEFB    %00000000
20215  3FA1 10                  DEFB    %00010000
20216  3FA2 38                  DEFB    %00111000
20217  3FA3 10                  DEFB    %00010000
20218  3FA4 10                  DEFB    %00010000
20219  3FA5 10                  DEFB    %00010000
20220  3FA6 0C                  DEFB    %00001100
20221  3FA7 00                  DEFB    %00000000
20222  3FA8             
20223  3FA8             ; $75 - Character: 'u'          CHR$(117)
20224  3FA8             
20225  3FA8 00                  DEFB    %00000000
20226  3FA9 00                  DEFB    %00000000
20227  3FAA 44                  DEFB    %01000100
20228  3FAB 44                  DEFB    %01000100
20229  3FAC 44                  DEFB    %01000100
20230  3FAD 44                  DEFB    %01000100
20231  3FAE 38                  DEFB    %00111000
20232  3FAF 00                  DEFB    %00000000
20233  3FB0             
20234  3FB0             ; $76 - Character: 'v'          CHR$(118)
20235  3FB0             
20236  3FB0 00                  DEFB    %00000000
20237  3FB1 00                  DEFB    %00000000
20238  3FB2 44                  DEFB    %01000100
20239  3FB3 44                  DEFB    %01000100
20240  3FB4 28                  DEFB    %00101000
20241  3FB5 28                  DEFB    %00101000
20242  3FB6 10                  DEFB    %00010000
20243  3FB7 00                  DEFB    %00000000
20244  3FB8             
20245  3FB8             ; $77 - Character: 'w'          CHR$(119)
20246  3FB8             
20247  3FB8 00                  DEFB    %00000000
20248  3FB9 00                  DEFB    %00000000
20249  3FBA 44                  DEFB    %01000100
20250  3FBB 54                  DEFB    %01010100
20251  3FBC 54                  DEFB    %01010100
20252  3FBD 54                  DEFB    %01010100
20253  3FBE 28                  DEFB    %00101000
20254  3FBF 00                  DEFB    %00000000
20255  3FC0             
20256  3FC0             ; $78 - Character: 'x'          CHR$(120)
20257  3FC0             
20258  3FC0 00                  DEFB    %00000000
20259  3FC1 00                  DEFB    %00000000
20260  3FC2 44                  DEFB    %01000100
20261  3FC3 28                  DEFB    %00101000
20262  3FC4 10                  DEFB    %00010000
20263  3FC5 28                  DEFB    %00101000
20264  3FC6 44                  DEFB    %01000100
20265  3FC7 00                  DEFB    %00000000
20266  3FC8             
20267  3FC8             ; $79 - Character: 'y'          CHR$(121)
20268  3FC8             
20269  3FC8 00                  DEFB    %00000000
20270  3FC9 00                  DEFB    %00000000
20271  3FCA 44                  DEFB    %01000100
20272  3FCB 44                  DEFB    %01000100
20273  3FCC 44                  DEFB    %01000100
20274  3FCD 3C                  DEFB    %00111100
20275  3FCE 04                  DEFB    %00000100
20276  3FCF 38                  DEFB    %00111000
20277  3FD0             
20278  3FD0             ; $7A - Character: 'z'          CHR$(122)
20279  3FD0             
20280  3FD0 00                  DEFB    %00000000
20281  3FD1 00                  DEFB    %00000000
20282  3FD2 7C                  DEFB    %01111100
20283  3FD3 08                  DEFB    %00001000
20284  3FD4 10                  DEFB    %00010000
20285  3FD5 20                  DEFB    %00100000
20286  3FD6 7C                  DEFB    %01111100
20287  3FD7 00                  DEFB    %00000000
20288  3FD8             
20289  3FD8             ; $7B - Character: '{'          CHR$(123)
20290  3FD8             
20291  3FD8 00                  DEFB    %00000000
20292  3FD9 0E                  DEFB    %00001110
20293  3FDA 08                  DEFB    %00001000
20294  3FDB 30                  DEFB    %00110000
20295  3FDC 08                  DEFB    %00001000
20296  3FDD 08                  DEFB    %00001000
20297  3FDE 0E                  DEFB    %00001110
20298  3FDF 00                  DEFB    %00000000
20299  3FE0             
20300  3FE0             ; $7C - Character: '|'          CHR$(124)
20301  3FE0             
20302  3FE0 00                  DEFB    %00000000
20303  3FE1 08                  DEFB    %00001000
20304  3FE2 08                  DEFB    %00001000
20305  3FE3 08                  DEFB    %00001000
20306  3FE4 08                  DEFB    %00001000
20307  3FE5 08                  DEFB    %00001000
20308  3FE6 08                  DEFB    %00001000
20309  3FE7 00                  DEFB    %00000000
20310  3FE8             
20311  3FE8             ; $7D - Character: '}'          CHR$(125)
20312  3FE8             
20313  3FE8 00                  DEFB    %00000000
20314  3FE9 70                  DEFB    %01110000
20315  3FEA 10                  DEFB    %00010000
20316  3FEB 0C                  DEFB    %00001100
20317  3FEC 10                  DEFB    %00010000
20318  3FED 10                  DEFB    %00010000
20319  3FEE 70                  DEFB    %01110000
20320  3FEF 00                  DEFB    %00000000
20321  3FF0             
20322  3FF0             ; $7E - Character: '~'          CHR$(126)
20323  3FF0             
20324  3FF0 00                  DEFB    %00000000
20325  3FF1 14                  DEFB    %00010100
20326  3FF2 28                  DEFB    %00101000
20327  3FF3 00                  DEFB    %00000000
20328  3FF4 00                  DEFB    %00000000
20329  3FF5 00                  DEFB    %00000000
20330  3FF6 00                  DEFB    %00000000
20331  3FF7 00                  DEFB    %00000000
20332  3FF8             
20333  3FF8             ; $7F - Character: '(c)'        CHR$(127)
20334  3FF8             
20335  3FF8 3C                  DEFB    %00111100
20336  3FF9 42                  DEFB    %01000010
20337  3FFA 99                  DEFB    %10011001
20338  3FFB A1                  DEFB    %10100001
20339  3FFC A1                  DEFB    %10100001
20340  3FFD 99                  DEFB    %10011001
20341  3FFE 42                  DEFB    %01000010
20342  3FFF 3C                  DEFB    %00111100
20343  4000             
20344  4000             
20345  4000             #end                            ; generic cross-assembler directive 
20346  4000             
20347  4000             ; Acknowledgements
20348  4000             ; -----------------
20349  4000             ; Sean Irvine               for default list of section headings
20350  4000             ; Dr. Ian Logan             for labels and functional disassembly.
20351  4000             ; Dr. Frank O'Hara          for labels and functional disassembly.
20352  4000             ;
20353  4000             ; Credits
20354  4000             ; -------
20355  4000             ; Alex Pallero Gonzales     for corrections.
20356  4000             ; Mike Dailly               for comments.
20357  4000             ; Alvin Albrecht            for comments.
20358  4000             ; Andy Styles               for full relocatability implementation and testing.                    testing.
20359  4000             ; Andrew Owen               for ZASM compatibility and format improvements.
20360  4000             
20361  4000             ;   For other assemblers you may have to add directives like these near the 
20362  4000             ;   beginning - see accompanying documentation.
20363  4000             ;   ZASM (MacOs) cross-assembler directives. (uncomment by removing ';' )
20364  4000             ;   #target rom           ; declare target file format as binary.
20365  4000             ;   #code   0,$4000       ; declare code segment.
20366  4000             ;   Also see notes at Address Labels 0609 and 1CA5 if your assembler has 
20367  4000             ;   trouble with expressions.
20368  4000             ;
20369  4000             ;   Note. The Sinclair Interface 1 ROM written by Dr. Ian Logan and Martin 
20370  4000             ;   Brennan calls numerous routines in this ROM.  
20371  4000             ;   Non-standard entry points have a label beginning with X. 
20372  4000             
tasm: Number of errors = 0
